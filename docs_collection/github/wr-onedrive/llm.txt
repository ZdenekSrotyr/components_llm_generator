Directory structure:
└── keboola-wr-onedrive/
    ├── README.md
    ├── composer.json
    ├── composer.lock
    ├── docker-compose.yml
    ├── Dockerfile
    ├── LICENSE
    ├── phpcs.xml
    ├── phpstan.neon
    ├── phpunit.xml.dist
    ├── .dockerignore
    ├── .env.example
    ├── docker/
    │   ├── composer-install.sh
    │   └── php-prod.ini
    ├── src/
    │   ├── Component.php
    │   ├── run.php
    │   ├── Sheet.php
    │   ├── SheetFile.php
    │   ├── SheetProvider.php
    │   ├── Writer.php
    │   ├── Api/
    │   │   ├── Api.php
    │   │   ├── ApiFactory.php
    │   │   ├── FileUploader.php
    │   │   ├── GraphApiFactory.php
    │   │   ├── Helpers.php
    │   │   ├── InsertRowsManager.php
    │   │   ├── WorkbooksFinder.php
    │   │   ├── Batch/
    │   │   │   ├── BatchRequest.php
    │   │   │   └── Request.php
    │   │   ├── Fixtures/
    │   │   │   └── empty.xlsx
    │   │   └── Model/
    │   │       ├── Drive.php
    │   │       ├── File.php
    │   │       ├── Site.php
    │   │       ├── TableHeader.php
    │   │       ├── TableRange.php
    │   │       ├── WorkbookSession.php
    │   │       └── Worksheet.php
    │   ├── Auth/
    │   │   ├── RefreshTokenProvider.php
    │   │   ├── TokenDataManager.php
    │   │   ├── TokenProvider.php
    │   │   └── TokenProviderFactory.php
    │   ├── Configuration/
    │   │   ├── Config.php
    │   │   ├── ConfigDefinition.php
    │   │   ├── CreateWorkbookConfigDefinition.php
    │   │   ├── CreateWorksheetConfigDefinition.php
    │   │   ├── SyncActionConfigDefinition.php
    │   │   └── Parts/
    │   │       ├── WorkbookDefinition.php
    │   │       └── WorksheetDefinition.php
    │   └── Exception/
    │       ├── AccessTokenInitException.php
    │       ├── AccessTokenRefreshException.php
    │       ├── BadRequestException.php
    │       ├── BatchRequestException.php
    │       ├── CsvFileException.php
    │       ├── FileInDriveNotFoundException.php
    │       ├── GatewayTimeoutException.php
    │       ├── InvalidAuthDataException.php
    │       ├── InvalidConfigException.php
    │       ├── InvalidFileTypeException.php
    │       ├── InvalidSessionException.php
    │       ├── ResourceNotFoundException.php
    │       ├── ShareLinkException.php
    │       ├── UnexpectedCountException.php
    │       ├── UnexpectedValueException.php
    │       ├── UserException.php
    │       ├── WorkbookAlreadyExistsException.php
    │       └── WorksheetAlreadyExistsException.php
    ├── tests/
    │   ├── bootstrap.php
    │   ├── api/
    │   │   ├── AuthTest.php
    │   │   ├── BaseTest.php
    │   │   ├── BatchRequestTest.php
    │   │   ├── ClearSheetTest.php
    │   │   ├── CreateEmptyFileTest.php
    │   │   ├── GetSheetIdTest.php
    │   │   ├── GetSheetsTest.php
    │   │   ├── HeaderTest.php
    │   │   ├── InsertRowsTest.php
    │   │   ├── RangeTest.php
    │   │   └── SearchForFileTest.php
    │   ├── datadir/
    │   │   ├── DatadirTest.php
    │   │   ├── DatadirTestsProvider.php
    │   │   ├── create-workbook/
    │   │   │   └── expected-stdout
    │   │   ├── create-workbook-already-exists/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── create-worksheet/
    │   │   │   └── expected-stdout
    │   │   ├── create-worksheet-already-exists/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── escape-expression/
    │   │   │   └── expected-stdout
    │   │   ├── get-worksheets-by-path/
    │   │   │   └── expected-stdout
    │   │   ├── get-worksheets-empty-sheet/
    │   │   │   └── expected-stdout
    │   │   ├── get-worksheets-hidden-sheet/
    │   │   │   └── expected-stdout
    │   │   ├── get-worksheets-invalid-drive-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── get-worksheets-invalid-file-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── get-worksheets-invalid-file-type/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── get-worksheets-many-sheets/
    │   │   │   └── expected-stdout
    │   │   ├── get-worksheets-not-found-drive-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── get-worksheets-not-found-file-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── get-worksheets-one-sheet/
    │   │   │   └── expected-stdout
    │   │   ├── search-file-path-drive/
    │   │   │   └── expected-stdout
    │   │   ├── search-file-path-drive-me/
    │   │   │   └── expected-stdout
    │   │   ├── search-file-path-drive-site/
    │   │   │   └── expected-stdout
    │   │   ├── search-file-path-not-found/
    │   │   │   └── expected-stdout
    │   │   ├── search-sharing-link/
    │   │   │   └── expected-stdout
    │   │   ├── search-sharing-link-not-found/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── write-append-empty-file/
    │   │   │   └── expected-stdout
    │   │   ├── write-append-hidden-sheet/
    │   │   │   ├── expected-stderr
    │   │   │   └── expected-stdout
    │   │   ├── write-append-one-sheet-file/
    │   │   │   ├── expected-stderr
    │   │   │   └── expected-stdout
    │   │   ├── write-empty-csv-file/
    │   │   │   ├── expected-stderr
    │   │   │   └── expected-stdout
    │   │   ├── write-file-invalid-drive-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── write-file-invalid-file-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── write-file-not-found-drive-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── write-file-not-found-file-id/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── write-file-path-drive/
    │   │   │   └── expected-stdout
    │   │   ├── write-file-path-drive-me/
    │   │   │   └── expected-stdout
    │   │   ├── write-file-path-drive-site/
    │   │   │   └── expected-stdout
    │   │   ├── write-file-path-not-found-created-append/
    │   │   │   └── expected-stdout
    │   │   ├── write-file-path-not-found-created-overwrite/
    │   │   │   └── expected-stdout
    │   │   ├── write-multiple-csv-files/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── write-no-csv-file/
    │   │   │   ├── expected-code
    │   │   │   └── expected-stderr
    │   │   ├── write-overwrite-empty-file/
    │   │   │   └── expected-stdout
    │   │   ├── write-overwrite-hidden-sheet/
    │   │   │   └── expected-stdout
    │   │   ├── write-overwrite-one-sheet-file/
    │   │   │   └── expected-stdout
    │   │   ├── write-rename-sheet/
    │   │   │   └── expected-stdout
    │   │   ├── write-same-sheet-name/
    │   │   │   └── expected-stdout
    │   │   ├── write-sheet-by-id/
    │   │   │   └── expected-stdout
    │   │   ├── write-sheet-by-name-found/
    │   │   │   └── expected-stdout
    │   │   ├── write-sheet-by-name-not-found-created-append/
    │   │   │   └── expected-stdout
    │   │   └── write-sheet-by-name-not-found-created-overwrite/
    │   │       └── expected-stdout
    │   ├── fixtures/
    │   │   ├── Drive.php
    │   │   ├── File.php
    │   │   ├── FixturesApi.php
    │   │   ├── FixturesCatalog.php
    │   │   ├── FixturesUtils.php
    │   │   └── WorksheetContent.php
    │   └── phpunit/
    │       ├── ErrorResponseHandlingTest.php
    │       ├── HelpersTest.php
    │       ├── HttpClientMockBuilder.php
    │       ├── TableHeaderTest.php
    │       ├── TableRangeTest.php
    │       └── Config/
    │           ├── BaseConfigTest.php
    │           ├── CreateWorkbookConfigTest.php
    │           ├── CreateWorksheetConfigTest.php
    │           ├── RunConfigTest.php
    │           └── SyncActionConfigTest.php
    ├── utils/
    │   ├── oauth-app-list.sh
    │   ├── oauth-app-registration.sh
    │   └── oauth-login.sh
    └── .github/
        └── workflows/
            └── push.yml

================================================
FILE: README.md
================================================
# Keboola OneDrive Writer

[![Build Status](https://travis-ci.com/keboola/wr-onedrive.svg?branch=master)](https://travis-ci.com/keboola/wr-onedrive)

Exports spreadsheets to OneDrive

## Configuration

The configuration `config.json` contains following properties in `parameters` key: 

- `append` - bool (optional): if sheet exists, rows are appended to the end, default false
- `batchSize` - int (optional): number of the rows in one batch / insert API call, default `10 000`
- `workbook` - object (required): Workbook `XLSX` file. [Read more](#workbook).
   - One of [`driveId` and `fileId`] or `path` must be configured.
    - `driveId` - string: id of [drive resource](https://docs.microsoft.com/en-us/graph/api/resources/drive?view=graph-rest-1.0)    
    - `fileId` - string: id of [driveItem resource](https://docs.microsoft.com/en-us/graph/api/resources/driveitem?view=graph-rest-1.0)
    - `path` - string: format see below 
    - `metadata` - object (optional): 
       - Serves to store human-readable data when `driveId` / `fileId` are used to define `workbook`.
       - The component code is not using content of this metadata. 
       - UI can use it to store and later show metadata from FilePicker.
- `worksheet` - object (required): Worksheet, one sheet from workbook's sheets. [Read more](#worksheet).
    - One of `id`, `position` or `name` must be configured.
    - If `id` is set, then `position` cannot be set and vice versa, but `name` can always be present.
    - `id` - string: id of [worksheet resource](https://docs.microsoft.com/en-us/graph/api/resources/worksheet?view=graph-rest-1.0)
    - `name` - string: worksheet name
    - `position` - int: worksheet position, first is 0, hidden sheets are included
    - `metadata` - object (optional): 
       - Serves to store human-readable data (eg. sheet name ) when `id` is used to define `worksheet`.
       - The component code is not using content of this metadata.
       - UI can use it to store and later show metadata from FilePicker.

### Workbook
- Specified by one of [`driveId` and `fileId`] or `path` (not both).
- If file doesn't exist and `path` is set, then a new file will be created, otherwise error.
- Parameter `path` can take several forms:
  - **`/path/to/file.xlsx`**
    - The file is searched on a personal OneDrive that belongs to the logged-in account.
  - **`https://...`**
    - The file is searched by sharing link obtained from OneDrive.
    - The copied URL of an opened OneDrive Excel file should also work.
  - **`drive://{driveId}/path/to/file.xlsx`**
    - The file is searched on drive specified with `{driveId}`
    - The `{driveId}` value must be correctly url-encoded
  - **`site://{siteName}/path/to/file.xlsx`**
    - The file is searched on SharePoint site drive specified with `{siteName}`, eg. `Excel Sheets`
    - The `{siteName}` value must be correctly url-encoded

### Worksheet
- Specified by `id`, `position` or `name`.
- Keys `id` and `position` cannot be used together.
- Keys `id` and `position` take precedence over the `name` if it is also set. 
- The sheet is renamed if sheet's and configured `name` is different.  
- If sheet with the configured `name` doesn't exist, then is created.
 

**Examples of `config.json`**

Output workbook and worksheet configured by IDs.
```json
{
  "authorization": {"oauth_api":  "..."},
  "parameters": {
    "append": true,
    "workbook": {
      "driveId": "...",
      "fileId": "..."
    },
    "worksheet": {
      "id": "..."
    }
  }
}
```

Output workbook configured by `path` and worksheet by `position`.  
If the file does not exist, it is created.
```json
{
  "authorization": {"oauth_api":  "..."},
  "parameters": {
    "workbook": {
      "search": "/path/to/my/file.xlsx"
    },
    "worksheet": {
      "position": 0
    }
  }
}
```


## Actions

Read more about actions [in KBC documentation](https://developers.keboola.com/extend/common-interface/actions/).

### Create Workbook

- Action `createWorkbook` serves to create a new workbook - XLSX file.
- Workbook must be defined by `parameters.workbook.path`, for format see [Workbook](#workbook).

**Example `config.json`**:
```json
{
  "authorization": {"oauth_api":  "..."},
  "action": "createWorkbook",
  "parameters": {
    "workbook": {
      "path": "site://Excel+Sheets/path/to/file.xlsx"
    }
  }
}
```

**Example result**:
```json
{
  "file": {
    "driveId": "...",
    "fileId": "..."
  }
}
```

### Create Worksheet

- Action `createWorksheet` serves to create a new worksheet in workbook.
- Parent `workbook` must be defined by [`driveId` and `fileId`] or `path`, see [Workbook](#workbook).
- The new worksheet must be defined by `parameters.worksheet.name`, see [Worksheet](#worksheet).

**Example `config.json`**:
```json
{
  "authorization": {"oauth_api":  "..."},
  "action": "createWorksheet",
  "parameters": {
    "workbook": {
      "driveId": "...",
      "fileId": "..."
    },
    "worksheet": {
      "name": "New Sheet"
    }
  }
}
```

**Example result**:
```json
{
  "worksheet": {
    "driveId": "...",
    "fileId": "...",
    "worksheetId": "..."
  }
}
```

### Search Action

- Action `search` serves to get `driveId` and `fileId` of spreadsheet `XLSX` file.
- Obtained `driveId` and `fileId` can be later used as export target.
- If file is not found, result is `{"file": null}`.

**Example `config.json`**:
```json
{
  "authorization": {"oauth_api":  "..."},
  "action": "search",
  "parameters": {
    "workbook": {
      "path": "https://.../sharing/link/from/OneDrive/...."
    }
  }
}
```

**Example result**:
```json
{
  "file": {
    "driveId":"...",
    "fileId":"...",
    "name":"one_sheet.xlsx",
    "path":"/path/to/folder"
  }
}
```

### Get Worksheets Action

Action `getWorksheets` serves to list all worksheets (tabs) from workbook `XSLX` file.

**Example `config.json`**:

Workbook configured by `driveId` and `fileId`

```json
{
  "authorization": {"oauth_api":  "..."},
  "action": "getWorksheets",
  "parameters": {
    "workbook": {
      "driveId": "...",
      "fileId": "..."
    }
  }
}
```

Workbook configured by `path`. If workbook is not found action results to `UserException`.

```json
{
  "authorization": {"oauth_api":  "..."},
  "action": "getWorksheets",
  "parameters": {
    "workbook": {
      "path": "site://Excel+Sheets/path/to/file.xlsx"
    }
  }
}
```


**Example result**:
```json
{
   "worksheets":[
      {
         "position":0,
         "name":"Hidden Sheet",
         "title":"Hidden Sheet (hidden)",
         "driveId":"...",
         "fileId":"...",
         "worksheetId":"...",
         "visible":false,
         "header":[
            "Col_1",
            "Col_2",
            "Col_3"
         ]
      }
   ]
}
```
## Development

For development it is necessary to:
  - Have an [Application in Microsoft identity platform](#application-in-microsoft-identity-platform)
    - Env variables: `OAUTH_APP_NAME`, `OAUTH_APP_ID`, `OAUTH_APP_SECRET`
    - You can use script to create app: `utils/oauth-app-setup.sh` 
    - Permissions (scopes) `offline_access User.Read Files.ReadWrite.All Sites.ReadWrite.All`.
  - Be logged in some OneDrive Business (Office 365) Account and have [OAuth tokens](#oauth-tokens)
    - Env variables: `OAUTH_ACCESS_TOKEN`, `OAUTH_REFRESH_TOKEN`, `TEST_SHAREPOINT_SITE`
    - To log in you can use script: `utils/oauth-login.sh` 

### Application in Microsoft identity platform 

- Component uses [Microsoft Graph API](https://developer.microsoft.com/en-us/graph) to connect to user's OneDrive.
- So for development you need access to some Microsoft application:
    - If you are Keboola employee, you can use existing app `wr-onedrive-dev-test`. Credentials are stored in [1Password](https://1password.com).
    - Or if you have work account on [portal.azure.com](https://portal.azure.com), you can create new app by `utils/oauth-app-setup.sh`
    - Or you can have personal account on [portal.azure.com](https://portal.azure.com). App can be created manually in `App registrations` section.
- To access all types of accounts (personal / work / school):
    - Property `signInAudience` must be set to `AzureADandPersonalMicrosoftAccount`. 
    - You can check it in Azure Portal, in app detail, in `Manifest` section.
- At least one `Redirect URIs` must be set:
    - Open `portal.azure.com` -> `App registrations` -> app-name -> `Authentication`
    - In `Web` -> `Redirect URIs` click `Add URI`
    - For development you should add `http://localhost:10000/sign-in/callback`.
    - Click `Save`
- If you have an application set, please store credentials in `.env` file.
```.env
OAUTH_APP_NAME=my-app-name
OAUTH_APP_ID=...
OAUTH_APP_SECRET=...
```

### OAuth tokens

- OAuth tokens are result of login to specific OneDrive account.
- OAuth login is not part of this repository. It is done in other parts of KBC, see [OAuth 2.0 Authentication](https://developers.keboola.com/extend/generic-extractor/configuration/api/authentication/oauth20/).
- Component uses the OAuth tokens to authorize to Graph API.
- The `access_token` and `refresh_token` are part of `config.json` in `authorization.oauth_api.credentials.#data`.
- Component uses `refresh_token` (expires in 90 days) to generate new `access_token` (expires in 1 hour).
- For development / tests you must obtain this token manually:
    1. Setup environment variables `OAUTH_APP_NAME`, `OAUTH_APP_ID`, `OAUTH_APP_SECRET`
        - If are present in `.env` file, the script loads them.
    2. Run script `utils/oauth-login.sh`
    3. Follow the instructions (open the URL and login)
    4. Save tokens to `.env` file
 
### Workspace setup

Clone this repository and init the workspace with following command:

```sh
git clone https://github.com/keboola/wr-onedrive
cd wr-onedrive
docker-compose build
docker-compose run --rm dev composer install --no-scripts
```

Create `.env` file with following variables (from the previous steps)
```env
OAUTH_APP_NAME=
OAUTH_APP_ID=
OAUTH_APP_SECRET=
OAUTH_ACCESS_TOKEN=
OAUTH_REFRESH_TOKEN=
TEST_SHAREPOINT_SITE=(optional)
```

Run the test suite using this command:

```sh
docker-compose run --rm dev composer tests
```

## License

MIT licensed, see [LICENSE](./LICENSE) file.



================================================
FILE: composer.json
================================================
{
    "name": "keboola/wr-onedrive",
    "type": "project",
    "license": "MIT",
    "description": "Exports spreadsheets to OneDrive",
    "keywords": [
        "keboola",
        "docker",
        "component",
        "onedrive"
    ],
    "autoload": {
        "psr-4": {
            "Keboola\\OneDriveWriter\\": "src"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Keboola\\OneDriveWriter\\Fixtures\\": "tests/fixtures/",
            "Keboola\\OneDriveWriter\\Tests\\": "tests/phpunit/",
            "Keboola\\OneDriveWriter\\ApiTests\\": "tests/api/",
            "Keboola\\OneDriveWriter\\DataDirTests\\": "tests/datadir/"
        }
    },
    "require": {
        "php": "^7.4",
        "ext-intl": "*",
        "ext-json": "*",
        "ext-mbstring": "*",
        "keboola/csv": "^2.1",
        "keboola/php-component": "^8.1",
        "keboola/retry": "^0.5.0",
        "league/oauth2-client": "^2.4",
        "microsoft/microsoft-graph": "^1.13",
        "symfony/finder": "^5.0"
    },
    "require-dev": {
        "php-parallel-lint/php-parallel-lint": "^1.2",
        "keboola/coding-standard": ">=7.0.2",
        "keboola/datadir-tests": "^4.0",
        "keboola/php-temp": "^2.0",
        "phpstan/phpstan": "^0.12.14",
        "phpunit/phpunit": "^9.0",
        "symfony/process": "^5.0"
    },
    "scripts": {
        "tests-phpunit": "phpunit",
        "tests-api": "phpunit tests/api",
        "tests-datadir": "phpunit tests/datadir",
        "tests": [
            "@tests-phpunit",
            "@tests-api",
            "@tests-datadir"
        ],

        "phpstan": "phpstan analyse ./src ./tests --level=max --no-progress -c phpstan.neon",
        "phpcs": "phpcs -n --ignore=vendor --extensions=php .",
        "phpcbf": "phpcbf -n --ignore=vendor --extensions=php .",
        "phplint": "parallel-lint -j 10 --exclude vendor .",
        "build": [
            "@phplint",
            "@phpcs",
            "@phpstan",
            "@tests"
        ],
        "ci": [
            "@composer validate --no-check-publish --no-check-all",
            "@build"
        ]
    },
    "config": {
        "sort-packages": true,
        "optimize-autoloader": true
    }
}



================================================
FILE: composer.lock
================================================
{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
        "This file is @generated automatically"
    ],
    "content-hash": "77098265d982c806e4747358bcb29319",
    "packages": [
        {
            "name": "guzzlehttp/guzzle",
            "version": "6.5.2",
            "source": {
                "type": "git",
                "url": "https://github.com/guzzle/guzzle.git",
                "reference": "43ece0e75098b7ecd8d13918293029e555a50f82"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/guzzle/guzzle/zipball/43ece0e75098b7ecd8d13918293029e555a50f82",
                "reference": "43ece0e75098b7ecd8d13918293029e555a50f82",
                "shasum": ""
            },
            "require": {
                "ext-json": "*",
                "guzzlehttp/promises": "^1.0",
                "guzzlehttp/psr7": "^1.6.1",
                "php": ">=5.5"
            },
            "require-dev": {
                "ext-curl": "*",
                "phpunit/phpunit": "^4.8.35 || ^5.7 || ^6.4 || ^7.0",
                "psr/log": "^1.1"
            },
            "suggest": {
                "ext-intl": "Required for Internationalized Domain Name (IDN) support",
                "psr/log": "Required for using the Log middleware"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "6.5-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "GuzzleHttp\\": "src/"
                },
                "files": [
                    "src/functions_include.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Michael Dowling",
                    "email": "mtdowling@gmail.com",
                    "homepage": "https://github.com/mtdowling"
                }
            ],
            "description": "Guzzle is a PHP HTTP client library",
            "homepage": "http://guzzlephp.org/",
            "keywords": [
                "client",
                "curl",
                "framework",
                "http",
                "http client",
                "rest",
                "web service"
            ],
            "time": "2019-12-23T11:57:10+00:00"
        },
        {
            "name": "guzzlehttp/promises",
            "version": "v1.3.1",
            "source": {
                "type": "git",
                "url": "https://github.com/guzzle/promises.git",
                "reference": "a59da6cf61d80060647ff4d3eb2c03a2bc694646"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/guzzle/promises/zipball/a59da6cf61d80060647ff4d3eb2c03a2bc694646",
                "reference": "a59da6cf61d80060647ff4d3eb2c03a2bc694646",
                "shasum": ""
            },
            "require": {
                "php": ">=5.5.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^4.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.4-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "GuzzleHttp\\Promise\\": "src/"
                },
                "files": [
                    "src/functions_include.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Michael Dowling",
                    "email": "mtdowling@gmail.com",
                    "homepage": "https://github.com/mtdowling"
                }
            ],
            "description": "Guzzle promises library",
            "keywords": [
                "promise"
            ],
            "time": "2016-12-20T10:07:11+00:00"
        },
        {
            "name": "guzzlehttp/psr7",
            "version": "1.6.1",
            "source": {
                "type": "git",
                "url": "https://github.com/guzzle/psr7.git",
                "reference": "239400de7a173fe9901b9ac7c06497751f00727a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/guzzle/psr7/zipball/239400de7a173fe9901b9ac7c06497751f00727a",
                "reference": "239400de7a173fe9901b9ac7c06497751f00727a",
                "shasum": ""
            },
            "require": {
                "php": ">=5.4.0",
                "psr/http-message": "~1.0",
                "ralouphie/getallheaders": "^2.0.5 || ^3.0.0"
            },
            "provide": {
                "psr/http-message-implementation": "1.0"
            },
            "require-dev": {
                "ext-zlib": "*",
                "phpunit/phpunit": "~4.8.36 || ^5.7.27 || ^6.5.8"
            },
            "suggest": {
                "zendframework/zend-httphandlerrunner": "Emit PSR-7 responses"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.6-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "GuzzleHttp\\Psr7\\": "src/"
                },
                "files": [
                    "src/functions_include.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Michael Dowling",
                    "email": "mtdowling@gmail.com",
                    "homepage": "https://github.com/mtdowling"
                },
                {
                    "name": "Tobias Schultze",
                    "homepage": "https://github.com/Tobion"
                }
            ],
            "description": "PSR-7 message implementation that also provides common utility methods",
            "keywords": [
                "http",
                "message",
                "psr-7",
                "request",
                "response",
                "stream",
                "uri",
                "url"
            ],
            "time": "2019-07-01T23:21:34+00:00"
        },
        {
            "name": "keboola/common-exceptions",
            "version": "1.0.1",
            "source": {
                "type": "git",
                "url": "https://github.com/keboola/common-exceptions.git",
                "reference": "44bff6e6d1f8edfb81af7662bc231566dcecb241"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/keboola/common-exceptions/zipball/44bff6e6d1f8edfb81af7662bc231566dcecb241",
                "reference": "44bff6e6d1f8edfb81af7662bc231566dcecb241",
                "shasum": ""
            },
            "require": {
                "php": "^7.1"
            },
            "require-dev": {
                "jakub-onderka/php-parallel-lint": "^1.0",
                "keboola/coding-standard": ">=7.0.2",
                "keboola/php-temp": "^1.0",
                "phpstan/phpstan-shim": "^0.10.6",
                "phpunit/phpunit": "^7.0"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Keboola\\CommonExceptions\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "Common exceptions shared between different applications",
            "time": "2019-11-21T11:09:10+00:00"
        },
        {
            "name": "keboola/csv",
            "version": "2.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/keboola/php-csv.git",
                "reference": "86f03def371e5b1a8a11973b496c86d3a0d4d57d"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/keboola/php-csv/zipball/86f03def371e5b1a8a11973b496c86d3a0d4d57d",
                "reference": "86f03def371e5b1a8a11973b496c86d3a0d4d57d",
                "shasum": ""
            },
            "require": {
                "php": ">=5.6"
            },
            "require-dev": {
                "phpunit/phpunit": "^5.7",
                "squizlabs/php_codesniffer": "^3.2"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Keboola\\Csv\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Keboola",
                    "email": "devel@keboola.com"
                }
            ],
            "description": "Keboola CSV reader and writer",
            "homepage": "http://keboola.com",
            "keywords": [
                "csv",
                "rfc4180"
            ],
            "time": "2019-11-11T08:02:32+00:00"
        },
        {
            "name": "keboola/php-component",
            "version": "8.1.1",
            "source": {
                "type": "git",
                "url": "https://github.com/keboola/php-component.git",
                "reference": "f6ac140f1a93f0647c1a73080385f03df96f8658"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/keboola/php-component/zipball/f6ac140f1a93f0647c1a73080385f03df96f8658",
                "reference": "f6ac140f1a93f0647c1a73080385f03df96f8658",
                "shasum": ""
            },
            "require": {
                "ext-json": "*",
                "keboola/common-exceptions": "^1.0",
                "monolog/monolog": "^2.0",
                "php": "^7.3",
                "symfony/config": "^5.0",
                "symfony/filesystem": "^5.0",
                "symfony/finder": "^5.0",
                "symfony/serializer": "^5.0"
            },
            "require-dev": {
                "devedge/sami-github": "^1.0",
                "jakub-onderka/php-parallel-lint": "^1.0",
                "keboola/coding-standard": ">=7.0.2",
                "keboola/php-temp": "^2.0",
                "phpstan/phpstan": "^0.12.14",
                "phpunit/phpunit": "^9.0"
            },
            "type": "project",
            "autoload": {
                "psr-4": {
                    "Keboola\\Component\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Keboola",
                    "email": "devel@keboola.com"
                }
            ],
            "description": "Helper classes for developing Keboola PHP components",
            "keywords": [
                "component",
                "docker",
                "keboola"
            ],
            "time": "2020-03-19T09:26:43+00:00"
        },
        {
            "name": "keboola/retry",
            "version": "0.5.0",
            "source": {
                "type": "git",
                "url": "https://github.com/keboola/retry.git",
                "reference": "afdb190a9186b30a27c75df2aaf24a6de07efebb"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/keboola/retry/zipball/afdb190a9186b30a27c75df2aaf24a6de07efebb",
                "reference": "afdb190a9186b30a27c75df2aaf24a6de07efebb",
                "shasum": ""
            },
            "require": {
                "php": ">=7.1",
                "psr/log": "^1.1"
            },
            "replace": {
                "vkartaviy/retry": "*"
            },
            "require-dev": {
                "keboola/coding-standard": "^7.0",
                "phpstan/phpstan-shim": "^0.10",
                "phpunit/phpunit": "7.*"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Retry\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Keboola Dev",
                    "email": "devel@keboola.com"
                }
            ],
            "description": "Library for repeatable and retryable operations",
            "keywords": [
                "backoff",
                "proxy",
                "repeat",
                "retry"
            ],
            "time": "2020-01-31T14:20:00+00:00"
        },
        {
            "name": "league/oauth2-client",
            "version": "2.4.1",
            "source": {
                "type": "git",
                "url": "https://github.com/thephpleague/oauth2-client.git",
                "reference": "cc114abc622a53af969e8664722e84ca36257530"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/thephpleague/oauth2-client/zipball/cc114abc622a53af969e8664722e84ca36257530",
                "reference": "cc114abc622a53af969e8664722e84ca36257530",
                "shasum": ""
            },
            "require": {
                "guzzlehttp/guzzle": "^6.0",
                "paragonie/random_compat": "^1|^2|^9.99",
                "php": "^5.6|^7.0"
            },
            "require-dev": {
                "eloquent/liberator": "^2.0",
                "eloquent/phony-phpunit": "^1.0|^3.0",
                "jakub-onderka/php-parallel-lint": "^0.9.2",
                "phpunit/phpunit": "^5.7|^6.0",
                "squizlabs/php_codesniffer": "^2.3|^3.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-2.x": "2.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "League\\OAuth2\\Client\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Alex Bilbie",
                    "email": "hello@alexbilbie.com",
                    "homepage": "http://www.alexbilbie.com",
                    "role": "Developer"
                },
                {
                    "name": "Woody Gilk",
                    "homepage": "https://github.com/shadowhand",
                    "role": "Contributor"
                }
            ],
            "description": "OAuth 2.0 Client Library",
            "keywords": [
                "Authentication",
                "SSO",
                "authorization",
                "identity",
                "idp",
                "oauth",
                "oauth2",
                "single sign on"
            ],
            "time": "2018-11-22T18:33:57+00:00"
        },
        {
            "name": "microsoft/microsoft-graph",
            "version": "1.13.0",
            "source": {
                "type": "git",
                "url": "https://github.com/microsoftgraph/msgraph-sdk-php.git",
                "reference": "584b71bf888659596003d9c8acab06161def8ae5"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/microsoftgraph/msgraph-sdk-php/zipball/584b71bf888659596003d9c8acab06161def8ae5",
                "reference": "584b71bf888659596003d9c8acab06161def8ae5",
                "shasum": ""
            },
            "require": {
                "guzzlehttp/guzzle": "^6.2",
                "php": "^7.1"
            },
            "require-dev": {
                "mikey179/vfsstream": "^1.2",
                "phpdocumentor/phpdocumentor": "^2.9",
                "phpunit/phpunit": "^7.5"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Microsoft\\Graph\\": "src/",
                    "Microsoft\\Graph\\Test\\": "tests/Functional/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Michael Mainer",
                    "email": "mmainer@microsoft.com",
                    "role": "Developer"
                }
            ],
            "description": "The Microsoft Graph SDK for PHP",
            "homepage": "https://developer.microsoft.com/en-us/graph",
            "time": "2020-02-04T23:16:38+00:00"
        },
        {
            "name": "monolog/monolog",
            "version": "2.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/Seldaek/monolog.git",
                "reference": "c861fcba2ca29404dc9e617eedd9eff4616986b8"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/Seldaek/monolog/zipball/c861fcba2ca29404dc9e617eedd9eff4616986b8",
                "reference": "c861fcba2ca29404dc9e617eedd9eff4616986b8",
                "shasum": ""
            },
            "require": {
                "php": "^7.2",
                "psr/log": "^1.0.1"
            },
            "provide": {
                "psr/log-implementation": "1.0.0"
            },
            "require-dev": {
                "aws/aws-sdk-php": "^2.4.9 || ^3.0",
                "doctrine/couchdb": "~1.0@dev",
                "elasticsearch/elasticsearch": "^6.0",
                "graylog2/gelf-php": "^1.4.2",
                "jakub-onderka/php-parallel-lint": "^0.9",
                "php-amqplib/php-amqplib": "~2.4",
                "php-console/php-console": "^3.1.3",
                "phpspec/prophecy": "^1.6.1",
                "phpunit/phpunit": "^8.3",
                "predis/predis": "^1.1",
                "rollbar/rollbar": "^1.3",
                "ruflin/elastica": ">=0.90 <3.0",
                "swiftmailer/swiftmailer": "^5.3|^6.0"
            },
            "suggest": {
                "aws/aws-sdk-php": "Allow sending log messages to AWS services like DynamoDB",
                "doctrine/couchdb": "Allow sending log messages to a CouchDB server",
                "elasticsearch/elasticsearch": "Allow sending log messages to an Elasticsearch server via official client",
                "ext-amqp": "Allow sending log messages to an AMQP server (1.0+ required)",
                "ext-mbstring": "Allow to work properly with unicode symbols",
                "ext-mongodb": "Allow sending log messages to a MongoDB server (via driver)",
                "graylog2/gelf-php": "Allow sending log messages to a GrayLog2 server",
                "mongodb/mongodb": "Allow sending log messages to a MongoDB server (via library)",
                "php-amqplib/php-amqplib": "Allow sending log messages to an AMQP server using php-amqplib",
                "php-console/php-console": "Allow sending log messages to Google Chrome",
                "rollbar/rollbar": "Allow sending log messages to Rollbar",
                "ruflin/elastica": "Allow sending log messages to an Elastic Search server"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Monolog\\": "src/Monolog"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Jordi Boggiano",
                    "email": "j.boggiano@seld.be",
                    "homepage": "http://seld.be"
                }
            ],
            "description": "Sends your logs to files, sockets, inboxes, databases and various web services",
            "homepage": "http://github.com/Seldaek/monolog",
            "keywords": [
                "log",
                "logging",
                "psr-3"
            ],
            "time": "2019-12-20T14:22:59+00:00"
        },
        {
            "name": "paragonie/random_compat",
            "version": "v9.99.99",
            "source": {
                "type": "git",
                "url": "https://github.com/paragonie/random_compat.git",
                "reference": "84b4dfb120c6f9b4ff7b3685f9b8f1aa365a0c95"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/paragonie/random_compat/zipball/84b4dfb120c6f9b4ff7b3685f9b8f1aa365a0c95",
                "reference": "84b4dfb120c6f9b4ff7b3685f9b8f1aa365a0c95",
                "shasum": ""
            },
            "require": {
                "php": "^7"
            },
            "require-dev": {
                "phpunit/phpunit": "4.*|5.*",
                "vimeo/psalm": "^1"
            },
            "suggest": {
                "ext-libsodium": "Provides a modern crypto API that can be used to generate random bytes."
            },
            "type": "library",
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Paragon Initiative Enterprises",
                    "email": "security@paragonie.com",
                    "homepage": "https://paragonie.com"
                }
            ],
            "description": "PHP 5.x polyfill for random_bytes() and random_int() from PHP 7",
            "keywords": [
                "csprng",
                "polyfill",
                "pseudorandom",
                "random"
            ],
            "time": "2018-07-02T15:55:56+00:00"
        },
        {
            "name": "psr/http-message",
            "version": "1.0.1",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-message.git",
                "reference": "f6561bf28d520154e4b0ec72be95418abe6d9363"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-message/zipball/f6561bf28d520154e4b0ec72be95418abe6d9363",
                "reference": "f6561bf28d520154e4b0ec72be95418abe6d9363",
                "shasum": ""
            },
            "require": {
                "php": ">=5.3.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "http://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP messages",
            "homepage": "https://github.com/php-fig/http-message",
            "keywords": [
                "http",
                "http-message",
                "psr",
                "psr-7",
                "request",
                "response"
            ],
            "time": "2016-08-06T14:39:51+00:00"
        },
        {
            "name": "psr/log",
            "version": "1.1.3",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/log.git",
                "reference": "0f73288fd15629204f9d42b7055f72dacbe811fc"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/log/zipball/0f73288fd15629204f9d42b7055f72dacbe811fc",
                "reference": "0f73288fd15629204f9d42b7055f72dacbe811fc",
                "shasum": ""
            },
            "require": {
                "php": ">=5.3.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.1.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Log\\": "Psr/Log/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "http://www.php-fig.org/"
                }
            ],
            "description": "Common interface for logging libraries",
            "homepage": "https://github.com/php-fig/log",
            "keywords": [
                "log",
                "psr",
                "psr-3"
            ],
            "time": "2020-03-23T09:12:05+00:00"
        },
        {
            "name": "ralouphie/getallheaders",
            "version": "3.0.3",
            "source": {
                "type": "git",
                "url": "https://github.com/ralouphie/getallheaders.git",
                "reference": "120b605dfeb996808c31b6477290a714d356e822"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/ralouphie/getallheaders/zipball/120b605dfeb996808c31b6477290a714d356e822",
                "reference": "120b605dfeb996808c31b6477290a714d356e822",
                "shasum": ""
            },
            "require": {
                "php": ">=5.6"
            },
            "require-dev": {
                "php-coveralls/php-coveralls": "^2.1",
                "phpunit/phpunit": "^5 || ^6.5"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/getallheaders.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Ralph Khattar",
                    "email": "ralph.khattar@gmail.com"
                }
            ],
            "description": "A polyfill for getallheaders.",
            "time": "2019-03-08T08:55:37+00:00"
        },
        {
            "name": "symfony/config",
            "version": "v5.0.7",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/config.git",
                "reference": "3e633c31a34738f7f4ed7a225c43fc45ca74c986"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/config/zipball/3e633c31a34738f7f4ed7a225c43fc45ca74c986",
                "reference": "3e633c31a34738f7f4ed7a225c43fc45ca74c986",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5",
                "symfony/filesystem": "^4.4|^5.0",
                "symfony/polyfill-ctype": "~1.8"
            },
            "conflict": {
                "symfony/finder": "<4.4"
            },
            "require-dev": {
                "symfony/event-dispatcher": "^4.4|^5.0",
                "symfony/finder": "^4.4|^5.0",
                "symfony/messenger": "^4.4|^5.0",
                "symfony/service-contracts": "^1.1|^2",
                "symfony/yaml": "^4.4|^5.0"
            },
            "suggest": {
                "symfony/yaml": "To use the yaml reference dumper"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.0-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Symfony\\Component\\Config\\": ""
                },
                "exclude-from-classmap": [
                    "/Tests/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Fabien Potencier",
                    "email": "fabien@symfony.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony Config Component",
            "homepage": "https://symfony.com",
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2020-03-27T16:56:45+00:00"
        },
        {
            "name": "symfony/filesystem",
            "version": "v5.0.7",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/filesystem.git",
                "reference": "ca3b87dd09fff9b771731637f5379965fbfab420"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/filesystem/zipball/ca3b87dd09fff9b771731637f5379965fbfab420",
                "reference": "ca3b87dd09fff9b771731637f5379965fbfab420",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5",
                "symfony/polyfill-ctype": "~1.8"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.0-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Symfony\\Component\\Filesystem\\": ""
                },
                "exclude-from-classmap": [
                    "/Tests/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Fabien Potencier",
                    "email": "fabien@symfony.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony Filesystem Component",
            "homepage": "https://symfony.com",
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2020-03-27T16:56:45+00:00"
        },
        {
            "name": "symfony/finder",
            "version": "v5.0.7",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/finder.git",
                "reference": "600a52c29afc0d1caa74acbec8d3095ca7e9910d"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/finder/zipball/600a52c29afc0d1caa74acbec8d3095ca7e9910d",
                "reference": "600a52c29afc0d1caa74acbec8d3095ca7e9910d",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.0-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Symfony\\Component\\Finder\\": ""
                },
                "exclude-from-classmap": [
                    "/Tests/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Fabien Potencier",
                    "email": "fabien@symfony.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony Finder Component",
            "homepage": "https://symfony.com",
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2020-03-27T16:56:45+00:00"
        },
        {
            "name": "symfony/polyfill-ctype",
            "version": "v1.15.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-ctype.git",
                "reference": "4719fa9c18b0464d399f1a63bf624b42b6fa8d14"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-ctype/zipball/4719fa9c18b0464d399f1a63bf624b42b6fa8d14",
                "reference": "4719fa9c18b0464d399f1a63bf624b42b6fa8d14",
                "shasum": ""
            },
            "require": {
                "php": ">=5.3.3"
            },
            "suggest": {
                "ext-ctype": "For best performance"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.15-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Symfony\\Polyfill\\Ctype\\": ""
                },
                "files": [
                    "bootstrap.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Gert de Pagter",
                    "email": "BackEndTea@gmail.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill for ctype functions",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "ctype",
                "polyfill",
                "portable"
            ],
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2020-02-27T09:26:54+00:00"
        },
        {
            "name": "symfony/serializer",
            "version": "v5.0.7",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/serializer.git",
                "reference": "5f9e12db25c6f993b4999159957b75d32a3f4ade"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/serializer/zipball/5f9e12db25c6f993b4999159957b75d32a3f4ade",
                "reference": "5f9e12db25c6f993b4999159957b75d32a3f4ade",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5",
                "symfony/polyfill-ctype": "~1.8"
            },
            "conflict": {
                "phpdocumentor/type-resolver": "<0.2.1",
                "symfony/dependency-injection": "<4.4",
                "symfony/property-access": "<4.4",
                "symfony/property-info": "<4.4",
                "symfony/yaml": "<4.4"
            },
            "require-dev": {
                "doctrine/annotations": "~1.0",
                "doctrine/cache": "~1.0",
                "phpdocumentor/reflection-docblock": "^3.2|^4.0",
                "symfony/cache": "^4.4|^5.0",
                "symfony/config": "^4.4|^5.0",
                "symfony/dependency-injection": "^4.4|^5.0",
                "symfony/error-handler": "^4.4|^5.0",
                "symfony/http-foundation": "^4.4|^5.0",
                "symfony/mime": "^4.4|^5.0",
                "symfony/property-access": "^4.4|^5.0",
                "symfony/property-info": "^4.4|^5.0",
                "symfony/validator": "^4.4|^5.0",
                "symfony/yaml": "^4.4|^5.0"
            },
            "suggest": {
                "doctrine/annotations": "For using the annotation mapping. You will also need doctrine/cache.",
                "doctrine/cache": "For using the default cached annotation reader and metadata cache.",
                "psr/cache-implementation": "For using the metadata cache.",
                "symfony/config": "For using the XML mapping loader.",
                "symfony/mime": "For using a MIME type guesser within the DataUriNormalizer.",
                "symfony/property-access": "For using the ObjectNormalizer.",
                "symfony/property-info": "To deserialize relations.",
                "symfony/yaml": "For using the default YAML mapping loader."
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.0-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Symfony\\Component\\Serializer\\": ""
                },
                "exclude-from-classmap": [
                    "/Tests/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Fabien Potencier",
                    "email": "fabien@symfony.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony Serializer Component",
            "homepage": "https://symfony.com",
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2020-03-27T16:56:45+00:00"
        }
    ],
    "packages-dev": [
        {
            "name": "doctrine/instantiator",
            "version": "1.3.0",
            "source": {
                "type": "git",
                "url": "https://github.com/doctrine/instantiator.git",
                "reference": "ae466f726242e637cebdd526a7d991b9433bacf1"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/doctrine/instantiator/zipball/ae466f726242e637cebdd526a7d991b9433bacf1",
                "reference": "ae466f726242e637cebdd526a7d991b9433bacf1",
                "shasum": ""
            },
            "require": {
                "php": "^7.1"
            },
            "require-dev": {
                "doctrine/coding-standard": "^6.0",
                "ext-pdo": "*",
                "ext-phar": "*",
                "phpbench/phpbench": "^0.13",
                "phpstan/phpstan-phpunit": "^0.11",
                "phpstan/phpstan-shim": "^0.11",
                "phpunit/phpunit": "^7.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.2.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Doctrine\\Instantiator\\": "src/Doctrine/Instantiator/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Marco Pivetta",
                    "email": "ocramius@gmail.com",
                    "homepage": "http://ocramius.github.com/"
                }
            ],
            "description": "A small, lightweight utility to instantiate objects in PHP without invoking their constructors",
            "homepage": "https://www.doctrine-project.org/projects/instantiator.html",
            "keywords": [
                "constructor",
                "instantiate"
            ],
            "time": "2019-10-21T16:45:58+00:00"
        },
        {
            "name": "keboola/coding-standard",
            "version": "9.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/keboola/phpcs-standard.git",
                "reference": "bcf9ac5f664aa3bf816902438c0a8a9187cd4ebb"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/keboola/phpcs-standard/zipball/bcf9ac5f664aa3bf816902438c0a8a9187cd4ebb",
                "reference": "bcf9ac5f664aa3bf816902438c0a8a9187cd4ebb",
                "shasum": ""
            },
            "require": {
                "slevomat/coding-standard": "^4.8.6",
                "squizlabs/php_codesniffer": "^3.2"
            },
            "type": "phpcodesniffer-standard",
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "Keboola coding standard",
            "time": "2019-10-16T11:14:48+00:00"
        },
        {
            "name": "keboola/datadir-tests",
            "version": "4.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/keboola/datadir-tests.git",
                "reference": "b01856c771760331b50a082f8b6cb2557632c5bc"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/keboola/datadir-tests/zipball/b01856c771760331b50a082f8b6cb2557632c5bc",
                "reference": "b01856c771760331b50a082f8b6cb2557632c5bc",
                "shasum": ""
            },
            "require": {
                "keboola/php-temp": "^2.0",
                "php": "^7.3",
                "phpunit/phpunit": "^9.0",
                "symfony/filesystem": "^5.0",
                "symfony/finder": "^5.0",
                "symfony/process": "^5.0"
            },
            "require-dev": {
                "jakub-onderka/php-parallel-lint": "^1.0",
                "keboola/coding-standard": "^9.0",
                "phpstan/phpstan": "^0.12.14"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Keboola\\DatadirTests\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "Tool for functional testing of Keboola Connection components",
            "time": "2020-03-19T12:08:12+00:00"
        },
        {
            "name": "keboola/php-temp",
            "version": "2.0.1",
            "source": {
                "type": "git",
                "url": "https://github.com/keboola/php-temp.git",
                "reference": "cbdb4dd0dfe548d7bffd74a0e66294981aea49ce"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/keboola/php-temp/zipball/cbdb4dd0dfe548d7bffd74a0e66294981aea49ce",
                "reference": "cbdb4dd0dfe548d7bffd74a0e66294981aea49ce",
                "shasum": ""
            },
            "require": {
                "php": ">=7.1",
                "symfony/filesystem": ">2.8"
            },
            "require-dev": {
                "infection/infection": "^0.12",
                "jakub-onderka/php-parallel-lint": "^1.0",
                "keboola/coding-standard": "^8.0",
                "phpstan/phpstan-shim": "^0.11",
                "phpunit/phpunit": "^7.0|^8.0"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Keboola\\Temp\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Keboola",
                    "email": "devel@keboola.com"
                }
            ],
            "description": "Temp library handles application temporary files",
            "keywords": [
                "filesystem",
                "temp"
            ],
            "time": "2019-04-26T07:18:24+00:00"
        },
        {
            "name": "myclabs/deep-copy",
            "version": "1.9.5",
            "source": {
                "type": "git",
                "url": "https://github.com/myclabs/DeepCopy.git",
                "reference": "b2c28789e80a97badd14145fda39b545d83ca3ef"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/myclabs/DeepCopy/zipball/b2c28789e80a97badd14145fda39b545d83ca3ef",
                "reference": "b2c28789e80a97badd14145fda39b545d83ca3ef",
                "shasum": ""
            },
            "require": {
                "php": "^7.1"
            },
            "replace": {
                "myclabs/deep-copy": "self.version"
            },
            "require-dev": {
                "doctrine/collections": "^1.0",
                "doctrine/common": "^2.6",
                "phpunit/phpunit": "^7.1"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "DeepCopy\\": "src/DeepCopy/"
                },
                "files": [
                    "src/DeepCopy/deep_copy.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "Create deep copies (clones) of your objects",
            "keywords": [
                "clone",
                "copy",
                "duplicate",
                "object",
                "object graph"
            ],
            "time": "2020-01-17T21:11:47+00:00"
        },
        {
            "name": "phar-io/manifest",
            "version": "1.0.3",
            "source": {
                "type": "git",
                "url": "https://github.com/phar-io/manifest.git",
                "reference": "7761fcacf03b4d4f16e7ccb606d4879ca431fcf4"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/phar-io/manifest/zipball/7761fcacf03b4d4f16e7ccb606d4879ca431fcf4",
                "reference": "7761fcacf03b4d4f16e7ccb606d4879ca431fcf4",
                "shasum": ""
            },
            "require": {
                "ext-dom": "*",
                "ext-phar": "*",
                "phar-io/version": "^2.0",
                "php": "^5.6 || ^7.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Arne Blankerts",
                    "email": "arne@blankerts.de",
                    "role": "Developer"
                },
                {
                    "name": "Sebastian Heuer",
                    "email": "sebastian@phpeople.de",
                    "role": "Developer"
                },
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "Developer"
                }
            ],
            "description": "Component for reading phar.io manifest information from a PHP Archive (PHAR)",
            "time": "2018-07-08T19:23:20+00:00"
        },
        {
            "name": "phar-io/version",
            "version": "2.0.1",
            "source": {
                "type": "git",
                "url": "https://github.com/phar-io/version.git",
                "reference": "45a2ec53a73c70ce41d55cedef9063630abaf1b6"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/phar-io/version/zipball/45a2ec53a73c70ce41d55cedef9063630abaf1b6",
                "reference": "45a2ec53a73c70ce41d55cedef9063630abaf1b6",
                "shasum": ""
            },
            "require": {
                "php": "^5.6 || ^7.0"
            },
            "type": "library",
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Arne Blankerts",
                    "email": "arne@blankerts.de",
                    "role": "Developer"
                },
                {
                    "name": "Sebastian Heuer",
                    "email": "sebastian@phpeople.de",
                    "role": "Developer"
                },
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "Developer"
                }
            ],
            "description": "Library for handling version information and constraints",
            "time": "2018-07-08T19:19:57+00:00"
        },
        {
            "name": "php-parallel-lint/php-parallel-lint",
            "version": "v1.2.0",
            "source": {
                "type": "git",
                "url": "https://github.com/php-parallel-lint/PHP-Parallel-Lint.git",
                "reference": "474f18bc6cc6aca61ca40bfab55139de614e51ca"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-parallel-lint/PHP-Parallel-Lint/zipball/474f18bc6cc6aca61ca40bfab55139de614e51ca",
                "reference": "474f18bc6cc6aca61ca40bfab55139de614e51ca",
                "shasum": ""
            },
            "require": {
                "ext-json": "*",
                "php": ">=5.4.0"
            },
            "replace": {
                "grogy/php-parallel-lint": "*",
                "jakub-onderka/php-parallel-lint": "*"
            },
            "require-dev": {
                "nette/tester": "^1.3 || ^2.0",
                "php-parallel-lint/php-console-highlighter": "~0.3",
                "squizlabs/php_codesniffer": "~3.0"
            },
            "suggest": {
                "php-parallel-lint/php-console-highlighter": "Highlight syntax in code snippet"
            },
            "bin": [
                "parallel-lint"
            ],
            "type": "library",
            "autoload": {
                "classmap": [
                    "./"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-2-Clause"
            ],
            "authors": [
                {
                    "name": "Jakub Onderka",
                    "email": "ahoj@jakubonderka.cz"
                }
            ],
            "description": "This tool check syntax of PHP files about 20x faster than serial check.",
            "homepage": "https://github.com/php-parallel-lint/PHP-Parallel-Lint",
            "time": "2020-04-04T12:18:32+00:00"
        },
        {
            "name": "phpdocumentor/reflection-common",
            "version": "2.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/phpDocumentor/ReflectionCommon.git",
                "reference": "63a995caa1ca9e5590304cd845c15ad6d482a62a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/phpDocumentor/ReflectionCommon/zipball/63a995caa1ca9e5590304cd845c15ad6d482a62a",
                "reference": "63a995caa1ca9e5590304cd845c15ad6d482a62a",
                "shasum": ""
            },
            "require": {
                "php": ">=7.1"
            },
            "require-dev": {
                "phpunit/phpunit": "~6"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "phpDocumentor\\Reflection\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Jaap van Otterdijk",
                    "email": "opensource@ijaap.nl"
                }
            ],
            "description": "Common reflection classes used by phpdocumentor to reflect the code structure",
            "homepage": "http://www.phpdoc.org",
            "keywords": [
                "FQSEN",
                "phpDocumentor",
                "phpdoc",
                "reflection",
                "static analysis"
            ],
            "time": "2018-08-07T13:53:10+00:00"
        },
        {
            "name": "phpdocumentor/reflection-docblock",
            "version": "5.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/phpDocumentor/ReflectionDocBlock.git",
                "reference": "cd72d394ca794d3466a3b2fc09d5a6c1dc86b47e"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/phpDocumentor/ReflectionDocBlock/zipball/cd72d394ca794d3466a3b2fc09d5a6c1dc86b47e",
                "reference": "cd72d394ca794d3466a3b2fc09d5a6c1dc86b47e",
                "shasum": ""
            },
            "require": {
                "ext-filter": "^7.1",
                "php": "^7.2",
                "phpdocumentor/reflection-common": "^2.0",
                "phpdocumentor/type-resolver": "^1.0",
                "webmozart/assert": "^1"
            },
            "require-dev": {
                "doctrine/instantiator": "^1",
                "mockery/mockery": "^1"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "phpDocumentor\\Reflection\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Mike van Riel",
                    "email": "me@mikevanriel.com"
                },
                {
                    "name": "Jaap van Otterdijk",
                    "email": "account@ijaap.nl"
                }
            ],
            "description": "With this component, a library can provide support for annotations via DocBlocks or otherwise retrieve information that is embedded in a DocBlock.",
            "time": "2020-02-22T12:28:44+00:00"
        },
        {
            "name": "phpdocumentor/type-resolver",
            "version": "1.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/phpDocumentor/TypeResolver.git",
                "reference": "7462d5f123dfc080dfdf26897032a6513644fc95"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/phpDocumentor/TypeResolver/zipball/7462d5f123dfc080dfdf26897032a6513644fc95",
                "reference": "7462d5f123dfc080dfdf26897032a6513644fc95",
                "shasum": ""
            },
            "require": {
                "php": "^7.2",
                "phpdocumentor/reflection-common": "^2.0"
            },
            "require-dev": {
                "ext-tokenizer": "^7.2",
                "mockery/mockery": "~1"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "phpDocumentor\\Reflection\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Mike van Riel",
                    "email": "me@mikevanriel.com"
                }
            ],
            "description": "A PSR-5 based resolver of Class names, Types and Structural Element Names",
            "time": "2020-02-18T18:59:58+00:00"
        },
        {
            "name": "phpspec/prophecy",
            "version": "v1.10.3",
            "source": {
                "type": "git",
                "url": "https://github.com/phpspec/prophecy.git",
                "reference": "451c3cd1418cf640de218914901e51b064abb093"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/phpspec/prophecy/zipball/451c3cd1418cf640de218914901e51b064abb093",
                "reference": "451c3cd1418cf640de218914901e51b064abb093",
                "shasum": ""
            },
            "require": {
                "doctrine/instantiator": "^1.0.2",
                "php": "^5.3|^7.0",
                "phpdocumentor/reflection-docblock": "^2.0|^3.0.2|^4.0|^5.0",
                "sebastian/comparator": "^1.2.3|^2.0|^3.0|^4.0",
                "sebastian/recursion-context": "^1.0|^2.0|^3.0|^4.0"
            },
            "require-dev": {
                "phpspec/phpspec": "^2.5 || ^3.2",
                "phpunit/phpunit": "^4.8.35 || ^5.7 || ^6.5 || ^7.1"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.10.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Prophecy\\": "src/Prophecy"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Konstantin Kudryashov",
                    "email": "ever.zet@gmail.com",
                    "homepage": "http://everzet.com"
                },
                {
                    "name": "Marcello Duarte",
                    "email": "marcello.duarte@gmail.com"
                }
            ],
            "description": "Highly opinionated mocking framework for PHP 5.3+",
            "homepage": "https://github.com/phpspec/prophecy",
            "keywords": [
                "Double",
                "Dummy",
                "fake",
                "mock",
                "spy",
                "stub"
            ],
            "time": "2020-03-05T15:02:03+00:00"
        },
        {
            "name": "phpstan/phpstan",
            "version": "0.12.18",
            "source": {
                "type": "git",
                "url": "https://github.com/phpstan/phpstan.git",
                "reference": "1ce27fe29c8660a27926127d350d53d80c4d4286"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/phpstan/phpstan/zipball/1ce27fe29c8660a27926127d350d53d80c4d4286",
                "reference": "1ce27fe29c8660a27926127d350d53d80c4d4286",
                "shasum": ""
            },
            "require": {
                "php": "^7.1"
            },
            "bin": [
                "phpstan",
                "phpstan.phar"
            ],
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "0.12-dev"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "PHPStan - PHP Static Analysis Tool",
            "funding": [
                {
                    "url": "https://github.com/ondrejmirtes",
                    "type": "github"
                },
                {
                    "url": "https://www.patreon.com/phpstan",
                    "type": "patreon"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/phpstan/phpstan",
                    "type": "tidelift"
                }
            ],
            "time": "2020-03-22T16:51:47+00:00"
        },
        {
            "name": "phpunit/php-code-coverage",
            "version": "8.0.1",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/php-code-coverage.git",
                "reference": "31e94ccc084025d6abee0585df533eb3a792b96a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/php-code-coverage/zipball/31e94ccc084025d6abee0585df533eb3a792b96a",
                "reference": "31e94ccc084025d6abee0585df533eb3a792b96a",
                "shasum": ""
            },
            "require": {
                "ext-dom": "*",
                "ext-xmlwriter": "*",
                "php": "^7.3",
                "phpunit/php-file-iterator": "^3.0",
                "phpunit/php-text-template": "^2.0",
                "phpunit/php-token-stream": "^4.0",
                "sebastian/code-unit-reverse-lookup": "^2.0",
                "sebastian/environment": "^5.0",
                "sebastian/version": "^3.0",
                "theseer/tokenizer": "^1.1.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "suggest": {
                "ext-pcov": "*",
                "ext-xdebug": "*"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "8.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "Library that provides collection, processing, and rendering functionality for PHP code coverage information.",
            "homepage": "https://github.com/sebastianbergmann/php-code-coverage",
            "keywords": [
                "coverage",
                "testing",
                "xunit"
            ],
            "time": "2020-02-19T13:41:19+00:00"
        },
        {
            "name": "phpunit/php-file-iterator",
            "version": "3.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/php-file-iterator.git",
                "reference": "354d4a5faa7449a377a18b94a2026ca3415e3d7a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/php-file-iterator/zipball/354d4a5faa7449a377a18b94a2026ca3415e3d7a",
                "reference": "354d4a5faa7449a377a18b94a2026ca3415e3d7a",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "FilterIterator implementation that filters files based on a list of suffixes.",
            "homepage": "https://github.com/sebastianbergmann/php-file-iterator/",
            "keywords": [
                "filesystem",
                "iterator"
            ],
            "time": "2020-02-07T06:05:22+00:00"
        },
        {
            "name": "phpunit/php-invoker",
            "version": "3.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/php-invoker.git",
                "reference": "7579d5a1ba7f3ac11c80004d205877911315ae7a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/php-invoker/zipball/7579d5a1ba7f3ac11c80004d205877911315ae7a",
                "reference": "7579d5a1ba7f3ac11c80004d205877911315ae7a",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "ext-pcntl": "*",
                "phpunit/phpunit": "^9.0"
            },
            "suggest": {
                "ext-pcntl": "*"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "Invoke callables with a timeout",
            "homepage": "https://github.com/sebastianbergmann/php-invoker/",
            "keywords": [
                "process"
            ],
            "time": "2020-02-07T06:06:11+00:00"
        },
        {
            "name": "phpunit/php-text-template",
            "version": "2.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/php-text-template.git",
                "reference": "526dc996cc0ebdfa428cd2dfccd79b7b53fee346"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/php-text-template/zipball/526dc996cc0ebdfa428cd2dfccd79b7b53fee346",
                "reference": "526dc996cc0ebdfa428cd2dfccd79b7b53fee346",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "Simple template engine.",
            "homepage": "https://github.com/sebastianbergmann/php-text-template/",
            "keywords": [
                "template"
            ],
            "time": "2020-02-01T07:43:44+00:00"
        },
        {
            "name": "phpunit/php-timer",
            "version": "3.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/php-timer.git",
                "reference": "4118013a4d0f97356eae8e7fb2f6c6472575d1df"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/php-timer/zipball/4118013a4d0f97356eae8e7fb2f6c6472575d1df",
                "reference": "4118013a4d0f97356eae8e7fb2f6c6472575d1df",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "Utility class for timing",
            "homepage": "https://github.com/sebastianbergmann/php-timer/",
            "keywords": [
                "timer"
            ],
            "time": "2020-02-07T06:08:11+00:00"
        },
        {
            "name": "phpunit/php-token-stream",
            "version": "4.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/php-token-stream.git",
                "reference": "b2560a0c33f7710e4d7f8780964193e8e8f8effe"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/php-token-stream/zipball/b2560a0c33f7710e4d7f8780964193e8e8f8effe",
                "reference": "b2560a0c33f7710e4d7f8780964193e8e8f8effe",
                "shasum": ""
            },
            "require": {
                "ext-tokenizer": "*",
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "4.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                }
            ],
            "description": "Wrapper around PHP's tokenizer extension.",
            "homepage": "https://github.com/sebastianbergmann/php-token-stream/",
            "keywords": [
                "tokenizer"
            ],
            "time": "2020-02-07T06:19:00+00:00"
        },
        {
            "name": "phpunit/phpunit",
            "version": "9.1.1",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/phpunit.git",
                "reference": "848f6521c906500e66229668768576d35de0227e"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/phpunit/zipball/848f6521c906500e66229668768576d35de0227e",
                "reference": "848f6521c906500e66229668768576d35de0227e",
                "shasum": ""
            },
            "require": {
                "doctrine/instantiator": "^1.2.0",
                "ext-dom": "*",
                "ext-json": "*",
                "ext-libxml": "*",
                "ext-mbstring": "*",
                "ext-xml": "*",
                "ext-xmlwriter": "*",
                "myclabs/deep-copy": "^1.9.1",
                "phar-io/manifest": "^1.0.3",
                "phar-io/version": "^2.0.1",
                "php": "^7.3",
                "phpspec/prophecy": "^1.8.1",
                "phpunit/php-code-coverage": "^8.0.1",
                "phpunit/php-file-iterator": "^3.0",
                "phpunit/php-invoker": "^3.0",
                "phpunit/php-text-template": "^2.0",
                "phpunit/php-timer": "^3.0",
                "sebastian/code-unit": "^1.0",
                "sebastian/comparator": "^4.0",
                "sebastian/diff": "^4.0",
                "sebastian/environment": "^5.0.1",
                "sebastian/exporter": "^4.0",
                "sebastian/global-state": "^4.0",
                "sebastian/object-enumerator": "^4.0",
                "sebastian/resource-operations": "^3.0",
                "sebastian/type": "^2.0",
                "sebastian/version": "^3.0"
            },
            "require-dev": {
                "ext-pdo": "*"
            },
            "suggest": {
                "ext-soap": "*",
                "ext-xdebug": "*"
            },
            "bin": [
                "phpunit"
            ],
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "9.1-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ],
                "files": [
                    "src/Framework/Assert/Functions.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "The PHP Unit Testing framework.",
            "homepage": "https://phpunit.de/",
            "keywords": [
                "phpunit",
                "testing",
                "xunit"
            ],
            "funding": [
                {
                    "url": "https://phpunit.de/donate.html",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/sebastianbergmann",
                    "type": "github"
                }
            ],
            "time": "2020-04-03T14:40:04+00:00"
        },
        {
            "name": "sebastian/code-unit",
            "version": "1.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/code-unit.git",
                "reference": "8d8f09bd47c75159921e6e84fdef146343962866"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/code-unit/zipball/8d8f09bd47c75159921e6e84fdef146343962866",
                "reference": "8d8f09bd47c75159921e6e84fdef146343962866",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "Collection of value objects that represent the PHP code units",
            "homepage": "https://github.com/sebastianbergmann/code-unit",
            "funding": [
                {
                    "url": "https://github.com/sebastianbergmann",
                    "type": "github"
                }
            ],
            "time": "2020-03-30T11:59:20+00:00"
        },
        {
            "name": "sebastian/code-unit-reverse-lookup",
            "version": "2.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/code-unit-reverse-lookup.git",
                "reference": "5b5dbe0044085ac41df47e79d34911a15b96d82e"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/code-unit-reverse-lookup/zipball/5b5dbe0044085ac41df47e79d34911a15b96d82e",
                "reference": "5b5dbe0044085ac41df47e79d34911a15b96d82e",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                }
            ],
            "description": "Looks up which function or method a line of code belongs to",
            "homepage": "https://github.com/sebastianbergmann/code-unit-reverse-lookup/",
            "time": "2020-02-07T06:20:13+00:00"
        },
        {
            "name": "sebastian/comparator",
            "version": "4.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/comparator.git",
                "reference": "85b3435da967696ed618ff745f32be3ff4a2b8e8"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/comparator/zipball/85b3435da967696ed618ff745f32be3ff4a2b8e8",
                "reference": "85b3435da967696ed618ff745f32be3ff4a2b8e8",
                "shasum": ""
            },
            "require": {
                "php": "^7.3",
                "sebastian/diff": "^4.0",
                "sebastian/exporter": "^4.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "4.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                },
                {
                    "name": "Jeff Welch",
                    "email": "whatthejeff@gmail.com"
                },
                {
                    "name": "Volker Dusch",
                    "email": "github@wallbash.com"
                },
                {
                    "name": "Bernhard Schussek",
                    "email": "bschussek@2bepublished.at"
                }
            ],
            "description": "Provides the functionality to compare PHP values for equality",
            "homepage": "https://github.com/sebastianbergmann/comparator",
            "keywords": [
                "comparator",
                "compare",
                "equality"
            ],
            "time": "2020-02-07T06:08:51+00:00"
        },
        {
            "name": "sebastian/diff",
            "version": "4.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/diff.git",
                "reference": "c0c26c9188b538bfa985ae10c9f05d278f12060d"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/diff/zipball/c0c26c9188b538bfa985ae10c9f05d278f12060d",
                "reference": "c0c26c9188b538bfa985ae10c9f05d278f12060d",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0",
                "symfony/process": "^4 || ^5"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "4.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                },
                {
                    "name": "Kore Nordmann",
                    "email": "mail@kore-nordmann.de"
                }
            ],
            "description": "Diff implementation",
            "homepage": "https://github.com/sebastianbergmann/diff",
            "keywords": [
                "diff",
                "udiff",
                "unidiff",
                "unified diff"
            ],
            "time": "2020-02-07T06:09:38+00:00"
        },
        {
            "name": "sebastian/environment",
            "version": "5.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/environment.git",
                "reference": "c753f04d68cd489b6973cf9b4e505e191af3b05c"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/environment/zipball/c753f04d68cd489b6973cf9b4e505e191af3b05c",
                "reference": "c753f04d68cd489b6973cf9b4e505e191af3b05c",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "suggest": {
                "ext-posix": "*"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                }
            ],
            "description": "Provides functionality to handle HHVM/PHP environments",
            "homepage": "http://www.github.com/sebastianbergmann/environment",
            "keywords": [
                "Xdebug",
                "environment",
                "hhvm"
            ],
            "time": "2020-04-14T13:36:52+00:00"
        },
        {
            "name": "sebastian/exporter",
            "version": "4.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/exporter.git",
                "reference": "80c26562e964016538f832f305b2286e1ec29566"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/exporter/zipball/80c26562e964016538f832f305b2286e1ec29566",
                "reference": "80c26562e964016538f832f305b2286e1ec29566",
                "shasum": ""
            },
            "require": {
                "php": "^7.3",
                "sebastian/recursion-context": "^4.0"
            },
            "require-dev": {
                "ext-mbstring": "*",
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "4.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                },
                {
                    "name": "Jeff Welch",
                    "email": "whatthejeff@gmail.com"
                },
                {
                    "name": "Volker Dusch",
                    "email": "github@wallbash.com"
                },
                {
                    "name": "Adam Harvey",
                    "email": "aharvey@php.net"
                },
                {
                    "name": "Bernhard Schussek",
                    "email": "bschussek@gmail.com"
                }
            ],
            "description": "Provides the functionality to export PHP variables for visualization",
            "homepage": "http://www.github.com/sebastianbergmann/exporter",
            "keywords": [
                "export",
                "exporter"
            ],
            "time": "2020-02-07T06:10:52+00:00"
        },
        {
            "name": "sebastian/global-state",
            "version": "4.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/global-state.git",
                "reference": "bdb1e7c79e592b8c82cb1699be3c8743119b8a72"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/global-state/zipball/bdb1e7c79e592b8c82cb1699be3c8743119b8a72",
                "reference": "bdb1e7c79e592b8c82cb1699be3c8743119b8a72",
                "shasum": ""
            },
            "require": {
                "php": "^7.3",
                "sebastian/object-reflector": "^2.0",
                "sebastian/recursion-context": "^4.0"
            },
            "require-dev": {
                "ext-dom": "*",
                "phpunit/phpunit": "^9.0"
            },
            "suggest": {
                "ext-uopz": "*"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "4.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                }
            ],
            "description": "Snapshotting of global state",
            "homepage": "http://www.github.com/sebastianbergmann/global-state",
            "keywords": [
                "global state"
            ],
            "time": "2020-02-07T06:11:37+00:00"
        },
        {
            "name": "sebastian/object-enumerator",
            "version": "4.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/object-enumerator.git",
                "reference": "e67516b175550abad905dc952f43285957ef4363"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/object-enumerator/zipball/e67516b175550abad905dc952f43285957ef4363",
                "reference": "e67516b175550abad905dc952f43285957ef4363",
                "shasum": ""
            },
            "require": {
                "php": "^7.3",
                "sebastian/object-reflector": "^2.0",
                "sebastian/recursion-context": "^4.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "4.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                }
            ],
            "description": "Traverses array structures and object graphs to enumerate all referenced objects",
            "homepage": "https://github.com/sebastianbergmann/object-enumerator/",
            "time": "2020-02-07T06:12:23+00:00"
        },
        {
            "name": "sebastian/object-reflector",
            "version": "2.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/object-reflector.git",
                "reference": "f4fd0835cabb0d4a6546d9fe291e5740037aa1e7"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/object-reflector/zipball/f4fd0835cabb0d4a6546d9fe291e5740037aa1e7",
                "reference": "f4fd0835cabb0d4a6546d9fe291e5740037aa1e7",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                }
            ],
            "description": "Allows reflection of object attributes, including inherited and non-public ones",
            "homepage": "https://github.com/sebastianbergmann/object-reflector/",
            "time": "2020-02-07T06:19:40+00:00"
        },
        {
            "name": "sebastian/recursion-context",
            "version": "4.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/recursion-context.git",
                "reference": "cdd86616411fc3062368b720b0425de10bd3d579"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/recursion-context/zipball/cdd86616411fc3062368b720b0425de10bd3d579",
                "reference": "cdd86616411fc3062368b720b0425de10bd3d579",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "4.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                },
                {
                    "name": "Jeff Welch",
                    "email": "whatthejeff@gmail.com"
                },
                {
                    "name": "Adam Harvey",
                    "email": "aharvey@php.net"
                }
            ],
            "description": "Provides functionality to recursively process PHP variables",
            "homepage": "http://www.github.com/sebastianbergmann/recursion-context",
            "time": "2020-02-07T06:18:20+00:00"
        },
        {
            "name": "sebastian/resource-operations",
            "version": "3.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/resource-operations.git",
                "reference": "8c98bf0dfa1f9256d0468b9803a1e1df31b6fa98"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/resource-operations/zipball/8c98bf0dfa1f9256d0468b9803a1e1df31b6fa98",
                "reference": "8c98bf0dfa1f9256d0468b9803a1e1df31b6fa98",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de"
                }
            ],
            "description": "Provides a list of PHP built-in functions that operate on resources",
            "homepage": "https://www.github.com/sebastianbergmann/resource-operations",
            "time": "2020-02-07T06:13:02+00:00"
        },
        {
            "name": "sebastian/type",
            "version": "2.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/type.git",
                "reference": "9e8f42f740afdea51f5f4e8cec2035580e797ee1"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/type/zipball/9e8f42f740afdea51f5f4e8cec2035580e797ee1",
                "reference": "9e8f42f740afdea51f5f4e8cec2035580e797ee1",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^9.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "Collection of value objects that represent the types of the PHP type system",
            "homepage": "https://github.com/sebastianbergmann/type",
            "time": "2020-02-07T06:13:43+00:00"
        },
        {
            "name": "sebastian/version",
            "version": "3.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/sebastianbergmann/version.git",
                "reference": "0411bde656dce64202b39c2f4473993a9081d39e"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/sebastianbergmann/version/zipball/0411bde656dce64202b39c2f4473993a9081d39e",
                "reference": "0411bde656dce64202b39c2f4473993a9081d39e",
                "shasum": ""
            },
            "require": {
                "php": "^7.3"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.0-dev"
                }
            },
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Sebastian Bergmann",
                    "email": "sebastian@phpunit.de",
                    "role": "lead"
                }
            ],
            "description": "Library that helps with managing the version number of Git-hosted PHP projects",
            "homepage": "https://github.com/sebastianbergmann/version",
            "time": "2020-01-21T06:36:37+00:00"
        },
        {
            "name": "slevomat/coding-standard",
            "version": "4.8.7",
            "source": {
                "type": "git",
                "url": "https://github.com/slevomat/coding-standard.git",
                "reference": "bff96313d8c7c2ba57a4edb13c1c141df8988c58"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/slevomat/coding-standard/zipball/bff96313d8c7c2ba57a4edb13c1c141df8988c58",
                "reference": "bff96313d8c7c2ba57a4edb13c1c141df8988c58",
                "shasum": ""
            },
            "require": {
                "php": "^7.1",
                "squizlabs/php_codesniffer": "^3.4.0"
            },
            "require-dev": {
                "jakub-onderka/php-parallel-lint": "1.0.0",
                "phing/phing": "2.16.1",
                "phpstan/phpstan": "0.9.2",
                "phpstan/phpstan-phpunit": "0.9.4",
                "phpstan/phpstan-strict-rules": "0.9",
                "phpunit/phpunit": "7.5.1"
            },
            "type": "phpcodesniffer-standard",
            "autoload": {
                "psr-4": {
                    "SlevomatCodingStandard\\": "SlevomatCodingStandard"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "Slevomat Coding Standard for PHP_CodeSniffer complements Consistence Coding Standard by providing sniffs with additional checks.",
            "time": "2019-01-03T13:15:50+00:00"
        },
        {
            "name": "squizlabs/php_codesniffer",
            "version": "3.5.4",
            "source": {
                "type": "git",
                "url": "https://github.com/squizlabs/PHP_CodeSniffer.git",
                "reference": "dceec07328401de6211037abbb18bda423677e26"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/squizlabs/PHP_CodeSniffer/zipball/dceec07328401de6211037abbb18bda423677e26",
                "reference": "dceec07328401de6211037abbb18bda423677e26",
                "shasum": ""
            },
            "require": {
                "ext-simplexml": "*",
                "ext-tokenizer": "*",
                "ext-xmlwriter": "*",
                "php": ">=5.4.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^4.0 || ^5.0 || ^6.0 || ^7.0"
            },
            "bin": [
                "bin/phpcs",
                "bin/phpcbf"
            ],
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.x-dev"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Greg Sherwood",
                    "role": "lead"
                }
            ],
            "description": "PHP_CodeSniffer tokenizes PHP, JavaScript and CSS files and detects violations of a defined set of coding standards.",
            "homepage": "https://github.com/squizlabs/PHP_CodeSniffer",
            "keywords": [
                "phpcs",
                "standards"
            ],
            "time": "2020-01-30T22:20:29+00:00"
        },
        {
            "name": "symfony/process",
            "version": "v5.0.7",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/process.git",
                "reference": "c5ca4a0fc16a0c888067d43fbcfe1f8a53d8e70e"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/process/zipball/c5ca4a0fc16a0c888067d43fbcfe1f8a53d8e70e",
                "reference": "c5ca4a0fc16a0c888067d43fbcfe1f8a53d8e70e",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.0-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Symfony\\Component\\Process\\": ""
                },
                "exclude-from-classmap": [
                    "/Tests/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Fabien Potencier",
                    "email": "fabien@symfony.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony Process Component",
            "homepage": "https://symfony.com",
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2020-03-27T16:56:45+00:00"
        },
        {
            "name": "theseer/tokenizer",
            "version": "1.1.3",
            "source": {
                "type": "git",
                "url": "https://github.com/theseer/tokenizer.git",
                "reference": "11336f6f84e16a720dae9d8e6ed5019efa85a0f9"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/theseer/tokenizer/zipball/11336f6f84e16a720dae9d8e6ed5019efa85a0f9",
                "reference": "11336f6f84e16a720dae9d8e6ed5019efa85a0f9",
                "shasum": ""
            },
            "require": {
                "ext-dom": "*",
                "ext-tokenizer": "*",
                "ext-xmlwriter": "*",
                "php": "^7.0"
            },
            "type": "library",
            "autoload": {
                "classmap": [
                    "src/"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Arne Blankerts",
                    "email": "arne@blankerts.de",
                    "role": "Developer"
                }
            ],
            "description": "A small library for converting tokenized PHP source code into XML and potentially other formats",
            "time": "2019-06-13T22:48:21+00:00"
        },
        {
            "name": "webmozart/assert",
            "version": "1.7.0",
            "source": {
                "type": "git",
                "url": "https://github.com/webmozart/assert.git",
                "reference": "aed98a490f9a8f78468232db345ab9cf606cf598"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/webmozart/assert/zipball/aed98a490f9a8f78468232db345ab9cf606cf598",
                "reference": "aed98a490f9a8f78468232db345ab9cf606cf598",
                "shasum": ""
            },
            "require": {
                "php": "^5.3.3 || ^7.0",
                "symfony/polyfill-ctype": "^1.8"
            },
            "conflict": {
                "vimeo/psalm": "<3.6.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^4.8.36 || ^7.5.13"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Webmozart\\Assert\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Bernhard Schussek",
                    "email": "bschussek@gmail.com"
                }
            ],
            "description": "Assertions to validate method input/output with nice error messages.",
            "keywords": [
                "assert",
                "check",
                "validate"
            ],
            "time": "2020-02-14T12:15:55+00:00"
        }
    ],
    "aliases": [],
    "minimum-stability": "stable",
    "stability-flags": [],
    "prefer-stable": false,
    "prefer-lowest": false,
    "platform": {
        "php": "^7.4",
        "ext-intl": "*",
        "ext-json": "*",
        "ext-mbstring": "*"
    },
    "platform-dev": [],
    "plugin-api-version": "1.1.0"
}



================================================
FILE: docker-compose.yml
================================================
version: '3'
services:
  dev:
    build: .
    volumes:
      - ./:/code
    environment:
     - OAUTH_APP_NAME
     - OAUTH_APP_ID
     - OAUTH_APP_SECRET
     - OAUTH_ACCESS_TOKEN
     - OAUTH_REFRESH_TOKEN
     - TEST_SHAREPOINT_SITE




================================================
FILE: Dockerfile
================================================
FROM php:7.4-cli

ARG COMPOSER_FLAGS="--prefer-dist --no-interaction"
ARG DEBIAN_FRONTEND=noninteractive
ENV COMPOSER_ALLOW_SUPERUSER 1
ENV COMPOSER_PROCESS_TIMEOUT 3600

WORKDIR /code/

COPY docker/php-prod.ini /usr/local/etc/php/php.ini
COPY docker/composer-install.sh /tmp/composer-install.sh

RUN apt-get update && apt-get install -y --no-install-recommends \
        git \
        locales \
        unzip \
        curl \
        libicu-dev \
        libonig-dev \
	&& rm -r /var/lib/apt/lists/* \
	&& sed -i 's/^# *\(en_US.UTF-8\)/\1/' /etc/locale.gen \
	&& locale-gen \
	&& chmod +x /tmp/composer-install.sh \
	&& /tmp/composer-install.sh \
	&& docker-php-ext-install sockets mbstring intl

ENV LANGUAGE=en_US.UTF-8
ENV LANG=en_US.UTF-8
ENV LC_ALL=en_US.UTF-8

## Composer - deps always cached unless changed
# First copy only composer files
COPY composer.* /code/

# Download dependencies, but don't run scripts or init autoloaders as the app is missing
RUN composer install $COMPOSER_FLAGS --no-scripts --no-autoloader

# Copy rest of the app
COPY . /code/

# Run normal composer - all deps are cached already
RUN composer install $COMPOSER_FLAGS

CMD ["php", "/code/src/run.php"]



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) Keboola :(){:|:&};: s.r.o.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: phpcs.xml
================================================
<?xml version="1.0"?>
<ruleset name="Project">
    <rule ref="vendor/keboola/coding-standard/src/ruleset.xml"/>
</ruleset>



================================================
FILE: phpstan.neon
================================================
parameters:
    checkMissingIterableValueType: false
    checkGenericClassInNonGenericObjectType: false
    ignoreErrors:
        - '#Symfony\\Component\\Config\\Definition\\Builder\\NodeParentInterface\|null#'



================================================
FILE: phpunit.xml.dist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<phpunit backupGlobals="false"
         backupStaticAttributes="false"
         colors="true"
         convertErrorsToExceptions="true"
         convertNoticesToExceptions="true"
         convertWarningsToExceptions="true"
         processIsolation="false"
         stopOnFailure="false"
         bootstrap="tests/bootstrap.php">
    <testsuite name="Main Test Suite">
        <directory>tests/phpunit</directory>
    </testsuite>
    <filter>
        <whitelist processUncoveredFilesFromWhitelist="true">
            <directory suffix=".php">.</directory>
            <exclude>
                <directory suffix=".php">vendor</directory>
            </exclude>
        </whitelist>
    </filter>
</phpunit>



================================================
FILE: .dockerignore
================================================
vendor
.git



================================================
FILE: .env.example
================================================
OAUTH_APP_NAME=
OAUTH_APP_ID=
OAUTH_APP_SECRET=
OAUTH_ACCESS_TOKEN=
OAUTH_REFRESH_TOKEN=
TEST_SHAREPOINT_SITE=



================================================
FILE: docker/composer-install.sh
================================================
#!/bin/sh

EXPECTED_SIGNATURE=$(curl -s https://composer.github.io/installer.sig)
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
ACTUAL_SIGNATURE=$(php -r "echo hash_file('SHA384', 'composer-setup.php');")

if [ "$EXPECTED_SIGNATURE" != "$ACTUAL_SIGNATURE" ]
then
    >&2 echo 'ERROR: Invalid installer signature'
    rm composer-setup.php
    exit 1
fi

php composer-setup.php --quiet --install-dir=/usr/local/bin/ --filename=composer
RESULT=$?
rm composer-setup.php
exit $RESULT



================================================
FILE: docker/php-prod.ini
================================================
; Recommended production values
display_errors = Off
display_startup_errors = Off
error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT
html_errors = On
log_errors = On
max_input_time = 60
output_buffering = 4096
register_argc_argv = Off
request_order = "GP"
session.gc_divisor = 1000
session.sid_bits_per_character = 5
short_open_tag = Off
track_errors = Off
variables_order = "GPCS"

; Custom
date.timezone = UTC
memory_limit = -1



================================================
FILE: src/Component.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter;

use ArrayObject;
use Keboola\OneDriveWriter\Api\ApiFactory;
use Keboola\OneDriveWriter\Auth\TokenProviderFactory;
use Keboola\OneDriveWriter\Configuration\CreateWorkbookConfigDefinition;
use Keboola\OneDriveWriter\Configuration\CreateWorksheetConfigDefinition;
use Keboola\OneDriveWriter\Configuration\SyncActionConfigDefinition;
use Psr\Log\LoggerInterface;
use UnexpectedValueException;
use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use Keboola\OneDriveWriter\Api\Api;
use Keboola\Component\BaseComponent;
use Keboola\OneDriveWriter\Configuration\Config;
use Keboola\OneDriveWriter\Configuration\ConfigDefinition;

class Component extends BaseComponent
{
    public const ACTION_RUN = 'run';
    public const ACTION_SEARCH = 'search';
    public const ACTION_GET_WORKSHEETS = 'getWorksheets';
    public const ACTION_CREATE_WORKBOOK = 'createWorkbook';
    public const ACTION_CREATE_WORKSHEET = 'createWorksheet';

    private ArrayObject $stateObject;

    private Api $api;

    private SheetProvider $sheetProvider;

    public function __construct(LoggerInterface $logger)
    {
        parent::__construct($logger);
        $config = $this->getConfig();
        $this->stateObject = new ArrayObject($this->getInputState());

        $tokenProviderFactory = new TokenProviderFactory($config, $this->stateObject, $logger);
        $tokenProvider = $tokenProviderFactory->create();
        $apiFactory = new ApiFactory($logger, $tokenProvider);
        $this->api = $apiFactory->create();
        $this->sheetProvider = new SheetProvider($this->api, $this->getConfig());
    }

    public function execute(): void
    {
        try {
            parent::execute();
        } finally {
            $this->writeOutputStateToFile($this->stateObject->getArrayCopy());
        }
    }

    public function getConfig(): Config
    {
        $config = parent::getConfig();
        assert($config instanceof Config);
        return $config;
    }

    protected function getSyncActions(): array
    {
        return [
            self::ACTION_SEARCH => 'handleSearchSyncAction',
            self::ACTION_GET_WORKSHEETS => 'handleGetWorksheetsSyncAction',
            self::ACTION_CREATE_WORKBOOK => 'handleCreateWorkbookSyncAction',
            self::ACTION_CREATE_WORKSHEET => 'handleCreateWorksheetSyncAction',
        ];
    }

    protected function run(): void
    {
        $sheet = $this->sheetProvider->getSheet();
        $this->createWriter()->write($sheet);
    }

    protected function handleSearchSyncAction(): array
    {
        try {
            $file = $this->api->searchWorkbook($this->getConfig()->getPath());
        } catch (ResourceNotFoundException $e) {
            $file = null;
        }

        return [
            'file' => $file,
        ];
    }

    protected function handleGetWorksheetsSyncAction(): array
    {
        $workbook = $this->sheetProvider->getFile();
        $worksheets = iterator_to_array($this->api->getSheets($workbook->getDriveId(), $workbook->getFileId()));
        return [
            'worksheets' => $worksheets,
        ];
    }

    protected function handleCreateWorkbookSyncAction(): array
    {
        $file = $this->sheetProvider->createFile();
        return [
            'file' => $file,
        ];
    }

    protected function handleCreateWorksheetSyncAction(): array
    {
        $sheet = $this->sheetProvider->createSheet();
        return [
            'worksheet' => $sheet,
        ];
    }

    protected function getConfigClass(): string
    {
        return Config::class;
    }

    protected function getConfigDefinitionClass(): string
    {
        $action = $this->getRawConfig()['action'] ?? 'run';
        switch ($action) {
            case self::ACTION_RUN:
                return ConfigDefinition::class;
            case self::ACTION_CREATE_WORKBOOK:
                return CreateWorkbookConfigDefinition::class;
            case self::ACTION_CREATE_WORKSHEET:
                return CreateWorksheetConfigDefinition::class;
            case self::ACTION_SEARCH:
            case self::ACTION_GET_WORKSHEETS:
                return SyncActionConfigDefinition::class;
            default:
                throw new UnexpectedValueException(sprintf('Unexpected action "%s"', $action));
        }
    }

    private function createWriter(): Writer
    {
        return new Writer(
            $this->getLogger(),
            $this->api,
            $this->getDataDir(),
            $this->getConfig(),
        );
    }
}



================================================
FILE: src/run.php
================================================
<?php

declare(strict_types=1);

use Keboola\CommonExceptions\UserExceptionInterface;
use Keboola\Component\Logger;
use Keboola\OneDriveWriter\Component;

require __DIR__ . '/../vendor/autoload.php';

$logger = new Logger();
try {
    $app = new Component($logger);
    $app->execute();
    exit(0);
} catch (UserExceptionInterface $e) {
    $logger->error($e->getMessage());
    exit(1);
} catch (\Throwable $e) {
    $logger->critical(
        get_class($e) . ':' . $e->getMessage(),
        [
            'errFile' => $e->getFile(),
            'errLine' => $e->getLine(),
            'errCode' => $e->getCode(),
            'errTrace' => $e->getTraceAsString(),
            'errPrevious' => is_object($e->getPrevious()) ? get_class($e->getPrevious()) : '',
        ]
    );
    exit(2);
}



================================================
FILE: src/Sheet.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter;

class Sheet implements \JsonSerializable
{
    private SheetFile $file;

    private string $id;

    private string $name;

    private bool $new;

    public function __construct(SheetFile $file, string $id, string $name, bool $new)
    {
        $this->file = $file;
        $this->id = $id;
        $this->name = $name;
        $this->new = $new;
    }

    public function getDriveId(): string
    {
        return $this->file->getDriveId();
    }

    public function getFileId(): string
    {
        return $this->file->getFileId();
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function isNew(): bool
    {
        return $this->new;
    }

    public function jsonSerialize(): array
    {
        return [
            'driveId' => $this->getDriveId(),
            'fileId' => $this->getFileId(),
            'worksheetId' => $this->id,
        ];
    }
}



================================================
FILE: src/SheetFile.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter;

class SheetFile implements \JsonSerializable
{
    private string $driveId;

    private string $fileId;

    private bool $new;

    public function __construct(string $driveId, string $fileId, bool $new)
    {
        $this->driveId = $driveId;
        $this->fileId = $fileId;
        $this->new = $new;
    }

    public function getDriveId(): string
    {
        return $this->driveId;
    }

    public function getFileId(): string
    {
        return $this->fileId;
    }

    public function isNew(): bool
    {
        return $this->new;
    }

    public function jsonSerialize(): array
    {
        return [
            'driveId' => $this->driveId,
            'fileId' => $this->fileId,
        ];
    }
}



================================================
FILE: src/SheetProvider.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter;

use Keboola\OneDriveWriter\Api\Api;
use Keboola\OneDriveWriter\Configuration\Config;
use Keboola\OneDriveWriter\Exception\FileInDriveNotFoundException;
use Keboola\OneDriveWriter\Exception\InvalidConfigException;
use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use Keboola\OneDriveWriter\Exception\WorkbookAlreadyExistsException;

class SheetProvider
{
    private Api $api;

    private Config $config;

    public function __construct(Api $api, Config $config)
    {
        $this->api = $api;
        $this->config = $config;
    }

    public function getSheet(): Sheet
    {
        $config = $this->config;
        $workbook = $this->getFile();

        try {
            if ($config->hasWorksheetId()) {
                return $this->getSheetById($workbook, $this->config->getWorksheetId());
            } elseif ($config->hasWorksheetPosition()) {
                return $this->getSheetByPosition($workbook, $this->config->getWorksheetPosition());
            } else {
                return $this->getSheetByName($workbook, $config->getWorksheetName());
            }
        } catch (ResourceNotFoundException $e) {
            throw new ResourceNotFoundException('Worksheet not found.', 0, $e);
        }
    }

    public function createSheet(): Sheet
    {
        if (!$this->config->hasWorksheetName()) {
            throw new InvalidConfigException(
                'To create worksheet please configure "parameters.worksheet.name".'
            );
        }

        $sheet = $this->getSheetByName($this->getFile(), $this->config->getWorksheetName());
        if (!$sheet->isNew()) {
            throw new WorkbookAlreadyExistsException(
                sprintf('Worksheet "%s" already exists.', $this->config->getWorksheetName())
            );
        }

        return $sheet;
    }

    public function getFile(): SheetFile
    {
        $config = $this->config;

        // Get by IDS
        if ($config->hasDriveId() && $config->hasFileId()) {
            $this->api->createWorkbookSessionId($config->getDriveId(), $config->getFileId());
            return $this->getFileByIds($config->getDriveId(), $config->getFileId());
        }

        // Search or create by path
        return $this->getFileByPath($config->getPath());
    }

    public function createFile(): SheetFile
    {
        if (!$this->config->hasPath()) {
            throw new InvalidConfigException(
                'To create workbook please configure "parameters.workbook.path".'
            );
        }

        $file = $this->getFileByPath($this->config->getPath());
        if (!$file->isNew()) {
            throw new WorkbookAlreadyExistsException(
                sprintf('Workbook "%s" already exists.', $this->config->getPath())
            );
        }

        return $file;
    }

    private function getFileByIds(string $driveId, string $fileId): SheetFile
    {
        try {
            // Check if workbook exists
            $this->api->getSheets($driveId, $fileId)->current();
            return new SheetFile($driveId, $fileId, false);
        } catch (ResourceNotFoundException $e) {
            throw new ResourceNotFoundException('Configured workbook XLSX file not found.', 0, $e);
        }
    }

    private function getFileByPath(string $path): SheetFile
    {
        try {
            $file = $this->api->searchWorkbook($path);
            $new = false;
        } catch (FileInDriveNotFoundException $e) {
            $file = $this->api->createEmptyWorkbook($e->getEndpointUrl());
            $new = true;
        } catch (ResourceNotFoundException $e) {
            throw new ResourceNotFoundException(
                sprintf('No file found when searching for "%s".', $path),
                0,
                $e
            );
        }

        return new SheetFile($file->getDriveId(), $file->getFileId(), $new);
    }

    private function getSheetById(SheetFile $workbook, string $sheetId): Sheet
    {
        $sheetName = $this->api->getSheetName($workbook->getDriveId(), $workbook->getFileId(), $sheetId);
        return new Sheet($workbook, $sheetId, $sheetName, false);
    }

    private function getSheetByPosition(SheetFile $workbook, int $position): Sheet
    {
        $position = $this->config->getWorksheetPosition();
        $sheetId = $this->api->getSheetIdByPosition($workbook->getDriveId(), $workbook->getFileId(), $position);
        $sheetName = $this->api->getSheetName($workbook->getDriveId(), $workbook->getFileId(), $sheetId);
        return new Sheet($workbook, $sheetId, $sheetName, false);
    }

    private function getSheetByName(SheetFile $workbook, string $sheetName): Sheet
    {
        try {
            $sheetId = $this->api->getSheetIdByName(
                $workbook->getDriveId(),
                $workbook->getFileId(),
                $sheetName
            );
            $new = false;
        } catch (ResourceNotFoundException $e) {
            $sheetId = $this->api->createSheet($workbook->getDriveId(), $workbook->getFileId(), $sheetName);
            $new = true;
        }

        return new Sheet($workbook, $sheetId, $sheetName, $new);
    }
}



================================================
FILE: src/Writer.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter;

use Keboola\OneDriveWriter\Configuration\Config;
use SplFileInfo;
use Psr\Log\LoggerInterface;
use Keboola\Csv\CsvReader;
use Keboola\OneDriveWriter\Exception\CsvFileException;
use Keboola\OneDriveWriter\Api\Api;
use Symfony\Component\Finder\Finder;

class Writer
{
    private LoggerInterface $logger;

    private Api $api;

    private string $inputDir;

    private Config $config;

    public function __construct(
        LoggerInterface $logger,
        Api $api,
        string $dataDir,
        Config $config
    ) {
        $this->logger = $logger;
        $this->api = $api;
        $this->inputDir = $dataDir . '/in/tables';
        $this->config = $config;
    }

    public function write(Sheet $sheet): void
    {
        $file = $this->findCsv();
        $csv = new CsvReader($file->getPathname());
        $header = $csv->getHeader();

        // Ignore empty file
        if (empty($header)) {
            $this->logger->warning(sprintf('Ignored empty CSV file "%s".', $file->getBasename()));
            return;
        }

        // Rename sheet
        if ($this->config->hasWorksheetName() && $this->config->getWorksheetName() !== $sheet->getName()) {
            $this->api->renameSheet(
                $sheet->getDriveId(),
                $sheet->getFileId(),
                $sheet->getId(),
                $this->config->getWorksheetName()
            );
        }

        // Insert rows
        $this->api->insertRows($sheet, $this->config->getAppend(), $csv, $this->config->getBatchSize());
    }

    private function findCsv(): SplFileInfo
    {
        // Find CSV files in input directory
        $finder = new Finder();
        $files = iterator_to_array(
            $finder->files()->in($this->inputDir)->name('*.csv')->getIterator(),
            false
        );

        // Expected is exact one CSV file
        if (count($files) === 0) {
            throw new CsvFileException(sprintf('No CSV file found in "%s".', $this->inputDir));
        } elseif (count($files) > 1) {
            throw new CsvFileException(sprintf(
                'Expected one CSV file, found multiple: "%s".',
                implode('", "', array_map(fn(SplFileInfo $file) => $file->getBasename(), $files))
            ));
        }

        /** @var SplFileInfo $file */
        $file = $files[0];
        $this->logger->info(sprintf('Found input CSV file "%s".', $file->getBasename()));
        return $file;
    }
}



================================================
FILE: src/Api/Api.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api;

use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use Keboola\OneDriveWriter\Api\Model\WorkbookSession;
use Keboola\OneDriveWriter\Exception\GatewayTimeoutException;
use Keboola\OneDriveWriter\Exception\InvalidSessionException;
use Keboola\OneDriveWriter\Exception\UserException;
use Throwable;
use Iterator;
use Psr\Log\LoggerInterface;
use GuzzleHttp\Exception\RequestException;
use Microsoft\Graph\Graph;
use Microsoft\Graph\Http\GraphResponse;
use Retry\RetryProxy;
use Retry\BackOff\ExponentialBackOffPolicy;
use Retry\Policy\CallableRetryPolicy;
use Keboola\OneDriveWriter\Sheet;
use Keboola\OneDriveWriter\Api\Model\TableRange;
use Keboola\OneDriveWriter\Api\Model\TableHeader;
use Keboola\OneDriveWriter\Exception\BatchRequestException;
use Keboola\OneDriveWriter\Api\Batch\BatchRequest;
use Keboola\OneDriveWriter\Api\Model\File;
use Keboola\OneDriveWriter\Api\Model\Site;
use Keboola\OneDriveWriter\Api\Model\Worksheet;
use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use Keboola\OneDriveWriter\Exception\UnexpectedCountException;
use Keboola\OneDriveWriter\Exception\UnexpectedValueException;

class Api
{
    public const RETRY_HTTP_CODES = [
        405, // 405 - Method not allowed, it occurs when the creation of a new sheet is not yet fully propagated
        409, // 409 Conflict
        500, // 500 Internal Serve Error
        502, // 502 Bad Gateway
        503, // 503 Service Unavailable
        504, // 504 Gateway Timeout
    ];

    public const RETRY_MAX_ATTEMPTS = 14;
    public const MAX_INTERVAL = 5000;

    private Graph $graphApi;

    private LoggerInterface $logger;

    private ?ClientInterface $httpClient = null;

    private ?WorkbookSession $workbookSession = null;

    public function __construct(Graph $graphApi, LoggerInterface $logger)
    {
        $this->graphApi = $graphApi;
        $this->logger = $logger;
    }

    public function __destruct()
    {
        $this->closeSession();
    }

    public function getAccountName(): string
    {
        $response = $this->get('/me?$select=userPrincipalName')->getBody();
        return (string) $response['userPrincipalName'];
    }

    public function createEmptyWorkbook(string $endpoint): File
    {
        $uploader = new FileUploader($this);
        $file = $uploader->upload($endpoint, __DIR__ . '/Fixtures/empty.xlsx');
        $this->createWorkbookSessionId($file->getDriveId(), $file->getFileId());
        $this->logger->info(sprintf('New workbook "%s" created.', implode('/', $file->getPathname())));
        return $file;
    }

    public function insertRows(
        Sheet $sheet,
        bool $append,
        Iterator $rows,
        int $batchSize = 30000
    ): void {
        $manager = new InsertRowsManager($this->logger, $this);
        $manager->insert($sheet, $append, $rows, $batchSize);
    }

    public function clearSheet(Sheet $sheet): void
    {
        $endpoint = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}';
        $uri = $endpoint . '/range/clear';

        $this->post(
            $uri,
            [
                'driveId' => $sheet->getDriveId(),
                'fileId' => $sheet->getFileId(),
                'worksheetId' => $sheet->getId(),
            ],
            [ 'applyTo' => 'all',]
        );
        $this->logger->info('Sheet cleared.');
    }

    public function createSheet(string $driveId, string $fileId, string $newName): string
    {
        $uri = '/drives/{driveId}/items/{fileId}/workbook/worksheets';
        $body = $this->post(
            $uri,
            ['driveId' => $driveId, 'fileId' => $fileId],
            [ 'name' => $newName]
        )->getBody();
        $this->logger->info(sprintf('New sheet "%s" created.', $newName));
        return $body['id'];
    }

    public function renameSheet(
        string $driveId,
        string $fileId,
        string $worksheetId,
        string $newName
    ): void {
        $uri = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}';

        $this->patch(
            $uri,
            ['driveId' => $driveId, 'fileId' => $fileId, 'worksheetId' => $worksheetId],
            [ 'name' => $newName]
        );

        $this->logger->info(sprintf('Sheet renamed to "%s".', $newName));
    }

    public function getSheetHeader(Sheet $sheet): TableHeader
    {
        // Table header is first row in worksheet
        // Table can be shifted because we use "usedRange".
        $endpoint = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}';
        $uri = $endpoint . '/usedRange(valuesOnly=true)/row(row=0)?$select=address,text';

        $body = $this
            ->get(
                $uri,
                [
                    'driveId' => $sheet->getDriveId(),
                    'fileId' => $sheet->getFileId(),
                    'worksheetId' => $sheet->getId(),
                ]
            )
            ->getBody();

        $header = TableHeader::from($body['address'], $body['text'][0]);
        $this->logger->info(sprintf(
            'Current sheet header "%s": %s',
            $header->getAddress(),
            Helpers::formatIterable($header->getColumns()),
        ));
        return $header;
    }

    public function getSheetRange(Sheet $sheet): TableRange
    {
        $endpoint = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}';
        $uri = $endpoint . '/usedRange(valuesOnly=true)?$select=address';
        $body = $this
            ->get(
                $uri,
                [
                    'driveId' => $sheet->getDriveId(),
                    'fileId' => $sheet->getFileId(),
                    'worksheetId' => $sheet->getId(),
                ]
            )
            ->getBody();

        $range =  TableRange::from($body['address']);
        if ($range->isEmpty()) {
            $this->logger->info('Sheet is empty.');
        } else {
            $this->logger->info(sprintf('Current sheet range: "%s"', $range->getAddress()));
        }

        return $range;
    }


    public function getSheetName(string $driveId, string $fileId, string $worksheetId): string
    {
        $uri = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}?$select=name';
        $body = $this
            ->get($uri, ['driveId' => $driveId, 'fileId' => $fileId, 'worksheetId' => $worksheetId])
            ->getBody();
        return $body['name'];
    }

    public function getSheetIdByName(string $driveId, string $fileId, string $name): string
    {
        // Load list of worksheets in workbook
        $uri = '/drives/{driveId}/items/{fileId}/workbook/worksheets?$select=id,name,position';
        $body = $this->get($uri, ['driveId' => $driveId, 'fileId' => $fileId])->getBody();

        // Search by position
        $worksheet = null;
        foreach ($body['value'] as $data) {
            if ($data['name'] === $name) {
                $worksheet = $data;
                break;
            }
        }

        // Log and return
        if ($worksheet) {
            $this->logger->info(sprintf(
                'Found worksheet "%s" at position "%s".',
                $worksheet['name'],
                $worksheet['position']
            ));
            return $worksheet['id'];
        }

        throw new ResourceNotFoundException(sprintf('No worksheet with name "%s".', $name));
    }


    public function getSheetIdByPosition(string $driveId, string $fileId, int $position): string
    {
        // Check position value, must be greater than zero
        if ($position < 0) {
            throw new UnexpectedValueException(sprintf(
                'Worksheet position must be greater than zero. Given "%d".',
                $position
            ));
        }

        // Load list of worksheets in workbook
        $uri = '/drives/{driveId}/items/{fileId}/workbook/worksheets?$select=id,name,position';
        $body = $this->get($uri, ['driveId' => $driveId, 'fileId' => $fileId])->getBody();

        // Search by position
        $worksheet = null;
        foreach ($body['value'] as $data) {
            if ($data['position'] === $position) {
                $worksheet = $data;
                break;
            }
        }

        // Log and return
        if ($worksheet) {
            $this->logger->info(sprintf(
                'Found worksheet "%s" at position "%s".',
                $worksheet['name'],
                $position
            ));
            return $worksheet['id'];
        }

        throw new ResourceNotFoundException(sprintf('No worksheet at position "%d".', $position));
    }

    /**
     * @return Iterator|Worksheet[]
     */
    public function getSheets(string $driveId, string $fileId): Iterator
    {
        // Load list of worksheets in workbook
        $uri = '/drives/{driveId}/items/{fileId}/workbook/worksheets?$select=id,position,name,visibility';
        $body = $this
            ->get($uri, ['driveId' => $driveId, 'fileId' => $fileId])
            ->getBody();

        // Map to object and load header in batch request
        $batch = $this->createBatchRequest();
        foreach ($body['value'] as $data) {
            $worksheet = Worksheet::from($data, $driveId, $fileId);
            $endpoint = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}';
            $uri = $endpoint . '/usedRange(valuesOnly=true)/row(row=0)?$select=address,text';
            $args = ['driveId' => $driveId, 'fileId' => $fileId, 'worksheetId' => $worksheet->getWorksheetId()];
            $batch->addRequest($uri, $args, function (array $body) use ($worksheet) {
                if (isset($body['address'])) {
                    $header = TableHeader::from($body['address'], $body['text'][0]);
                    $worksheet->setHeader($header);
                    yield $worksheet;
                }
            });
        }

        // Load headers for worksheets in one request, sort by position
        $backOffPolicy = new ExponentialBackOffPolicy(500, 2.0, self::MAX_INTERVAL);
        $retryPolicy = new CallableRetryPolicy(function (Throwable $e) {
            // Retry on connect exception, eg. Could not resolve host: login.microsoftonline.com
            if ($e instanceof ConnectException) {
                return true;
            }

            if ($e instanceof UserException && strpos($e->getMessage(), 'Request took too long') !== false) {
                return true;
            }
            return false;
        }, self::RETRY_MAX_ATTEMPTS);
        $proxy = new RetryProxy($retryPolicy, $backOffPolicy, $this->logger);

        $worksheets = $proxy->call(function () use ($batch) {
            return iterator_to_array($batch->execute());
        });

        usort($worksheets, fn(Worksheet $a, Worksheet $b) => $a->getPosition() - $b->getPosition());
        yield from $worksheets;
    }

    public function getSite(string $name): Site
    {
        $response = $this->get('/sites?search={name}&$select=id,name', ['name' => $name]);
        $body = $response->getBody();
        $count = count($body['value']);
        if ($count === 1) {
            $siteData = $body['value'][0];
            return Site::from($siteData);
        } elseif ($count === 0) {
            throw new ResourceNotFoundException(sprintf('Site "%s" not found.', $name));
        } else {
            throw new UnexpectedCountException(sprintf('Multiple sites found when searching for "%s".', $name));
        }
    }

    public function createWorkbookSessionId(string $driveId, string $fileId): void
    {
        $uri = '/drives/{driveId}/items/{fileId}/workbook/createSession';

        try {
            $response = $this->post(
                $uri,
                [
                    'driveId' => $driveId,
                    'fileId' => $fileId,
                ],
                [
                    'persistChanges' => true,
                ],
                [
                    'Prefer' => 'respond-async',
                ],
            );
        } catch (ResourceNotFoundException $e) {
            throw new ResourceNotFoundException('Configured workbook XLSX file not found.', 0, $e);
        }

        switch ($response->getStatus()) {
            case 201:
                $this->workbookSession = new WorkbookSession($driveId, $fileId, $response->getBody()['id']);
                $this->logger->info('Write data using the session.');
                return;
            case 202:
                $responseHeader = $response->getHeaders();

                $sessionLocation = current($responseHeader['Location']);

                $status = 'running';
                while ($status === 'running') {
                    sleep(2);
                    $session = $this->get($sessionLocation)->getBody();
                    $status = $session['status'];
                }

                if ($status !== 'succeeded') {
                    $this->logger->info('The workbook session could not be created.');
                    return;
                }

                $sessionResource = $this->get($session['resourceLocation'])->getBody();

                $this->workbookSession = new WorkbookSession($driveId, $fileId, $sessionResource['id']);
                $this->logger->info('Write data using the session.');
                return;
            default:
                $this->logger->info('The workbook session could not be created.');
        }
    }

    public function closeSession(): void
    {
        if (!$this->workbookSession) {
            return;
        }

        $uri = '/drives/{driveId}/items/{fileId}/workbook/closeSession';
        try {
            $this->post(
                $uri,
                [
                    'driveId' => $this->workbookSession->getDriveId(),
                    'fileId' => $this->workbookSession->getFileId(),
                ]
            );
        } catch (Throwable $e) {
        }
    }

    public function searchWorkbook(string $search = ''): File
    {
        $finder = new WorkbooksFinder($this, $this->logger);
        $file = $finder->search($search);
        $this->createWorkbookSessionId($file->getDriveId(), $file->getFileId());
        $this->logger->info(sprintf('Found workbook "%s".', $file->getName()));
        return $file;
    }

    public function getGraph(): Graph
    {
        return $this->graphApi;
    }

    public function createBatchRequest(): BatchRequest
    {
        return new BatchRequest($this);
    }

    public function get(string $uri, array $params = [], array $headers = []): GraphResponse
    {
        return $this->executeWithRetry('GET', $uri, $params, [], $headers);
    }

    public function post(string $uri, array $params = [], array $body = [], array $headers = []): GraphResponse
    {
        return $this->executeWithRetry('POST', $uri, $params, $body, $headers);
    }

    public function patch(string $uri, array $params = [], array $body = [], array $headers = []): GraphResponse
    {
        return $this->executeWithRetry('PATCH', $uri, $params, $body, $headers);
    }

    private function executeWithRetry(
        string $method,
        string $uri,
        array $params = [],
        array $body = [],
        array $headers = []
    ): GraphResponse {
        $backOffPolicy = new ExponentialBackOffPolicy(500, 2.0, self::MAX_INTERVAL);
        $retryPolicy = new CallableRetryPolicy(function (Throwable $e) {
            // Retry on connect exception, eg. Could not resolve host: login.microsoftonline.com
            if ($e instanceof ConnectException) {
                return true;
            }

            if ($e instanceof InvalidSessionException) {
                $this->workbookSession = null;
                $this->logger->info('Session expired, will recreate and retry.');
                return true;
            }

            if ($e instanceof RequestException
                || $e instanceof BatchRequestException
                || $e instanceof GatewayTimeoutException
            ) {
                // Retry only on defined HTTP codes
                if (in_array($e->getCode(), self::RETRY_HTTP_CODES, true)) {
                    return true;
                }

                // Retry if communication problems
                if (strpos($e->getMessage(), 'There were communication or server problems') !== false) {
                    return true;
                }

                if (strpos($e->getMessage(), 'EditModeCannotAcquireLockTooManyRequests') !== false) {
                    return true;
                }
            }

            if ($e instanceof UserException && $e->getCode() === 429) {
                $previous = $e->getPrevious();
                assert($previous instanceof RequestException);
                assert($previous->getResponse() !== null);
                if ($previous->getResponse()->hasHeader('Retry-After')) {
                    if ((int) $previous->getResponse()->getHeader('Retry-After')[0] > self::MAX_INTERVAL) {
                        return false;
                    }
                }
                return true;
            }

            return false;
        }, self::RETRY_MAX_ATTEMPTS);
        $proxy = new RetryProxy($retryPolicy, $backOffPolicy, $this->logger);
        return $proxy->call(function () use ($method, $uri, $params, $body, $headers) {
            return $this->execute($method, $uri, $params, $body, $headers);
        });
    }

    private function execute(
        string $method,
        string $uri,
        array $params = [],
        array $body = [],
        array $headers = []
    ): GraphResponse {
        $uri = Helpers::replaceParamsInUri($uri, $params);
        $request = $this->graphApi->createRequest($method, $uri);

        if ($body) {
            $request->attachBody($body);
        }

        if ($headers) {
            $request->addHeaders($headers);
        }

        if ($this->workbookSession instanceof WorkbookSession) {
            $request->addHeaders([
                'Workbook-Session-Id' => $this->workbookSession->getSessionId(),
            ]);
        }

        try {
            return $request->execute($this->httpClient);
        } catch (RequestException $e) {
            throw Helpers::processRequestException($e);
        }
    }

    public function setHttpClient(ClientInterface $httpClient): void
    {
        $this->httpClient = $httpClient;
    }
}



================================================
FILE: src/Api/ApiFactory.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api;

use Psr\Log\LoggerInterface;
use Keboola\OneDriveWriter\Auth\TokenProvider;

class ApiFactory
{
    private LoggerInterface $logger;

    private TokenProvider $tokenProvider;

    public function __construct(LoggerInterface $logger, TokenProvider $tokenProvider)
    {
        $this->logger = $logger;
        $this->tokenProvider = $tokenProvider;
    }

    public function create(): Api
    {
        $graphApiFactory = new GraphApiFactory();
        $graphApi = $graphApiFactory->create($this->tokenProvider->get());
        return new Api($graphApi, $this->logger);
    }
}



================================================
FILE: src/Api/FileUploader.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api;

use RuntimeException;
use Microsoft\Graph\Model;
use Keboola\OneDriveWriter\Api\Model\File;

class FileUploader
{
    private Api $api;

    public function __construct(Api $api)
    {
        $this->api = $api;
    }

    public function upload(string $endpoint, string $localPath): File
    {
        // The size of each byte range MUST be a multiple of 320 KiB
        // https://docs.microsoft.com/cs-cz/graph/api/driveitem-createuploadsession?view=graph-rest-1.0#upload-bytes-to-the-upload-session
        $uploadFragSize = 320 * 1024 * 10; // 3.2 MiB
        $fileSize = filesize($localPath);

        // Create upload session
        $uploadSession = $this->createUploadSession($endpoint);

        // Upload file in parts
        $file = fopen($localPath, 'r');
        if (!$file) {
            throw new RuntimeException(sprintf('Cannot open file "%s".', $localPath));
        }

        try {
            while (!feof($file)) {
                $start = ftell($file);
                $data = fread($file, $uploadFragSize);
                $end = ftell($file);
                $uploadSession = $this
                    ->api
                    ->getGraph()
                    ->createRequest('PUT', $uploadSession->getUploadUrl())
                    ->addHeaders([
                        'Authorization' => '',
                        'Content-Length' => $end - $start,
                        'Content-Range' => sprintf('bytes %d-%d/%d', $start, $end-1, $fileSize),
                    ])
                    ->attachBody($data)
                    ->setReturnType(Model\UploadSession::class)
                    ->setTimeout('1000')
                    ->execute();
            }
        } finally {
            fclose($file);
        }

        // Uploaded
        return File::from($uploadSession->getProperties());
    }

    private function createUploadSession(string $url): Model\UploadSession
    {
        $uploadSession = $this
            ->api
            ->getGraph()
            ->createRequest('POST', $url . 'createUploadSession')
            ->attachBody(['@microsoft.graph.conflictBehavior'=> 'replace' ])
            ->setReturnType(Model\UploadSession::class)
            ->setTimeout('1000')
            ->execute();
        assert($uploadSession instanceof Model\UploadSession);
        return $uploadSession;
    }
}



================================================
FILE: src/Api/GraphApiFactory.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api;

use League\OAuth2\Client\Token\AccessTokenInterface;
use Microsoft\Graph\Graph;

class GraphApiFactory
{
    public function create(AccessTokenInterface $token): Graph
    {
        $api = new Graph();
        $api->setAccessToken($token->getToken());
        return $api;
    }
}



================================================
FILE: src/Api/Helpers.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api;

use InvalidArgumentException;
use Keboola\OneDriveWriter\Exception\BadRequestException;
use Keboola\OneDriveWriter\Exception\BatchRequestException;
use Keboola\OneDriveWriter\Exception\GatewayTimeoutException;
use Keboola\OneDriveWriter\Exception\InvalidSessionException;
use Keboola\OneDriveWriter\Exception\UserException;
use Normalizer;
use GuzzleHttp\Exception\RequestException;
use Keboola\Component\JsonHelper;
use Keboola\OneDriveWriter\Exception\InvalidFileTypeException;
use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use Psr\Http\Message\MessageInterface;

class Helpers
{
    public static function isFilePath(string $str): bool
    {
        // Relative or absolute path
        return preg_match('~^(/?[^/]+)(/[^/]+)*$~ui', $str) === 1;
    }

    public static function isDriveFilePath(string $str): bool
    {
        try {
            self::explodeDriveFilePath($str);
            return true;
        } catch (InvalidArgumentException $e) {
            return false;
        }
    }

    public static function isSiteFilePath(string $str): bool
    {
        try {
            self::explodeSiteFilePath($str);
            return true;
        } catch (InvalidArgumentException $e) {
            return false;
        }
    }

    public static function isHttpsUrl(string $str): bool
    {
        return preg_match('~^https://~', $str) === 1;
    }

    public static function explodeDriveFilePath(string $str): array
    {
        preg_match('~^drive://([^/]+)/(.+)$~', $str, $m);
        if (!$m) {
            throw new InvalidArgumentException('Input not match regexp.');
        }
        $site = urldecode(rtrim($m[1], '/'));
        $path = $m[2];
        return [$site, $path];
    }

    public static function explodeSiteFilePath(string $str): array
    {
        preg_match('~^site://([^/]+)/(.+)$~', $str, $m);
        if (!$m) {
            throw new InvalidArgumentException('Input not match regexp.');
        }
        $site = urldecode(rtrim($m[1], '/'));
        $path = $m[2];
        return [$site, $path];
    }

    public static function processRequestException(\Throwable $e): \Throwable
    {
        $error = null;
        if ($e instanceof RequestException) {
            $error = Helpers::getErrorFromRequestException($e);
        } elseif ($e instanceof BatchRequestException) {
            $error = $e->getErrorCode();
        }

        if ($error === 'AccessDenied: Could not obtain a WAC access token.') {
            $msg = 'It looks like the specified file is not in the "XLSX" Excel format. Error: "%s"';
            return new InvalidFileTypeException(sprintf($msg, $error), 0, $e);
        } elseif ($error && strpos($error, 'ItemNotFound:') === 0) {
            $msg = 'The resource could not be found. Uri: "%s"';
            $uri = $e instanceof RequestException ? $e->getRequest()->getUri() : '';
            return new ResourceNotFoundException(sprintf($msg, $uri), 0, $e);
        } elseif ($e->getCode() === 404) {
            // ResourceNotFound, eg. bad fileId, "-1, Microsoft.SharePoint.Client.ResourceNotFoundException"
            return new ResourceNotFoundException(
                'Not found error. Please check configuration. ' .
                'It can be caused by typo in an ID, or resource doesn\'t exists.',
                $e->getCode(),
                $e
            );
        } elseif ($error && strpos($error, 'BadRequest: ') === 0) {
            // eg. BadRequest: Tenant does not have a SPO license.
            return new BadRequestException($error, 0, $e);
        } elseif ($error && strpos($error, 'InvalidSession:') === 0) {
            return new InvalidSessionException(
                'OneDrive API session expired or is invalid. ' .
                'The session will be recreated automatically. ' .
                'API error: ' . $error,
                $e->getCode(),
                $e
            );
        } elseif ($e->getCode() === 400) {
            // BadRequest, eg. bad fileId, "-1, Microsoft.SharePoint.Client.InvalidClientQueryException"
            return new BadRequestException(sprintf(
                'Bad request error. Please check configuration. ' .
                'It can be caused by typo in an ID, or resource doesn\'t exists. ' .
                'API error: %s',
                $error ?: $e->getMessage(),
            ), $e->getCode(), $e);
        } elseif ($error === 'GenericFileOpenError') {
            return new UserException('OneDrive API error: The workbook cannot be opened. Make sure ' .
                'nobody is editing it.');
        } elseif ($error === 'UnknownError') {
            return new UserException('OneDrive API error: The service is unavailable.');
        } elseif ($error === 'MaxRequestDurationExceeded') {
            return new UserException('OneDrive API error: Request took too long.');
        } elseif ($e->getCode() === 504) {
            return new GatewayTimeoutException(
                'Gateway Timeout Error. The Microsoft OneDrive API has some problems. ' .
                'Please try again later. API message: ' . $e->getMessage(),
                $e->getCode(),
                $e
            );
        } elseif ($e->getCode() === 429) {
            if ($e instanceof RequestException) {
                assert($e->getResponse() !== null);
                if ($e->getResponse()->hasHeader('Retry-After')) {
                    $retryAfter = (int) $e->getResponse()->getHeader('Retry-After')[0];
                    if ($retryAfter > Api::MAX_INTERVAL) {
                        return new UserException(sprintf(
                            'OneDrive API error: Too many requests. Retry-After (%d ' .
                                'seconds) exceeded maximum retry interval (%d seconds)',
                            $retryAfter,
                            Api::MAX_INTERVAL
                        ), 429, $e);
                    }
                }
            }

            return new UserException('OneDrive API error: Too many requests.', 429, $e);
        } elseif ($e->getCode() === 403) {
            if (preg_match_all('/`([^`]+)`/', $e->getMessage(), $matches)) {
                $message = sprintf('%s resulted in a %s', $matches[1][0], $matches[1][1]);
                return new UserException('OneDrive API error: AccessDenied - ' . $message, 403, $e);
            }
            return new UserException('OneDrive API error: AccessDenied', 403, $e);
        }

        return $e;
    }

    public static function getErrorFromRequestException(RequestException $exception): ?string
    {
        try {
            /** @var MessageInterface $response */
            $response = $exception->getResponse();
            $stream = $response->getBody();
            $stream->rewind();
            $body = JsonHelper::decode($stream->getContents());
            $error = $body['error'];
            return sprintf('%s: %s', ucfirst($error['code']), $error['message']);
        } catch (\Throwable $jsonException) {
            return null;
        }
    }

    public static function replaceParamsInUri(string $uri, array $params): string
    {
        // Replace params
        foreach ($params as $key => $value) {
            $uri = str_replace("{{$key}}", urlencode((string) $value), $uri);
        }
        return $uri;
    }

    public static function convertPathToApiFormat(string $path): string
    {
        // API use special path format:
        // eg. root path: /me/drive/root/children ... output of this fn is "/"
        // eg. absolute path /me/drive/root:/path/to/folder:/children ... output of this fn is ":/path/to/folder:/"
        $path = trim($path, '/');
        $path = $path ? (":/{$path}:/") : '/';
        return $path;
    }

    public static function toAscii(string $str): string
    {
        $str = Normalizer::normalize($str, Normalizer::FORM_D);
        $str = (string) preg_replace('~\pM~u', '', $str);
        $str = (string) preg_replace('~[^a-zA-Z0-9\-.]+~', '_', $str);
        $str = trim($str, '_');
        return $str;
    }

    public static function truncate(string $value, int $maxLength = 20): string
    {
        return mb_strlen($value) > $maxLength ? mb_substr($value, 0, $maxLength) . '...' : $value;
    }

    public static function formatIterable(iterable $values, int $maxItems = 20, int $strLength = 30): string
    {
        $out = '';
        $i = 0;
        foreach ($values as $value) {
            // Append '...' if there are more items
            if ($i >= $maxItems) {
                $out .= ', ...';
                break;
            }

            // Truncate item length
            $value = self::truncate($value, $strLength);

            $out .= $i === 0 ? "\"{$value}\"" : ", \"{$value}\"";
            $i++;
        }

        if ($i === 0) {
            return '(empty)';
        }

        return $out;
    }

    /**
     * Convert Excel column name to it int position.
     * See https://stackoverflow.com/questions/848147
     * Eg. A => 1, B => 2, AA => 27, ...
     */
    public static function columnStrToInt(string $columnName): int
    {
        if ($columnName === '') {
            throw new InvalidArgumentException('Column name cannot be empty.');
        }

        $columnName = strtoupper($columnName);
        $columnNumber = 0;
        $pow = 1;
        foreach (array_reverse(str_split($columnName)) as $letter) {
            if (!preg_match('~^[A-Z]$~', $letter)) {
                throw new InvalidArgumentException(sprintf('Unexpected letter, expected A-Z, given: "%s"', $letter));
            }
            $columnNumber += (ord($letter) - 65 + 1) * $pow;
            $pow *= 26;
        }

        return $columnNumber;
    }

    /**
     * Convert column position to it Excel column name
     * See https://stackoverflow.com/questions/181596
     * Eg. 1 => A, 2 => B, 26 => AA
     */
    public static function columnIntToStr(int $columnNumber): string
    {
        if ($columnNumber <= 0) {
            throw new InvalidArgumentException('Column must be greater than zero.');
        }

        $dividend = $columnNumber;
        $columnName = '';
        while ($dividend > 0) {
            $modulo = ($dividend - 1) % 26;
            $columnName = chr(65 + $modulo) . $columnName;
            $dividend = (int) (($dividend - $modulo) / 26);
        }

        return $columnName;
    }

    /**
     * Escape Excel expressions with "'", apostrophe, char code 39.
     * Expression starts with "=".
     * Example: "=foo-bar" is converted to "'=foo-bar"
     */
    public static function escapeExcelExpressions(array &$values): void
    {
        array_walk_recursive($values, function (&$value): void {
            // Escape expression, eg. "=foo-bar" with "'", eg. "'=foo-bar"
            if (is_string($value) && isset($value[0]) && $value[0] === '=') {
                $value = "'" . $value;
            }
        });
    }
}



================================================
FILE: src/Api/InsertRowsManager.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api;

use Iterator;
use NoRewindIterator;
use LimitIterator;
use PHPUnit\TextUI\Help;
use Psr\Log\LoggerInterface;
use Keboola\OneDriveWriter\Sheet;
use Keboola\OneDriveWriter\Api\Model\TableHeader;

class InsertRowsManager
{
    private LoggerInterface $logger;
    private Api $api;

    public function __construct(LoggerInterface $logger, Api $api)
    {
        $this->logger = $logger;
        $this->api = $api;
    }

    public function insert(Sheet $sheet, bool $append, Iterator $rows, int $batchSize): void
    {
        // Clear
        if (!$append && !$sheet->isNew()) {
            $this->api->clearSheet($sheet);
        }

        // Determine offset
        $range = !$sheet->isNew() && $append ?
            $this->api->getSheetRange($sheet) : null;
        $orgHeader = $range && !$range->isEmpty() ?
            $this->api->getSheetHeader($sheet) : null;

        if ($range && !$range->isEmpty()) {
            $startCol = Helpers::columnStrToInt($range->getStartColumn());
            $startRow = $range->getLastRowNumber() + 1;
        } else {
            $startCol = 1;
            $startRow = 1;
        }

        // Parse header
        $header = $rows->current();
        $headerColumns = TableHeader::parseColumns($header);
        $endCol = $startCol + count($headerColumns) - 1;

        // Check header
        if ($orgHeader && $orgHeader->getColumns() !== $headerColumns) {
            $this->logger->warning(sprintf(
                'Headers mismatch. Ignored new header: %s',
                Helpers::formatIterable($headerColumns)
            ));
        }

        // Insert in parts
        $iterator = new NoRewindIterator($rows);

        // Skip header if header present in target file
        if ($orgHeader && !$orgHeader->isEmpty()) {
            $iterator->next();
        }

        do {
            // use_keys = false, important!
            $values = iterator_to_array(new LimitIterator($iterator, 0, $batchSize), false);
            if (empty($values)) {
                break;
            }

            // escape
            Helpers::escapeExcelExpressions($values);

            $endRow = $startRow + count($values) - 1;
            $endpoint = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}';
            $uri = $endpoint . '/range(address=\'{startCol}{startRow}:{endCol}{endRow}\')';

            $this->api->patch(
                $uri,
                [
                    'driveId' => $sheet->getDriveId(),
                    'fileId' => $sheet->getFileId(),
                    'worksheetId' => $sheet->getId(),
                    'startCol' => Helpers::columnIntToStr($startCol),
                    'startRow' => $startRow,
                    'endCol' => Helpers::columnIntToStr($endCol),
                    'endRow' => $endRow,
                ],
                ['values' => $values]
            );

            $this->logger->info(sprintf('Inserted %s rows.', count($values)));

            $startRow = $endRow + 1;
        } while (true);
    }
}



================================================
FILE: src/Api/WorkbooksFinder.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api;

use GuzzleHttp\Exception\RequestException;
use Keboola\OneDriveWriter\Api\Model\File;
use Keboola\OneDriveWriter\Exception\BadRequestException;
use Keboola\OneDriveWriter\Exception\FileInDriveNotFoundException;
use Keboola\OneDriveWriter\Exception\InvalidFileTypeException;
use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use Keboola\OneDriveWriter\Exception\ShareLinkException;
use Keboola\OneDriveWriter\Exception\UnexpectedValueException;
use Keboola\OneDriveWriter\Exception\UserException;
use Psr\Log\LoggerInterface;

class WorkbooksFinder
{
    public const ALLOWED_MIME_TYPES = [
        # Only XLSX files can by accessed through API
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    ];

    private Api $api;

    private LoggerInterface $logger;

    public function __construct(Api $api, LoggerInterface $logger)
    {
        $this->api = $api;
        $this->logger = $logger;
    }

    public function search(string $search): File
    {
        switch (true) {
            // Drive path, eg. "/path/to/file.xlsx"
            case Helpers::isFilePath($search):
                $this->log('Searching for "%s" in personal OneDrive.', $search);
                return $this->searchByPathInMeDrive($search);

            // Site path, eg. "drive://1234driveId6789/path/to/file.xlsx"
            case Helpers::isDriveFilePath($search):
                [$driveId, $path] = Helpers::explodeDriveFilePath($search);
                $this->log(
                    'Searching for "%s" in drive "%s".',
                    $path,
                    Helpers::truncate($driveId, 15)
                );
                return $this->searchByPathInDrive('/drives/' . urlencode($driveId), $path, []);

            // Site path, eg. "site://Excel Sheets/path/to/file.xlsx"
            case Helpers::isSiteFilePath($search):
                [$siteName, $path] = Helpers::explodeSiteFilePath($search);
                $this->log('Searching for "%s" in site "%s".', $path, $siteName);
                return $this->searchByPathInSite($siteName, $path);

            // Https url, eg: "https://keboolads.sharepoint.com/..."
            case Helpers::isHttpsUrl($search):
                $this->log('Searching by link "%s".', Helpers::truncate($search, 20));
                return $this->searchByUrl($search);

            // Search for file by text in all locations
            default:
                throw new UnexpectedValueException(sprintf('Unexpected path format "%s".', $search));
        }
    }

    private function searchByPathInMeDrive(string $path): File
    {
        return $this->searchByPathInDrive('/me/drive', $path, ['my']);
    }

    private function searchByPathInSite(string $siteName, string $path): File
    {
        $site = $this->api->getSite($siteName);
        $prefix = '/sites/' . urlencode($site->getId()) .  '/drive';
        return $this->searchByPathInDrive($prefix, $path, ['sites', $siteName]);
    }

    private function searchByPathInDrive(string $drivePrefix, string $path, array $pathPrefix): File
    {
        $graphPath = Helpers::convertPathToApiFormat($path);
        $endpoint = "{$drivePrefix}/root{$graphPath}";
        $url = "{$endpoint}?\$select=id,name,parentReference,file";
        try {
            $body = $this->api->get($url)->getBody();
        } catch (ResourceNotFoundException $e) {
            $msg = 'File "%s" not found in "%s".';
            throw new FileInDriveNotFoundException(sprintf($msg, $path, $drivePrefix), $endpoint, 0, $e);
        }

        // Check mime type
        self::checkFileMimeType($body);

        // Convert to object
        return File::from($body, $pathPrefix);
    }

    private function searchByUrl(string $url): File
    {
        // See: https://docs.microsoft.com/en-ca/onedrive/developer/rest-api/api/shares_get#encoding-sharing-urls
        $encode = base64_encode($url);
        $sharingUrl = 'u!' . str_replace('+', '-', str_replace('/', '_', rtrim($encode, '=')));

        // Get URL info and extract driveId, fileId
        try {
            $body = $this->api->get(sprintf('/shares/%s/driveItem', $sharingUrl))->getBody();
        } catch (RequestException|UserException $e) {
            /** @var RequestException $exception */
            $exception = $e instanceof UserException ? $e->getPrevious() : $e;
            $error = Helpers::getErrorFromRequestException($exception);
            switch (true) {
                // Not exists
                case $error && strpos($error, 'AccessDenied: The sharing link no longer exists') === 0:
                    throw new ShareLinkException(sprintf(
                        'The sharing link "%s..." not exists, or you do not have permission to access it.',
                        substr($url, 0, 32)
                    ), 0, $e);

                // Access denied
                case $error && strpos($error, 'AccessDenied:') === 0:
                    throw new ShareLinkException(sprintf(
                        'The sharing link "%s..." not exists, or you do not have permission to access it.',
                        substr($url, 0, 32)
                    ), 0, $e);

                // Invalid link
                case $error === 'InvalidRequest: The sharing token is invalid.':
                case $error === 'InvalidRequest: The site in the encoded share URI is invalid.':
                    throw new ShareLinkException(sprintf(
                        'The sharing link "%s..." is invalid.',
                        substr($url, 0, 32)
                    ), 0, $e);

                default:
                    throw $e;
            }
        } catch (BadRequestException $e) {
            throw new ShareLinkException(sprintf(
                'The sharing link "%s..." is invalid.',
                substr($url, 0, 32)
            ), 0, $e);
        }

        // Check mime type
        self::checkFileMimeType($body);

        // Convert to object
        return  File::from($body, []);
    }

    /**
     * @param mixed ...$args args for sprintf
     */
    private function log(...$args): void
    {
        $this->logger->info(sprintf(...$args));
    }

    private static function checkFileMimeType(array $body): void
    {
        $mimeType = $body['file']['mimeType'] ?? 'undefined-mime-type';
        if (!in_array($mimeType, self::ALLOWED_MIME_TYPES, true)) {
            throw new InvalidFileTypeException(sprintf(
                'File is not in the "XLSX" Excel format. Mime type: "%s"',
                $mimeType
            ));
        }
    }
}



================================================
FILE: src/Api/Batch/BatchRequest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Batch;

use Iterator;
use Keboola\OneDriveWriter\Api\Helpers;
use NoRewindIterator;
use ArrayIterator;
use LimitIterator;
use InvalidArgumentException;
use Keboola\OneDriveWriter\Api\Api;
use Keboola\OneDriveWriter\Exception\BatchRequestException;
use Microsoft\Graph\Http\GraphResponse;

/**
 * Microsoft Graph API allows combine requests to batch, and run them as single request.
 * See: https://docs.microsoft.com/en-us/graph/json-batching
 */
class BatchRequest
{
    // https://docs.microsoft.com/en-us/graph/known-issues#limit-on-batch-size
    public const MAX_REQUESTS_PER_BATCH = 20;

    private Api $api;

    private ?int $limit;

    private int $idCounter = 1;

    private int $processedCount;

    /** @var array|Request[] */
    private array $requests = [];

    public function __construct(Api $api, ?int $limit = null)
    {
        $this->api = $api;
        $this->limit = $limit;
    }

    public function addRequest(
        string $uriTemplate,
        array $uriArgs = [],
        ?callable $responseMapper = null,
        string $method = 'GET'
    ): self {
        $id = (string) $this->idCounter++;
        $this->requests[$id] = new Request($id, $uriTemplate, $uriArgs, $responseMapper, $method);
        return $this;
    }

    public function execute(): Iterator
    {
        // Empty batch request cannot be executed, ... if empty => empty iterator is returned
        if ($this->requests) {
            $this->processedCount = 0;
            $responses = $this->runBatchRequest();
            foreach ($responses as $response) {
                do {
                    try {
                        yield from $this->processBatchResponse($response);
                    } catch (BatchRequestException $e) {
                        throw Helpers::processRequestException($e);
                    }
                    $response = $this->getNextPage($response);
                } while ($response !== null);
            }
        }
    }

    private function getNextPage(GraphResponse $response): ?GraphResponse
    {
        // See: https://docs.microsoft.com/en-us/graph/paging
        /** @var string|null $nextLink */
        $nextLink = $response->getNextLink();
        if ($nextLink === null) {
            return null;
        }

        return $this->api->get($nextLink);
    }

    /**
     * @return GraphResponse[]
     */
    private function runBatchRequest(): array
    {
        /** @var GraphResponse[] $responses */
        $responses = [];

        $all = new NoRewindIterator(new ArrayIterator($this->requests));
        while ($all->valid()) {
            $batch = new LimitIterator($all, 0, self::MAX_REQUESTS_PER_BATCH);
            $requests = array_map(fn(Request $request) => $request->toArray(), array_values(iterator_to_array($batch)));
            $responses[] = $this->api->post('/$batch', [], [ 'requests' => $requests]);
        }

        return $responses;
    }

    private function processBatchResponse(GraphResponse $batchResponse): Iterator
    {
        $responses = $batchResponse->getBody()['responses'];
        assert(is_array($responses));

        foreach ($responses as $response) {
            $id = (string) $response['id'];
            $status = (int) $response['status'];
            $body = $response['body'] ?? [];
            $request = $this->getRequestById($id);
            yield from $this->processResponse($request, $status, $body);
        }
    }

    private function processResponse(Request $request, int $status, array $body): Iterator
    {
        // Request from batch failed, status != 2xx
        if ($status < 200 || $status >= 300) {
            throw new BatchRequestException(sprintf(
                'Unexpected status "%d" for request "%s": %s, %s',
                $status,
                $request->getUri(),
                $body['error']['code'] ?? '',
                $body['error']['message'] ?? '',
            ), $status, null, $body['error']['code'] ?? null);
        }

        // Map response body (eg. to files)
        $mapper = $request->getResponseMapper();
        $values = $mapper ? $mapper($body) : [$body];
        assert($values instanceof Iterator);
        foreach ($values as $key => $value) {
            // End if over limit (eg. last page has 10 items, but we need only 4)
            if ($this->limit && $this->processedCount >= $this->limit) {
                break;
            }

            // It is needed to specify key, otherwise it would be overwritten
            // ... because method is called multiple times, and without specifications are keys: 0, 1, 2 ...
            yield $this->processedCount => $value;

            // Increase processed
            $this->processedCount++;
        }
    }

    private function getRequestById(string $id): Request
    {
        if (!isset($this->requests[$id])) {
            throw new InvalidArgumentException(sprintf('Request with id "%s" not found.', $id));
        }

        return $this->requests[$id];
    }
}



================================================
FILE: src/Api/Batch/Request.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Batch;

use Keboola\OneDriveWriter\Api\Helpers;

class Request
{
    private string $id;

    private string $uri;

    private string $method;

    /** @var callable|null */
    private $responseMapper;

    public function __construct(
        string $id,
        string $uri,
        array $uriArgs,
        ?callable $responseMapper = null,
        string $method = 'GET'
    ) {
        $this->id = $id;
        $this->uri = Helpers::replaceParamsInUri($uri, $uriArgs);
        $this->responseMapper = $responseMapper;
        $this->method = $method;
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function getUri(): string
    {
        return $this->uri;
    }

    public function getMethod(): string
    {
        return $this->method;
    }

    public function getResponseMapper(): ?callable
    {
        return $this->responseMapper;
    }

    public function toArray(): array
    {
        return [
            'id' => $this->id,
            'method' => $this->method,
            'url' => $this->uri,
        ];
    }
}



================================================
FILE: src/Api/Fixtures/empty.xlsx
================================================
[Binary file]


================================================
FILE: src/Api/Model/Drive.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Model;

use InvalidArgumentException;

class Drive
{
    private string $id;

    private array $path;

    public static function from(array $data, Site $site): self
    {
        $path = ['sites', $site->getName(), $data['name']];
        return new self($data['id'], $path);
    }

    public function __construct(string $id, array $path)
    {
        if (strlen($id) === 0) {
            throw new InvalidArgumentException('Drive id cannot be empty.');
        }
        $this->id = $id;
        $this->path = $path;
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function getPath(): array
    {
        return $this->path;
    }
}



================================================
FILE: src/Api/Model/File.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Model;

use InvalidArgumentException;

class File implements \JsonSerializable
{
    private string $fileId;

    private string $driveId;

    private string $name;

    private array $path;

    public static function from(array $data, array $path = []): self
    {
        $fileId = $data['id'];
        $driveId = $data['parentReference']['driveId'];

        // In response can be defined folder path, eg. /drive/root:/__wx-onedrive-test-folder/valid
        $filePath = $data['parentReference']['path'] ?? null;
        if ($filePath && strpos($filePath, 'root:/') !== false) {
            $parts = explode('root:/', $filePath, 2);
            $path = array_merge($path, explode('/', $parts[1]));
        }

        return new self($fileId, $driveId, $data['name'], $path);
    }

    public function __construct(string $fileId, string $driveId, string $name, array $pathParts)
    {
        if (strlen($fileId) === 0) {
            throw new InvalidArgumentException('File id cannot be empty.');
        }
        if (strlen($driveId) === 0) {
            throw new InvalidArgumentException('Drive id cannot be empty.');
        }
        if (strlen($name) === 0) {
            throw new InvalidArgumentException('File name cannot be empty.');
        }

        $this->fileId = $fileId;
        $this->driveId = $driveId;
        $this->name = $name;
        $this->path = $pathParts;
    }

    public function getFileId(): string
    {
        return $this->fileId;
    }

    public function getDriveId(): string
    {
        return $this->driveId;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getPath(): array
    {
        return $this->path;
    }

    public function getPathname(): array
    {
        $out = $this->getPath();
        $out[] = $this->getName();
        return $out;
    }

    public function jsonSerialize(): array
    {
        return [
            'driveId' => $this->driveId,
            'fileId' => $this->fileId,
            'name' => $this->name,
            'path' => $this->path ? implode('/', $this->path) : null,
        ];
    }
}



================================================
FILE: src/Api/Model/Site.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Model;

use InvalidArgumentException;

class Site
{
    private string $id;

    private string $name;

    public static function from(array $data): self
    {
        return new self($data['id'], $data['name']);
    }

    public function __construct(string $id, string $name)
    {
        if (strlen($id) === 0) {
            throw new InvalidArgumentException('Site id cannot be empty.');
        }
        if (strlen($name) === 0) {
            throw new InvalidArgumentException('Site name cannot be empty.');
        }
        $this->id = $id;
        $this->name = $name;
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function getName(): string
    {
        return $this->name;
    }
}



================================================
FILE: src/Api/Model/TableHeader.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Model;

use Keboola\OneDriveWriter\Api\Helpers;

class TableHeader extends TableRange implements \JsonSerializable
{
    private array $columns;

    public static function from(string $address, ?array $cells = null): self
    {
        [$start, $end, $firstRowNumber] = self::parseStartEnd($address);

        // For empty sheet API returns empty first cell, ignore it
        $cells = $cells ?? [];
        $empty = count($cells) <= 1 && ($cells[0] ?? '') === '';
        $columns = self::parseColumns($empty ? [] : $cells);

        // Intentionally 2x firstRowNumber, because header range, not whole table
        return new self($start, $end, $firstRowNumber, $firstRowNumber, $columns);
    }

    public static function parseColumns(array $columns): array
    {
        $output = [];
        foreach ($columns as $index => $colName) {
            // Normalize column name, fix empty value
            $colName = Helpers::toAscii((string) $colName);
            $colName = empty($colName) ? 'column-' . ($index + 1) : $colName;

            // Prevent duplicates
            $i = 1;
            $orgColName = $colName;
            while (in_array($colName, $output, true)) {
                $colName = $orgColName . '-' . $i++;
            }

            // Store
            $output[] = $colName;
        }
        return $output;
    }

    public function __construct(string $start, string $end, int $firstRowNumber, int $lastRowNumber, array $columns)
    {
        parent::__construct($start, $end, $firstRowNumber, $lastRowNumber);
        $this->columns = $columns;
    }

    public function getColumns(): array
    {
        return $this->columns;
    }

    public function isEmpty(): bool
    {
        return empty($this->columns);
    }

    public function jsonSerialize(): array
    {
        return $this->columns;
    }
}



================================================
FILE: src/Api/Model/TableRange.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Model;

use InvalidArgumentException;

class TableRange
{
    private string $startColumn;

    private string $endColumn;

    private int $firstRowNumber;

    private int $lastRowNumber;

    public static function from(string $address): self
    {
        [$start, $end, $firstRowNumber, $lastRowNumber] = self::parseStartEnd($address);
        return new self($start, $end, $firstRowNumber, $lastRowNumber);
    }

    public static function parseStartEnd(string $address): array
    {
        // Eg. address = Sheet1!B123:I456 => start=B, end=I, rows=123-456
        // ... or eg. A1 if empty file
        preg_match('~!?([A-Z]+)([0-9]+)?(?::([A-Z]+)([0-9]+)?)?$~', $address, $m);
        if (empty($m)) {
            throw new InvalidArgumentException(sprintf('Unexpected input: "%s"', $address));
        }

        $start = $m[1];
        $firstRowNumber = (int) $m[2];
        $end = $m[3] ?? $start;
        $lastRowNumber = (int) ($m[4] ?? $m[2]);

        return [$start, $end, $firstRowNumber, $lastRowNumber];
    }

    public function __construct(string $start, string $end, int $firstRowNumber, int $lastRowNumber)
    {
        $this->startColumn = $start;
        $this->endColumn = $end;
        $this->firstRowNumber = $firstRowNumber;
        $this->lastRowNumber = $lastRowNumber;
    }

    public function getStartColumn(): string
    {
        return $this->startColumn;
    }

    public function getStartCell(): string
    {
        return $this->startColumn . $this->firstRowNumber;
    }

    public function getEndColumn(): string
    {
        return $this->endColumn;
    }

    public function getEndCell(): string
    {
        return $this->endColumn . $this->lastRowNumber;
    }

    public function getAddress(): string
    {
        return $this->getStartCell() . ':' . $this->getEndCell();
    }

    public function getFirstRowNumber(): int
    {
        return $this->firstRowNumber;
    }

    public function getLastRowNumber(): int
    {
        return $this->lastRowNumber;
    }

    public function isEmpty(): bool
    {
        return
            $this->startColumn === $this->endColumn &&
            $this->firstRowNumber === $this->lastRowNumber;
    }
}



================================================
FILE: src/Api/Model/WorkbookSession.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Model;

class WorkbookSession
{
    private string $driveId;

    private string $fileId;

    private string $sessionId;

    public function __construct(string $driveId, string $fileId, string $sessionId)
    {
        $this->driveId = $driveId;
        $this->fileId = $fileId;
        $this->sessionId = $sessionId;
    }

    public function getDriveId(): string
    {
        return $this->driveId;
    }

    public function getFileId(): string
    {
        return $this->fileId;
    }

    public function getSessionId(): string
    {
        return $this->sessionId;
    }
}



================================================
FILE: src/Api/Model/Worksheet.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Api\Model;

use InvalidArgumentException;

class Worksheet implements \JsonSerializable
{
    private string $driveId;

    private string $fileId;

    private string $worksheetId;

    private int $position; // 0,1,2 ...

    private string $name;

    private bool $visible;

    private ?TableRange $header;

    public static function from(array $data, string $driveId, string $fileId): self
    {
        $worksheetId = $data['id'];
        $position = $data['position'];
        $name = $data['name'];
        $visible = strtolower($data['visibility']) === 'visible';
        return new self($driveId, $fileId, $worksheetId, $position, $name, $visible);
    }

    public function __construct(
        string $driveId,
        string $fileId,
        string $worksheetId,
        int $position,
        string $name,
        bool $visible,
        ?TableRange $header = null
    ) {
        if (strlen($fileId) === 0) {
            throw new InvalidArgumentException('File id cannot be empty.');
        }
        if (strlen($driveId) === 0) {
            throw new InvalidArgumentException('Drive id cannot be empty.');
        }
        if (strlen($worksheetId) === 0) {
            throw new InvalidArgumentException('Worksheet id cannot be empty.');
        }
        if (strlen($name) === 0) {
            throw new InvalidArgumentException('Worksheet name cannot be empty.');
        }

        $this->driveId = $driveId;
        $this->fileId = $fileId;
        $this->worksheetId = $worksheetId;
        $this->position = $position;
        $this->name = $name;
        $this->visible = $visible;
        $this->header = $header;
    }

    public function getDriveId(): string
    {
        return $this->driveId;
    }

    public function getFileId(): string
    {
        return $this->fileId;
    }

    public function getWorksheetId(): string
    {
        return $this->worksheetId;
    }

    public function getPosition(): int
    {
        return $this->position;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getTitle(): string
    {
        return "{$this->name}" . ($this->visible ? '' : ' (hidden)');
    }

    public function getHeader(): ?TableRange
    {
        return $this->header;
    }

    public function setHeader(TableRange $header): self
    {
        $this->header = $header;
        return $this;
    }

    public function getVisible(): bool
    {
        return $this->visible;
    }

    public function toArray(): array
    {
        return [
            'position' => $this->position,
            'name' => $this->name,
            'title' => $this->getTitle(),
            'driveId' => $this->driveId,
            'fileId' => $this->fileId,
            'worksheetId' => $this->worksheetId,
            'visible' => $this->visible,
            'header' => $this->header,
        ];
    }

    public function jsonSerialize(): array
    {
        return $this->toArray();
    }
}



================================================
FILE: src/Auth/RefreshTokenProvider.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Auth;

use Keboola\OneDriveWriter\Exception\AccessTokenRefreshException;
use League\OAuth2\Client\Provider\Exception\IdentityProviderException;
use League\OAuth2\Client\Provider\GenericProvider;
use League\OAuth2\Client\Token\AccessTokenInterface;
use LogicException;
use Psr\Log\LoggerInterface;

class RefreshTokenProvider implements TokenProvider
{
    private const AUTHORITY_URL = 'https://login.microsoftonline.com/common';
    private const AUTHORIZE_ENDPOINT = '/oauth2/v2.0/authorize';
    private const TOKEN_ENDPOINT = '/oauth2/v2.0/token';
    private const SCOPES = ['offline_access', 'User.Read', 'Files.ReadWrite.All', 'Sites.ReadWrite.All'];

    private string $appId;

    private string $appSecret;

    private TokenDataManager $dataManager;

    private LoggerInterface $logger;

    private string $authorityUrl;

    public function __construct(
        string $appId,
        string $appSecret,
        ?string $authorityUrl,
        TokenDataManager $dataManager,
        LoggerInterface $logger
    ) {
        $this->appId = $appId;
        $this->appSecret = $appSecret;
        $this->authorityUrl = $authorityUrl ?? self::AUTHORITY_URL;
        $this->dataManager = $dataManager;
        $this->logger = $logger;
    }

    public function get(): AccessTokenInterface
    {
        $provider = $this->createOAuthProvider($this->appId, $this->appSecret);
        $tokens = $this->dataManager->load();

        // It is needed to always refresh token, because original token expires after 1 hour
        $newToken = null;

        // Try token from stored state, and from the configuration.
        if (!$tokens->valid()) {
            throw new AccessTokenRefreshException(
                'Missing token in configuration or state file.'
            );
        } else {
            while ($tokens->valid()) {
                try {
                    $newToken = $provider->getAccessToken(
                        'refresh_token',
                        ['refresh_token' => $tokens->current()->getRefreshToken()]
                    );
                    break;
                } catch (IdentityProviderException $e) {
                    $tokens->next();
                    /** @var array<string, string> $responseBody */
                    $responseBody = $e->getResponseBody();
                    if ($tokens->valid()) {
                        $this->logger->info(sprintf(
                            'Microsoft OAuth API token refresh failed (%s: %s), trying next token.',
                            $e->getMessage(),
                            $responseBody['error_description'] ?? 'No error description'
                        ));
                    } else {
                        throw new AccessTokenRefreshException(
                            sprintf(
                                'Microsoft OAuth API token refresh failed (%s: %s). Please reset authorization in ' .
                                'the extractor configuration.',
                                $e->getMessage(),
                                $responseBody['error_description'] ?? 'No error description'
                            )
                        );
                    }
                }
            }
        }

        if ($newToken === null) {
            throw new LogicException('Token is null.');
        }

        $this->dataManager->store($newToken);
        return $newToken;
    }

    private function createOAuthProvider(string $appId, string $appSecret): GenericProvider
    {
        return new GenericProvider([
            'clientId' => $appId,
            'clientSecret' => $appSecret,
            'urlAuthorize' => $this->authorityUrl . self::AUTHORIZE_ENDPOINT,
            'urlAccessToken' => $this->authorityUrl . self::TOKEN_ENDPOINT,
            'urlResourceOwnerDetails' => '',
            'scopes' => implode(' ', self::SCOPES),
        ]);
    }
}



================================================
FILE: src/Auth/TokenDataManager.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Auth;

use ArrayObject;
use Generator;
use Keboola\Component\JsonHelper;
use Keboola\OneDriveWriter\Exception\AccessTokenInitException;
use League\OAuth2\Client\Token\AccessToken;
use League\OAuth2\Client\Token\AccessTokenInterface;

class TokenDataManager
{
    public const STATE_AUTH_DATA_KEY = '#refreshed_auth_data'; // # -> must be encrypted!

    private array $configAuthData;

    private ArrayObject $state;

    public function __construct(array $configAuthData, ArrayObject $state)
    {
        $this->configAuthData = $configAuthData;
        $this->state = $state;

        // Check required keys
        $missingKeys = array_diff(['access_token', 'refresh_token'], array_keys($this->configAuthData));
        if ($missingKeys) {
            throw new AccessTokenInitException(
                sprintf('Missing key "%s" in OAuth data array.', implode('", "', $missingKeys))
            );
        }
    }

    public function load(): Generator
    {
        // Load tokens from state.json
        $authDataJson = $this->state[self::STATE_AUTH_DATA_KEY] ?? null;
        if (is_string($authDataJson)) {
            yield new AccessToken(JsonHelper::decode($authDataJson));
        }

        // Or use default from the configuration
        yield new AccessToken($this->configAuthData);
    }

    public function store(AccessTokenInterface $newToken): void
    {
        // See AccessToken::jsonSerialize
        $this->state[self::STATE_AUTH_DATA_KEY] = json_encode($newToken);
    }
}



================================================
FILE: src/Auth/TokenProvider.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Auth;

use League\OAuth2\Client\Token\AccessTokenInterface;

interface TokenProvider
{
    public function get(): AccessTokenInterface;
}



================================================
FILE: src/Auth/TokenProviderFactory.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Auth;

use ArrayObject;
use Keboola\OneDriveWriter\Configuration\Config;
use Psr\Log\LoggerInterface;

class TokenProviderFactory
{
    private Config $config;

    private ArrayObject $stateObject;

    private LoggerInterface $logger;

    public function __construct(Config $config, ArrayObject $stateObject, LoggerInterface $logger)
    {
        $this->config = $config;
        $this->stateObject = $stateObject;
        $this->logger = $logger;
    }

    public function create(): TokenProvider
    {
        // OAuth Refresh Token login
        $tokenDataManager = new TokenDataManager($this->config->getOAuthApiData(), $this->stateObject);
        return new RefreshTokenProvider(
            $this->config->getOAuthApiAppKey(),
            $this->config->getOAuthApiAppSecret(),
            $this->config->getImageParameters()['oneDriveAuthorityUrl'] ?? null,
            $tokenDataManager,
            $this->logger
        );
    }
}



================================================
FILE: src/Configuration/Config.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Configuration;

use InvalidArgumentException;
use Keboola\Component\Config\BaseConfig;
use Keboola\Component\JsonHelper;
use Keboola\OneDriveWriter\Exception\InvalidAuthDataException;
use Keboola\OneDriveWriter\Exception\InvalidConfigException;
use Symfony\Component\Config\Definition\ConfigurationInterface;

class Config extends BaseConfig
{
    public function __construct(array $config, ?ConfigurationInterface $configDefinition = null)
    {
        parent::__construct($config, $configDefinition);
        $this->customValidation();
    }

    public function getAppend(): bool
    {
        return $this->getValue(['parameters', 'append']);
    }

    public function getBatchSize(): int
    {
        return $this->getValue(['parameters', 'batchSize']);
    }

    public function hasDriveId(): bool
    {
        return $this->hasValue(['parameters', 'workbook', 'driveId']);
    }

    public function getDriveId(): string
    {
        return $this->getValue(['parameters', 'workbook', 'driveId']);
    }

    public function hasFileId(): bool
    {
        return $this->hasValue(['parameters', 'workbook', 'fileId']);
    }

    public function getFileId(): string
    {
        return $this->getValue(['parameters', 'workbook', 'fileId']);
    }

    public function hasPath(): bool
    {
        return $this->hasValue(['parameters', 'workbook', 'path']);
    }

    public function getPath(): string
    {
        return $this->getValue(['parameters', 'workbook', 'path']);
    }

    public function hasWorksheetId(): bool
    {
        return $this->hasValue(['parameters', 'worksheet', 'id']);
    }

    public function getWorksheetId(): string
    {
        return $this->getValue(['parameters', 'worksheet', 'id']);
    }

    public function hasWorksheetName(): bool
    {
        return $this->hasValue(['parameters', 'worksheet', 'name']);
    }


    public function getWorksheetName(): string
    {
        return $this->getValue(['parameters', 'worksheet', 'name']);
    }

    public function hasWorksheetPosition(): bool
    {
        return $this->hasValue(['parameters', 'worksheet', 'position']);
    }


    public function getWorksheetPosition(): int
    {
        return $this->getValue(['parameters', 'worksheet', 'position']);
    }

    public function getOAuthApiData(): array
    {
        $data = parent::getOAuthApiData();

        if (empty($data)) {
            return [];
        }

        if (!is_string($data)) {
            throw new InvalidAuthDataException('Value of "authorization.oauth_api.credentials.#data".');
        }

        try {
            return JsonHelper::decode($data);
        } catch (\Throwable $e) {
            throw new InvalidAuthDataException(sprintf(
                'Value of "authorization.oauth_api.credentials.#data" must be valid JSON, sample: "%s"',
                substr($data, 0, 16)
            ));
        }
    }

    private function hasValue(array $keys): bool
    {
        try {
            $this->getValue($keys);
            return true;
        } catch (InvalidArgumentException $e) {
            return false;
        }
    }

    private function customValidation(): void
    {
        // Missing OAuth data
        if (!$this->getOAuthApiAppKey() || !$this->getOAuthApiAppSecret() || !$this->getOAuthApiData()) {
            throw new InvalidConfigException(
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".'
            );
        }
    }
}



================================================
FILE: src/Configuration/ConfigDefinition.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Configuration;

use Keboola\Component\Config\BaseConfigDefinition;
use Keboola\OneDriveWriter\Configuration\Parts\WorkbookDefinition;
use Keboola\OneDriveWriter\Configuration\Parts\WorksheetDefinition;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class ConfigDefinition extends BaseConfigDefinition
{
    protected function getParametersDefinition(): ArrayNodeDefinition
    {
        $builder = new TreeBuilder('parameters');
        /** @var ArrayNodeDefinition $parametersNode */
        $parametersNode = $builder->getRootNode();

        // @formatter:off
        $parametersNode
            ->children()
                ->booleanNode('append')->defaultValue(false)->end()
                ->integerNode('batchSize')->defaultValue(500)->end()
                // Workbook is one XLSX file
                ->append(WorkbookDefinition::getDefinition())
                // In one workbook are multiple worksheets, specify one
                ->append(WorksheetDefinition::getDefinition())
            ->end();
        // @formatter:on

        return $parametersNode;
    }
}



================================================
FILE: src/Configuration/CreateWorkbookConfigDefinition.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Configuration;

use Keboola\Component\Config\BaseConfigDefinition;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class CreateWorkbookConfigDefinition extends BaseConfigDefinition
{
    protected function getParametersDefinition(): ArrayNodeDefinition
    {
        $builder = new TreeBuilder('parameters');
        /** @var ArrayNodeDefinition $parametersNode */
        $parametersNode = $builder->getRootNode();

        // @formatter:off
        $parametersNode
            ->children()
                ->arrayNode('workbook')
                    ->isRequired()
                    ->children()
                        // To create new workbook, must be specified by path
                        ->scalarNode('path')->isRequired()->cannotBeEmpty()->end()
                    ->end()
            ->end();
        // @formatter:on

        return $parametersNode;
    }
}



================================================
FILE: src/Configuration/CreateWorksheetConfigDefinition.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Configuration;

use Keboola\Component\Config\BaseConfigDefinition;
use Keboola\OneDriveWriter\Configuration\Parts\WorkbookDefinition;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class CreateWorksheetConfigDefinition extends BaseConfigDefinition
{
    protected function getParametersDefinition(): ArrayNodeDefinition
    {
        $builder = new TreeBuilder('parameters');
        /** @var ArrayNodeDefinition $parametersNode */
        $parametersNode = $builder->getRootNode();

        // @formatter:off
        $parametersNode
            ->children()
                // Workbook is one XLSX file
                ->append(WorkbookDefinition::getDefinition())
                // Worksheet is one sheet from workbook's sheets
                ->arrayNode('worksheet')
                    ->isRequired()
                    ->children()
                        // To create new worksheet, must be specified by name
                        ->scalarNode('name')->isRequired()->cannotBeEmpty()->end()
                    ->end()
            ->end();
        // @formatter:on

        return $parametersNode;
    }
}



================================================
FILE: src/Configuration/SyncActionConfigDefinition.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Configuration;

use Keboola\Component\Config\BaseConfigDefinition;
use Keboola\OneDriveWriter\Configuration\Parts\WorkbookDefinition;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class SyncActionConfigDefinition extends BaseConfigDefinition
{
    protected function getParametersDefinition(): ArrayNodeDefinition
    {
        $builder = new TreeBuilder('parameters');
        /** @var ArrayNodeDefinition $parametersNode */
        $parametersNode = $builder->getRootNode();

        // @formatter:off
        $parametersNode
            ->children()
                // Workbook is one XLSX file
                ->append(WorkbookDefinition::getDefinition())
            ->end();
        // @formatter:on

        return $parametersNode;
    }
}



================================================
FILE: src/Configuration/Parts/WorkbookDefinition.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Configuration\Parts;

use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class WorkbookDefinition
{
    public static function getDefinition(): ArrayNodeDefinition
    {
        $treeBuilder = new TreeBuilder('workbook');

        /** @var ArrayNodeDefinition $root */
        $root = $treeBuilder->getRootNode();

        // @formatter:off
        $root
            ->isRequired()
            ->children()
                // Workbook is specified by driveId, fileId
                ->scalarNode('driveId')->cannotBeEmpty()->end()
                ->scalarNode('fileId')->cannotBeEmpty()->end()
                // ... OR by search (path, download url, ...)
                ->scalarNode('path')->cannotBeEmpty()->end()
                // optional metadata can be always present, it is not used in code
                ->arrayNode('metadata')->ignoreExtraKeys(true)->end()
            ->end()
            // Not empty
            ->validate()
                ->ifTrue(function (array $workbook): bool {
                    return !isset($workbook['path']) && !isset($workbook['driveId']) && !isset($workbook['fileId']);
                })
                ->thenInvalid(
                    'In config must be present "workbook.path" OR ' .
                    '("workbook.driveId" and "workbook.fileId").'
                )
            ->end()
            // Must be present "workbook.search" OR ("workbook,driveId" and "workbook.fileId") - not both
            ->validate()
                ->ifTrue(function (array $workbook): bool {
                    return isset($workbook['path']) && (isset($workbook['driveId']) || isset($workbook['fileId']));
                })
                ->thenInvalid(
                    'In config is present "workbook.path", ' .
                    'therefore "workbook,driveId" and "workbook.fileId" are not expected.'
                )
            ->end()
            // If is one of driveId/fileId set, check both are set
            ->validate()
                ->ifTrue(function (array $workbook): bool {
                    return isset($workbook['driveId']) xor isset($workbook['fileId']);
                })
                ->thenInvalid(
                    'Both "workbook.driveId" and "workbook.fileId" must be configured.'
                )
            ->end();
        // @formatter:on

        return $root;
    }
}



================================================
FILE: src/Configuration/Parts/WorksheetDefinition.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Configuration\Parts;

use Keboola\OneDriveWriter\Exception\InvalidConfigException;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\Config\Definition\Builder\TreeBuilder;

class WorksheetDefinition
{
    public static function getDefinition(): ArrayNodeDefinition
    {
        $treeBuilder = new TreeBuilder('worksheet');

        /** @var ArrayNodeDefinition $root */
        $root = $treeBuilder->getRootNode();

        // @formatter:off
        $root
            ->isRequired()
            ->children()
                // Worksheet is specified by name (name can be set always, also with id or position)
                ->scalarNode('name')->cannotBeEmpty()->end()
                // ... or id
                ->scalarNode('id')->cannotBeEmpty()->end()
                // ... or position
                ->scalarNode('position')->cannotBeEmpty()->end()
                // optional metadata can be always present, it is not used in code
                ->arrayNode('metadata')->ignoreExtraKeys(true)->end()
            ->end()
            // Only one of id/position allowed
            ->validate()
                ->ifTrue(function (array $worksheet): bool {
                    $hasId = isset($worksheet['id']);
                    $hasPosition = array_key_exists('position', $worksheet); // position can be 0
                    return $hasId && $hasPosition;
                })
                ->thenInvalid('In config must be ONLY ONE OF "worksheet.id" OR "worksheet.position". Both given.')
            ->end()
            // One of name/id/position must be set
            ->validate()
                ->ifTrue(function (array $worksheet): bool {
                    $hasName = isset($worksheet['name']);
                    $hasId = isset($worksheet['id']);
                    $hasPosition = array_key_exists('position', $worksheet); // position can be 0
                    return !$hasName && !$hasId && !$hasPosition;
                })
                ->thenInvalid('In config must be ONE OF "worksheet.name", "worksheet.id" OR "worksheet.position".')
            ->end();
        // @formatter:on

        return $root;
    }
}



================================================
FILE: src/Exception/AccessTokenInitException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\ApplicationExceptionInterface;

class AccessTokenInitException extends \Exception implements ApplicationExceptionInterface
{

}



================================================
FILE: src/Exception/AccessTokenRefreshException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class AccessTokenRefreshException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/BadRequestException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class BadRequestException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/BatchRequestException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Exception;
use Keboola\CommonExceptions\ApplicationExceptionInterface;
use Throwable;

class BatchRequestException extends Exception implements ApplicationExceptionInterface
{
    private ?string $errorCode;

    public function __construct(string $message, int $code, ?Throwable $previous = null, ?string $errorCode = null)
    {
        parent::__construct($message, $code, $previous);
        $this->errorCode = $errorCode;
    }

    public function getErrorCode(): ?string
    {
        return $this->errorCode;
    }
}



================================================
FILE: src/Exception/CsvFileException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class CsvFileException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/FileInDriveNotFoundException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Throwable;

class FileInDriveNotFoundException extends ResourceNotFoundException
{
    private string $endpointUrl;

    public function __construct(string $message, string $endpointUrl, int $code = 0, ?Throwable $previous = null)
    {
        parent::__construct($message, $code, $previous);
        $this->endpointUrl = $endpointUrl;
    }

    public function getEndpointUrl(): string
    {
        return $this->endpointUrl;
    }
}



================================================
FILE: src/Exception/GatewayTimeoutException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class GatewayTimeoutException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/InvalidAuthDataException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class InvalidAuthDataException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/InvalidConfigException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;
use Symfony\Component\Config\Definition\Exception\InvalidConfigurationException;

class InvalidConfigException extends InvalidConfigurationException implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/InvalidFileTypeException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class InvalidFileTypeException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/InvalidSessionException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class InvalidSessionException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/ResourceNotFoundException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class ResourceNotFoundException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/ShareLinkException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class ShareLinkException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/UnexpectedCountException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class UnexpectedCountException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/UnexpectedValueException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class UnexpectedValueException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/UserException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class UserException extends \Exception implements UserExceptionInterface
{

}



================================================
FILE: src/Exception/WorkbookAlreadyExistsException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class WorkbookAlreadyExistsException extends \Exception implements UserExceptionInterface
{
}



================================================
FILE: src/Exception/WorksheetAlreadyExistsException.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Exception;

use Keboola\CommonExceptions\UserExceptionInterface;

class WorksheetAlreadyExistsException extends \Exception implements UserExceptionInterface
{
}



================================================
FILE: tests/bootstrap.php
================================================
<?php

declare(strict_types=1);

require __DIR__ . '/../vendor/autoload.php';

use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use \Keboola\OneDriveWriter\Fixtures\FixturesUtils;

FixturesCatalog::initialize();
FixturesUtils::disableLog();



================================================
FILE: tests/api/AuthTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use ArrayObject;
use Keboola\Component\JsonHelper;
use Keboola\OneDriveWriter\Auth\TokenDataManager;
use Keboola\OneDriveWriter\Exception\AccessTokenInitException;
use Keboola\OneDriveWriter\Exception\AccessTokenRefreshException;
use PHPUnit\Framework\Assert;

class AuthTest extends BaseTest
{
    /**
     * @dataProvider getValidCredentials`
     */
    public function testValidCredentials(
        string $appId,
        string $appSecret,
        string $accessToken,
        string $refreshToken
    ): void {
        $data = [
            'access_token' => $accessToken,
            'refresh_token' => $refreshToken,
        ];
        $api = $this->createApi($appId, $appSecret, $data);
        Assert::assertNotEmpty($api->getAccountName());
    }

    /**
     * @dataProvider getInvalidCredentials
     */
    public function testInvalidCredentials(
        string $expectedExceptionMsg,
        string $appId,
        string $appSecret,
        string $accessToken,
        string $refreshToken
    ): void {
        $data = [
            'access_token' => $accessToken,
            'refresh_token' => $refreshToken,
        ];
        $this->expectException(AccessTokenRefreshException::class);
        $this->expectExceptionMessageMatches($expectedExceptionMsg);
        $this->createApi($appId, $appSecret, $data);
    }

    /**
     * @dataProvider getInvalidAuthData
     */
    public function testInvalidAuthDataFormat(
        string $expectedExceptionMsg,
        array $data
    ): void {
        // Try auth with invalid app-id
        $this->expectException(AccessTokenInitException::class);
        $this->expectExceptionMessage($expectedExceptionMsg);
        $appId = (string) getenv('OAUTH_APP_ID');
        $appSecret = (string) getenv('OAUTH_APP_SECRET');
        $this->createApi($appId, $appSecret, $data);
    }

    public function testEmptyState(): void
    {
        // State is empty
        $state = new ArrayObject();
        $originAccessToken = (string) getenv('OAUTH_ACCESS_TOKEN');
        $originRefreshToken = (string) getenv('OAUTH_REFRESH_TOKEN');

        // Refresh tokens
        $tokenProvider = $this->createRefreshTokenProvider($state);
        $newAccessToken = $tokenProvider->get();

        // We have a new access token
        Assert::assertNotEmpty($newAccessToken->getToken());
        Assert::assertNotSame($originAccessToken, $newAccessToken->getToken());
        Assert::assertNotSame($originRefreshToken, $newAccessToken->getRefreshToken());

        // And tokens are stored to state
        $state = $state->getArrayCopy();
        $dataRaw = $state[TokenDataManager::STATE_AUTH_DATA_KEY];
        $data = JsonHelper::decode($dataRaw);
        Assert::assertNotEmpty($data['access_token']);
        Assert::assertNotEmpty($data['refresh_token']);
        Assert::assertNotSame($originAccessToken, $data['access_token']);
        Assert::assertNotSame($originRefreshToken, $data['refresh_token']);
    }

    public function testEmptyStateInvalidTokens(): void
    {
        $state = new ArrayObject([]);
        $tokenProvider = $this->createRefreshTokenProvider($state, [
            'access_token' => 'invalid',
            'refresh_token' => 'invalid',
        ]);

        $this->expectException(AccessTokenRefreshException::class);
        $this->expectExceptionMessageMatches('/Microsoft OAuth API token refresh failed ' .
            '\(invalid_grant:.*\). Please reset authorization in the extractor configuration\./s');
        $tokenProvider->get();
    }

    public function testState(): void
    {
        // State contains valid tokens, from the previous run
        $originAccessToken = (string) getenv('OAUTH_ACCESS_TOKEN');
        $originRefreshToken = (string) getenv('OAUTH_REFRESH_TOKEN');
        $state = new ArrayObject([
            TokenDataManager::STATE_AUTH_DATA_KEY => json_encode([
                'access_token' => $originAccessToken,
                'refresh_token' => $originRefreshToken,
            ]),
        ]);

        // And configuration contains expired old tokens, but they are not used
        $tokenProvider = $this->createRefreshTokenProvider($state, [
            'access_token' => 'old',
            'refresh_token' => 'old',
        ]);
        $newAccessToken = $tokenProvider->get();

        // We have a new access token
        Assert::assertNotEmpty($newAccessToken->getToken());
        Assert::assertNotSame($originAccessToken, $newAccessToken->getToken());
        Assert::assertNotSame($originRefreshToken, $newAccessToken->getRefreshToken());

        // And tokens are stored to state
        $state = $state->getArrayCopy();
        $dataRaw = $state[TokenDataManager::STATE_AUTH_DATA_KEY];
        Assert::assertIsString($dataRaw);
        $data = JsonHelper::decode((string) $dataRaw);
        Assert::assertNotEmpty($data['access_token']);
        Assert::assertNotEmpty($data['refresh_token']);
        Assert::assertNotSame($originAccessToken, $data['access_token']);
        Assert::assertNotSame($originRefreshToken, $data['refresh_token']);
    }

    public function testStateInvalidTokens(): void
    {
        $state = new ArrayObject([
            TokenDataManager::STATE_AUTH_DATA_KEY => json_encode([
                'access_token' => 'invalid',
                'refresh_token' => 'invalid',
            ]),
        ]);
        $tokenProvider = $this->createRefreshTokenProvider($state, [
            'access_token' => 'invalid',
            'refresh_token' => 'invalid',
        ]);

        $this->expectException(AccessTokenRefreshException::class);
        $this->expectExceptionMessageMatches('/Microsoft OAuth API token refresh failed ' .
            '\(invalid_grant:.*\). Please reset authorization in the extractor configuration\./s');
        $tokenProvider->get();
    }

    public function getValidCredentials(): array
    {
        return [
            'all-valid' => [
                getenv('OAUTH_APP_ID'),
                getenv('OAUTH_APP_SECRET'),
                getenv('OAUTH_ACCESS_TOKEN'),
                getenv('OAUTH_REFRESH_TOKEN'),
            ],
            // Invalid access token is not problem.
            // New access token will be obtained using refresh token.
            'invalid-access-token' => [
                getenv('OAUTH_APP_ID'),
                getenv('OAUTH_APP_SECRET'),
                'invalid-access-token',
                getenv('OAUTH_REFRESH_TOKEN'),
            ],
        ];
    }

    public function getInvalidCredentials(): array
    {
        return [
            'invalid-app-id' => [
                '/Microsoft OAuth API token refresh failed \(invalid_grant:.*\). ' .
                'Please reset authorization in the extractor configuration\./s',
                'invalid-app-id',
                getenv('OAUTH_APP_SECRET'),
                getenv('OAUTH_ACCESS_TOKEN'),
                getenv('OAUTH_REFRESH_TOKEN'),
            ],
            'invalid-app-secret' => [
                '/Microsoft OAuth API token refresh failed \(invalid_client:.*\). ' .
                'Please reset authorization in the extractor configuration\./s',
                getenv('OAUTH_APP_ID'),
                'invalid-app-secret',
                getenv('OAUTH_ACCESS_TOKEN'),
                getenv('OAUTH_REFRESH_TOKEN'),
            ],
            'invalid-refresh-token' => [
                '/Microsoft OAuth API token refresh failed \(invalid_grant:.*\). ' .
                'Please reset authorization in the extractor configuration\./s',
                getenv('OAUTH_APP_ID'),
                getenv('OAUTH_APP_SECRET'),
                getenv('OAUTH_ACCESS_TOKEN'),
                'invalid-refresh-token',
            ],
        ];
    }

    public function getInvalidAuthData(): array
    {
        return [
            'empty-data' => [
                'Missing key "access_token", "refresh_token" in OAuth data array.',
                [],
            ],
            'missing-access-token' => [
                'Missing key "access_token" in OAuth data array.',
                [
                    'refresh_token' => getenv('OAUTH_REFRESH_TOKEN'),
                ],
            ],
            'missing-refresh-token' => [
                'Missing key "refresh_token" in OAuth data array.',
                [
                    'access_token' => getenv('OAUTH_ACCESS_TOKEN'),
                ],
            ],
        ];
    }
}



================================================
FILE: tests/api/BaseTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use ArrayObject;
use Keboola\OneDriveWriter\Api\Api;
use Keboola\OneDriveWriter\Api\ApiFactory;
use Keboola\OneDriveWriter\Api\GraphApiFactory;
use Keboola\OneDriveWriter\Auth\RefreshTokenProvider;
use Keboola\OneDriveWriter\Auth\TokenDataManager;
use Keboola\OneDriveWriter\Auth\TokenProvider;
use Keboola\OneDriveWriter\Auth\TokenProviderFactory;
use Keboola\OneDriveWriter\Configuration\Config;
use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use Keboola\OneDriveWriter\Fixtures\FixturesUtils;
use Microsoft\Graph\Graph;
use PHPUnit\Framework\TestCase;
use Psr\Log\Test\TestLogger;

abstract class BaseTest extends TestCase
{
    protected TestLogger $logger;

    protected Api $api;

    protected FixturesUtils $utils;

    protected ApiFactory $apiFactory;

    protected FixturesCatalog $fixtures;

    protected function setUp(): void
    {
        parent::setUp();

        $this->checkEnvironment(['OAUTH_APP_ID', 'OAUTH_APP_SECRET', 'OAUTH_ACCESS_TOKEN', 'OAUTH_REFRESH_TOKEN']);
        $this->logger = new TestLogger();
        $this->api = $this->createApi(
            (string) getenv('OAUTH_APP_ID'),
            (string) getenv('OAUTH_APP_SECRET'),
            [
                'access_token' => (string) getenv('OAUTH_ACCESS_TOKEN'),
                'refresh_token' => (string) getenv('OAUTH_REFRESH_TOKEN'),
            ],
        );
        $this->utils = new FixturesUtils();
        $this->fixtures = FixturesCatalog::load();
    }

    protected function createApi(
        string $appId,
        string $appSecret,
        array $oauthData
    ): Api {
        $config = $this->createMock(Config::class);
        $config->method('getOAuthApiAppKey')->willReturn($appId);
        $config->method('getOAuthApiAppSecret')->willReturn($appSecret);
        $config->method('getOAuthApiData')->willReturn($oauthData);

        $state = new ArrayObject();
        $tokenProviderFactory = new TokenProviderFactory($config, $state, $this->logger);
        $tokenProvider = $tokenProviderFactory->create();
        $apiFactory = new ApiFactory($this->logger, $tokenProvider);
        return $apiFactory->create();
    }

    protected function createGraphApi(): Graph
    {
        $state = new ArrayObject();
        $tokenProvider = $this->createRefreshTokenProvider($state);
        $graphApiFactory = new GraphApiFactory();
        return $graphApiFactory->create($tokenProvider->get());
    }

    protected function createRefreshTokenProvider(ArrayObject $state, ?array $oauthData = null): TokenProvider
    {
        $appId = (string) getenv('OAUTH_APP_ID');
        $appSecret = (string) getenv('OAUTH_APP_SECRET');
        $accessToken = (string) getenv('OAUTH_ACCESS_TOKEN');
        $refreshToken = (string) getenv('OAUTH_REFRESH_TOKEN');
        $oauthData = $oauthData ?? [
                'access_token' => $accessToken,
                'refresh_token' => $refreshToken,
            ];
        $dataManager = new TokenDataManager($oauthData, $state);
        return new RefreshTokenProvider($appId, $appSecret, null, $dataManager, $this->logger);
    }

    protected function checkEnvironment(array $vars): void
    {
        foreach ($vars as $var) {
            if (empty(getenv($var))) {
                throw new \Exception(sprintf('Missing environment var "%s".', $var));
            }
        }
    }
}



================================================
FILE: tests/api/BatchRequestTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use PHPUnit\Framework\Assert;

class BatchRequestTest extends BaseTest
{
    public function testEmptyBatchRequest(): void
    {
        // Test for bug COM-214, when empty batch request resulted to "BadRequest: Invalid batch payload format."
        $batch = $this->api->createBatchRequest();
        Assert::assertCount(0, iterator_to_array($batch->execute()));
    }
}



================================================
FILE: tests/api/ClearSheetTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use Keboola\OneDriveWriter\Sheet;
use Keboola\OneDriveWriter\SheetFile;
use PHPUnit\Framework\Assert;

class ClearSheetTest extends BaseTest
{
    public function testClearSheet(): void
    {
        $driveId = $this->fixtures->getDrive()->getDriveId();
        $file = $this->utils->uploadTmpFile($driveId, FixturesCatalog::FILE_SPECIAL_CASES);

        // Not empty content before
        $content = $this->utils->getWorksheetContent($file, 0);
        Assert::assertFalse($content->isEmpty());
        Assert::assertSame('C4:I14', $content->getRange()->getAddress());

        // Clear
        $this->api->clearSheet(new Sheet(
            new SheetFile($file->getDriveId(), $file->getFileId(), false),
            $file->getWorksheetId(0),
            'Some name',
            false
        ));

        // Empty content after
        sleep(1);
        $content = $this->utils->getWorksheetContent($file, 0);
        Assert::assertTrue($content->isEmpty());
        Assert::assertSame('A1:A1', $content->getRange()->getAddress());
    }
}



================================================
FILE: tests/api/CreateEmptyFileTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use Keboola\OneDriveWriter\Api\Helpers;
use Keboola\OneDriveWriter\Api\Model\Worksheet;
use Keboola\OneDriveWriter\Fixtures\FixturesUtils;
use PHPUnit\Framework\Assert;

class CreateEmptyFileTest extends BaseTest
{
    public function testCreateEmptyFile(): void
    {
        [$dir, $name] = FixturesUtils::createTmpFilePath();
        $path = $dir . '/' . $name;
        $endpoint = '/me/drive/root' . Helpers::convertPathToApiFormat($path);

        $file = $this->api->createEmptyWorkbook($endpoint);
        Assert::assertSame($this->fixtures->getMeDriveId(), $file->getDriveId());
        Assert::assertNotEmpty($file->getFileId());
        Assert::assertSame($dir, '/' . implode('/', $file->getPath()));
        Assert::assertSame($name, $file->getName());

        /** @var Worksheet[] $sheets */
        $sheets = iterator_to_array($this->api->getSheets($file->getDriveId(), $file->getFileId()));
        Assert::assertCount(1, $sheets);
        Assert::assertSame('New', $sheets[0]->getName());
    }
}



================================================
FILE: tests/api/GetSheetIdTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use Keboola\OneDriveWriter\Exception\UnexpectedValueException;
use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use PHPUnit\Framework\Assert;

class GetSheetIdTest extends BaseTest
{
    /**
     * @dataProvider getFiles
     */
    public function testGetSheetIdByPosition(string $file): void
    {
        $fixture = $this->fixtures->getDrive()->getFile($file);
        $worksheets = $this->api->getSheets($fixture->getDriveId(), $fixture->getFileId());
        foreach ($worksheets as $sheet) {
            Assert::assertSame(
                $sheet->getWorksheetId(),
                $this->api->getSheetIdByPosition($fixture->getDriveId(), $fixture->getFileId(), $sheet->getPosition())
            );
        }
    }

    public function testSheetNotFound(): void
    {
        $fixture = $this->fixtures->getDrive()->getFile(FixturesCatalog::FILE_ONE_SHEET);

        $this->expectException(ResourceNotFoundException::class);
        $this->expectExceptionMessage('No worksheet at position "123".');
        $this->api->getSheetIdByPosition($fixture->getDriveId(), $fixture->getFileId(), 123);
    }

    public function testNegativePosition(): void
    {
        $fixture = $this->fixtures->getDrive()->getFile(FixturesCatalog::FILE_ONE_SHEET);

        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Worksheet position must be greater than zero. Given "-5".');
        $this->api->getSheetIdByPosition($fixture->getDriveId(), $fixture->getFileId(), -5);
    }

    public function getFiles(): array
    {
        return [
            [FixturesCatalog::FILE_ONE_SHEET],
            [FixturesCatalog::FILE_HIDDEN_SHEET],
        ];
    }
}



================================================
FILE: tests/api/GetSheetsTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use Keboola\OneDriveWriter\Exception\InvalidFileTypeException;
use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use Keboola\OneDriveWriter\Fixtures;
use PHPUnit\Framework\Assert;

class GetSheetsTest extends BaseTest
{
    /**
     * @dataProvider getValidFiles
     */
    public function testValidFile(string $filePath, array $expected): void
    {
        $file = $this->fixtures->getDrive()->getFile($filePath);
        $worksheets = iterator_to_array($this->api->getSheets($file->getDriveId(), $file->getFileId()));

        // Compare with expected data
        $serialized = json_decode((string) json_encode($worksheets), true);
        foreach ($serialized as &$worksheet) {
            // Dynamic values: assert not empty and ignore
            Assert::assertNotEmpty($worksheet['driveId']);
            Assert::assertNotEmpty($worksheet['fileId']);
            Assert::assertNotEmpty($worksheet['worksheetId']);
            unset($worksheet['driveId']);
            unset($worksheet['fileId']);
            unset($worksheet['worksheetId']);
        }
        Assert::assertSame($expected, $serialized);
    }

    /**
     * @dataProvider getFilesWithInvalidType
     */
    public function testFileWithInvalidFileType(string $filePath): void
    {
        $file = $this->fixtures->getDrive()->getFile($filePath);
        $this->expectException(InvalidFileTypeException::class);
        $this->expectExceptionMessage(
            'It looks like the specified file is not in the "XLSX" Excel format. ' .
            'Error: "AccessDenied: Could not obtain a WAC access token."'
        );
        iterator_to_array($this->api->getSheets($file->getDriveId(), $file->getFileId()));
    }

    public function testFileNotFound(): void
    {
        $driveId = $this->fixtures->getDrive()->getFile(Fixtures\FixturesCatalog::FILE_EMPTY)->getDriveId();
        $fileId = '01GQDMCCPK5MFK6QCSJFC2HYWA7AABCDEF';  // not exists
        $this->expectException(ResourceNotFoundException::class);
        $this->expectExceptionMessage('The resource could not be found.');
        iterator_to_array($this->api->getSheets($driveId, $fileId));
    }

    public function testDriveNotFound(): void
    {
        $driveId = 'b!nZgsjp3RK0aRFp01PZWjKUicqho1KehCtKM1UhLEWybvgM_dt6mJRKV571234567'; // not exists
        $fileId = $this->fixtures->getDrive()->getFile(Fixtures\FixturesCatalog::FILE_EMPTY)->getFileId();
        $this->expectException(ResourceNotFoundException::class);
        $this->expectExceptionMessage('It can be caused by typo in an ID, or resource doesn\'t exists.');
        iterator_to_array($this->api->getSheets($driveId, $fileId));
    }

    public function getValidFiles(): array
    {
        return [
            'empty' => [
                Fixtures\FixturesCatalog::FILE_EMPTY,
                [
                    [
                        'position' => 0,
                        'name' => 'Sheet1',
                        'title' => 'Sheet1',
                        'visible' => true,
                        'header' => [],
                    ],
                ],
            ],
            'hidden_sheet' => [
                Fixtures\FixturesCatalog::FILE_HIDDEN_SHEET,
                [
                    [
                        'position' => 0,
                        'name' => 'Sheet1',
                        'title' => 'Sheet1',
                        'visible' => true,
                        'header' => ['Col_1', 'Col_2', 'Col_3'],
                    ],
                    [
                        'position' => 1,
                        'name' => 'Zošit 2',
                        'title' => 'Zošit 2',
                        'visible' => true,
                        'header' => ['Col_1', 'Col_2', 'Col_3'],
                    ],
                    [
                        'position' => 2,
                        'name' => 'Hidden Sheet 3',
                        'title' => 'Hidden Sheet 3 (hidden)',
                        'visible' => false,
                        'header' => ['Col_4', 'Col_5', 'Col_6'],
                    ],
                    [
                        'position' => 3,
                        'name' => 'sheet=4',
                        'title' => 'sheet=4',
                        'visible' => true,
                        'header' => ['Col_1', 'Col_2', 'Col_3'],
                    ],
                ],
            ],
            'one_sheet' => [
                Fixtures\FixturesCatalog::FILE_ONE_SHEET,
                [
                    [
                        'position' => 0,
                        'name' => 'Only One Sheet',
                        'title' => 'Only One Sheet',
                        'visible' => true,
                        'header' => ['Col_1', 'Col_2', 'Col_3'],
                    ],
                ],
            ],
            'only_header' => [
                Fixtures\FixturesCatalog::FILE_ONLY_HEADER,
                [
                    [
                        'position' => 0,
                        'name' => 'Sheet1',
                        'title' => 'Sheet1',
                        'visible' => true,
                        'header' => ['Col1', 'Col2', 'Col3', 'Col4'],
                    ],
                ],
            ],
            'special_cases' => [
                Fixtures\FixturesCatalog::FILE_SPECIAL_CASES,
                [
                    [
                        'position' => 0,
                        'name' => 'Special 123úěščř!@#$%^',
                        'title' => 'Special 123úěščř!@#$%^',
                        'visible' => true,
                        'header' =>
                            [
                                'Duplicate',
                                'Duplicate-1',
                                'column-3',
                                'column-4',
                                'Special_123_uescr',
                                'column-6',
                                'column-7',
                            ],
                    ],
                ],
            ],
            'table_offset' => [
                Fixtures\FixturesCatalog::FILE_TABLE_OFFSET,
                [
                    [
                        'position' => 0,
                        'name' => 'Sheet 1',
                        'title' => 'Sheet 1',
                        'visible' => true,
                        'header' =>
                            [
                                'Segment',
                                'column-2',
                                'Country',
                                'Duplicate',
                                'Duplicate-1',
                                'Product',
                                'Discount_Band',
                                'Units_Sold',
                                'column-9',
                                'column-10',
                            ],
                    ],
                ],
            ],
        ];
    }

    public function getFilesWithInvalidType(): array
    {
        return [
            'csv-file' => [Fixtures\FixturesCatalog::FILE_CSV],
            'ods-file' => [Fixtures\FixturesCatalog::FILE_ODS],
            'odt-file' => [Fixtures\FixturesCatalog::FILE_ODT],
            'xls-file' => [Fixtures\FixturesCatalog::FILE_XLS],
        ];
    }
}



================================================
FILE: tests/api/HeaderTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use Keboola\OneDriveWriter\Sheet;
use Keboola\OneDriveWriter\SheetFile;
use PHPUnit\Framework\Assert;

class HeaderTest extends BaseTest
{
    /**
     * @dataProvider getFiles
     */
    public function testGetSheetHeader(
        string $file,
        int $worksheetPosition,
        string $expectedAddress,
        array $expectedColumns
    ): void {
        $fixture = $this->fixtures->getDrive()->getFile($file);
        $header = $this->api->getSheetHeader(new Sheet(
            new SheetFile($fixture->getDriveId(), $fixture->getFileId(), false),
            $fixture->getWorksheetId($worksheetPosition),
            'Some name',
            false
        ));
        Assert::assertSame($expectedAddress, $header->getAddress());
        Assert::assertSame($expectedColumns, $header->getColumns());
    }

    public function getFiles(): array
    {
        return [
            'hidden-sheet' => [
                FixturesCatalog::FILE_HIDDEN_SHEET,
                2, // hidden sheet, see ListSheetsTest.php
                'A48:C48',
                ['Col_4', 'Col_5', 'Col_6'],
            ],
            'one-sheet' => [
                FixturesCatalog::FILE_ONE_SHEET,
                0,
                'A1:C1',
                ['Col_1', 'Col_2', 'Col_3'],
            ],
            'only-header' => [
                FixturesCatalog::FILE_ONLY_HEADER,
                0,
                'A1:D1',
                ['Col1', 'Col2', 'Col3', 'Col4'],
            ],
            'only-one-column' => [
                FixturesCatalog::FILE_ONLY_ONE_COLUMN,
                0,
                'A1:A1',
                ['Col1'],
            ],
            'special-cases' => [
                FixturesCatalog::FILE_SPECIAL_CASES,
                0,
                'C4:I4',
                [
                    'Duplicate',
                    'Duplicate-1',
                    'column-3',
                    'column-4',
                    'Special_123_uescr',
                    'column-6',
                    'column-7',
                ],
            ],
            'table-offset' => [
                FixturesCatalog::FILE_TABLE_OFFSET,
                0,
                'C9:L9',
                [
                    'Segment',
                    'column-2',
                    'Country',
                    'Duplicate',
                    'Duplicate-1',
                    'Product',
                    'Discount_Band',
                    'Units_Sold',
                    'column-9',
                    'column-10',
                ],
            ],
        ];
    }
}



================================================
FILE: tests/api/InsertRowsTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use JakubOnderka\PhpParallelLint\ArrayIterator;
use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use Keboola\OneDriveWriter\Sheet;
use Keboola\OneDriveWriter\SheetFile;
use PHPUnit\Framework\Assert;

class InsertRowsTest extends BaseTest
{
    /**
     * @dataProvider getFiles
     */
    public function testInsertRows(
        bool $append,
        string $fileName,
        string $rangeBefore,
        array $insertRows,
        string $rangeAfter,
        array $stateAfter,
        array $expectedLogs,
        int $bulk = 30000
    ): void {
        $driveId = $this->fixtures->getDrive()->getDriveId();
        $file = $this->utils->uploadTmpFile($driveId, $fileName);

        // Content before
        $contentBefore = $this->utils->getWorksheetContent($file, 0);
        Assert::assertSame($rangeBefore, $contentBefore->getRange()->getAddress());

        // Insert
        $iterator = new ArrayIterator($insertRows);
        $this->api->insertRows(
            new Sheet(
                new SheetFile($file->getDriveId(), $file->getFileId(), false),
                $file->getWorksheetId(0),
                'Some name',
                false
            ),
            $append,
            $iterator,
            $bulk
        );

        // Check result
        sleep(2);
        $contentAfter = $this->utils->getWorksheetContent($file, 0);
        Assert::assertSame($rangeAfter, $contentAfter->getRange()->getAddress());
        Assert::assertSame($stateAfter, $contentAfter->getRows());

        // Check logs
        if ($expectedLogs !== null) {
            Assert::assertSame(
                $expectedLogs,
                array_map(fn(array $r) => strtoupper($r['level']) . ': ' . $r['message'], $this->logger->records)
            );
        }
    }

    public function getFiles(): array
    {
        return [
            'one-sheet-overwrite' => [
               false,
                FixturesCatalog::FILE_ONE_SHEET,
                'A1:C3',
                [['a', 'b', 'c', 'd'], ['1', '2', '3', ''], ['x', 'y', 'z', 'zz']],
                'A1:D3',
                [['a', 'b', 'c', 'd'], ['1', '2', '3', ''], ['x', 'y', 'z', 'zz']],
                [
                    'INFO: Sheet cleared.',
                    'INFO: Inserted 3 rows.',
                ],
            ],
            'one-sheet-overwrite-bulk-size-2' => [
                false,
                FixturesCatalog::FILE_ONE_SHEET,
                'A1:C3',
                [['a', 'b'], ['1', 'a'], ['2', 'b'], ['3', 'c'], ['4', 'd'], ['5', 'e'], ['6', 'f']],
                'A1:B7',
                [['a', 'b'], ['1', 'a'], ['2', 'b'], ['3', 'c'], ['4', 'd'], ['5', 'e'], ['6', 'f']],
                [
                    'INFO: Sheet cleared.',
                    'INFO: Inserted 2 rows.',
                    'INFO: Inserted 2 rows.',
                    'INFO: Inserted 2 rows.',
                    'INFO: Inserted 1 rows.',
                ],
                2,
            ],
            'one-sheet-overwrite-bulk-size-3' => [
                false,
                FixturesCatalog::FILE_ONE_SHEET,
                'A1:C3',
                [['a', 'b'], ['1', 'a'], ['2', 'b'], ['3', 'c'], ['4', 'd'], ['5', 'e'], ['6', 'f']],
                'A1:B7',
                [['a', 'b'], ['1', 'a'], ['2', 'b'], ['3', 'c'], ['4', 'd'], ['5', 'e'], ['6', 'f']],
                [
                    'INFO: Sheet cleared.',
                    'INFO: Inserted 3 rows.',
                    'INFO: Inserted 3 rows.',
                    'INFO: Inserted 1 rows.',
                ],
                3,
            ],
            'table-offset-overwrite' => [
                false,
                FixturesCatalog::FILE_TABLE_OFFSET,
                'C9:L14',
                [['a', 'b', 'c'], ['1', '2', '3'], ['x', 'y', 'z']],
                'A1:C3',
                [['a', 'b', 'c'], ['1', '2', '3'], ['x', 'y', 'z']],
                [
                    'INFO: Sheet cleared.',
                    'INFO: Inserted 3 rows.',
                ],
            ],
            'empty-overwrite' => [
                false,
                FixturesCatalog::FILE_EMPTY,
                'A1:A1',
                [['a', 'b', 'c'], ['1', '2', '3'], ['x', 'y', 'z']],
                'A1:C3',
                [['a', 'b', 'c'], ['1', '2', '3'], ['x', 'y', 'z']],
                [
                    'INFO: Sheet cleared.',
                    'INFO: Inserted 3 rows.',
                ],
            ],
            'one-sheet-append-same-header' => [
                true,
                FixturesCatalog::FILE_ONE_SHEET,
                'A1:C3',
                [['Col 1', 'Col 2', 'Col 3'], ['1', '2', '3'], ['x', 'y', 'z']],
                'A1:C5',
                [
                    // Old rows
                    ['Col 1', 'Col 2', 'Col 3'], ['A', 'B', 'C'], ['D', 'E', 'F'],
                    // New rows
                    ['1', '2', '3'], ['x', 'y', 'z'],
                ],
                [
                    'INFO: Current sheet range: "A1:C3"',
                    'INFO: Current sheet header "A1:C1": "Col_1", "Col_2", "Col_3"',
                    'INFO: Inserted 2 rows.',
                ],
            ],
            'one-sheet-append-different-header' => [
                true,
                FixturesCatalog::FILE_ONE_SHEET,
                'A1:C3',
                [['a', 'b', 'c', 'd'], ['1', '2', '3', ''], ['x', 'y', 'z', 'zz']],
                'A1:D5',
                [
                    // Old rows
                    ['Col 1', 'Col 2', 'Col 3', ''], ['A', 'B', 'C', ''], ['D', 'E', 'F', ''],
                    // New rows
                    ['1', '2', '3', ''], ['x', 'y', 'z', 'zz'],
                ],
                [
                    'INFO: Current sheet range: "A1:C3"',
                    'INFO: Current sheet header "A1:C1": "Col_1", "Col_2", "Col_3"',
                    'WARNING: Headers mismatch. Ignored new header: "a", "b", "c", "d"',
                    'INFO: Inserted 2 rows.',
                ],
            ],
            'one-sheet-append-bulk-size-2' => [
                true,
                FixturesCatalog::FILE_ONE_SHEET,
                'A1:C3',
                [['a', 'b'], ['1', 'a'], ['2', 'b'], ['3', 'c'], ['4', 'd'], ['5', 'e'], ['6', 'f'], ['7', 'g']],
                'A1:C10',
                [
                    ['Col 1', 'Col 2', 'Col 3'],
                    ['A', 'B', 'C'],
                    ['D', 'E', 'F'],
                    ['1', 'a', ''],
                    ['2', 'b', ''],
                    ['3', 'c', ''],
                    ['4', 'd', ''],
                    ['5', 'e', ''],
                    ['6', 'f', ''],
                    ['7', 'g', ''],
                ],
                [
                    'INFO: Current sheet range: "A1:C3"',
                    'INFO: Current sheet header "A1:C1": "Col_1", "Col_2", "Col_3"',
                    'WARNING: Headers mismatch. Ignored new header: "a", "b"',
                    'INFO: Inserted 2 rows.',
                    'INFO: Inserted 2 rows.',
                    'INFO: Inserted 2 rows.',
                    'INFO: Inserted 1 rows.',
                ],
                2,
            ],
            'one-sheet-append-bulk-size-3' => [
                true,
                FixturesCatalog::FILE_ONE_SHEET,
                'A1:C3',
                [['a', 'b'], ['1', 'a'], ['2', 'b'], ['3', 'c'], ['4', 'd'], ['5', 'e'], ['6', 'f'], ['7', 'g']],
                'A1:C10',
                [
                    ['Col 1', 'Col 2', 'Col 3'],
                    ['A', 'B', 'C'],
                    ['D', 'E', 'F'],
                    ['1', 'a', ''],
                    ['2', 'b', ''],
                    ['3', 'c', ''],
                    ['4', 'd', ''],
                    ['5', 'e', ''],
                    ['6', 'f', ''],
                    ['7', 'g', ''],
                ],
                [
                    'INFO: Current sheet range: "A1:C3"',
                    'INFO: Current sheet header "A1:C1": "Col_1", "Col_2", "Col_3"',
                    'WARNING: Headers mismatch. Ignored new header: "a", "b"',
                    'INFO: Inserted 3 rows.',
                    'INFO: Inserted 3 rows.',
                    'INFO: Inserted 1 rows.',
                ],
                3,
            ],
            'table-offset-append' => [
                true,
                FixturesCatalog::FILE_TABLE_OFFSET,
                'C9:L14',
                [['a', 'b', 'c', 'd'], ['1', '2', '3', ''], ['x', 'y', 'z', 'zz']],
                'C9:L16',
                [
                    // Old rows
                    [
                        'Segment',
                        '',
                        'Country',
                        'Duplicate',
                        'Duplicate',
                        'Product',
                        'Discount Band',
                        'Units Sold',
                        '',
                        '',
                    ],
                    ['Government', '', 'Canada', '', '6', 'Carretera', 'None', '1618.5', '', '',],
                    ['Government', '', 'Germany', '', '7', 'Carretera', 'None', '1321', '', '',],
                    ['Midmarket', '', 'France', '', '8', 'Carretera', 'None', '2178', '', 'x',],
                    ['Midmarket', '', 'Germany', '', '9', 'Carretera', 'None', '888', '', 'y',],
                    [
                        'Midmarket', '(empty header)', 'Mexico', '(duplicate header)',
                        '(duplicate header)', 'Carretera', 'None', '2470', '', 'z',
                    ],
                    // New rows
                    ['1', '2', '3', '', '', '', '', '', '', ''],
                    ['x', 'y', 'z', 'zz', '', '', '', '', '', ''],
                ],
                [
                    'INFO: Current sheet range: "C9:L14"',
                    'INFO: Current sheet header "C9:L9": "Segment", "column-2", "Country", "Duplicate", ' .
                    '"Duplicate-1", "Product", "Discount_Band", "Units_Sold", "column-9", "column-10"',
                    'WARNING: Headers mismatch. Ignored new header: "a", "b", "c", "d"',
                    'INFO: Inserted 2 rows.',
                ],
            ],
            'empty-append' => [
                true,
                FixturesCatalog::FILE_EMPTY,
                'A1:A1',
                [['a', 'b', 'c'], ['1', '2', '3'], ['x', 'y', 'z']],
                'A1:C3',
                [['a', 'b', 'c'], ['1', '2', '3'], ['x', 'y', 'z']],
                [
                    'INFO: Sheet is empty.',
                    'INFO: Inserted 3 rows.',
                ],
            ],
        ];
    }
}



================================================
FILE: tests/api/RangeTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use Keboola\OneDriveWriter\Sheet;
use Keboola\OneDriveWriter\SheetFile;
use PHPUnit\Framework\Assert;

class RangeTest extends BaseTest
{
    /**
     * @dataProvider getFiles
     */
    public function testGetWorksheetRange(string $file, int $worksheetPosition, string $expectedRange): void
    {
        $fixture = $this->fixtures->getDrive()->getFile($file);
        $range = $this->api->getSheetRange(
            new Sheet(
                new SheetFile($fixture->getDriveId(), $fixture->getFileId(), false),
                $fixture->getWorksheetId($worksheetPosition),
                'Some name',
                false,
            )
        );
        Assert::assertSame($expectedRange, $range->getAddress());
    }

    public function getFiles(): array
    {
        return [
            'hidden-sheet' => [
                FixturesCatalog::FILE_HIDDEN_SHEET,
                2, // hidden sheet, see GetSheetsTest.php
                'A48:C50',
            ],
            'one-sheet' => [
                FixturesCatalog::FILE_ONE_SHEET,
                0,
                'A1:C3',
            ],
            'only-header' => [
                FixturesCatalog::FILE_ONLY_HEADER,
                0,
                'A1:D1',
            ],
            'only-one-column' => [
                FixturesCatalog::FILE_ONLY_ONE_COLUMN,
                0,
                'A1:A4',
            ],
            'special-cases' => [
                FixturesCatalog::FILE_SPECIAL_CASES,
                0,
                'C4:I14',
            ],
            'table-offset' => [
                FixturesCatalog::FILE_TABLE_OFFSET,
                0,
                'C9:L14',
            ],
        ];
    }
}



================================================
FILE: tests/api/SearchForFileTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\ApiTests;

use Keboola\OneDriveWriter\Api\Model\File;
use Keboola\OneDriveWriter\Exception\FileInDriveNotFoundException;
use Keboola\OneDriveWriter\Exception\InvalidFileTypeException;
use Keboola\OneDriveWriter\Exception\ShareLinkException;
use Keboola\OneDriveWriter\Exception\UnexpectedValueException;
use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\SkippedTestError;

class SearchForFileTest extends BaseTest
{
    public function testEmptySearch(): void
    {
        $this->expectException(UnexpectedValueException::class);
        $this->expectExceptionMessage('Unexpected path format "".');
        $this->api->searchWorkbook('');
    }

    public function testSearchByPathInMeDrive1(): void
    {
        $fixture = $this->fixtures->getMeDrive()->getFile(FixturesCatalog::FILE_ONE_SHEET);
        $path = $fixture->getPath();
        Assert::assertSame('/', $path[0]); // path starts with /

        /** @var File $file */
        $file = $this->api->searchWorkbook($path);
        Assert::assertNotNull($file);
        Assert::assertSame('one_sheet.xlsx', $file->getName());
        Assert::assertSame(['my', '__wr-onedrive-test-folder', 'valid'], $file->getPath());
        Assert::assertSame($fixture->getDriveId(), $file->getDriveId());
        Assert::assertSame($fixture->getFileId(), $file->getFileId());
    }

    public function testSearchByPathInMeDrive2(): void
    {
        $fixture = $this->fixtures->getMeDrive()->getFile(FixturesCatalog::FILE_ONE_SHEET);
        $path = $fixture->getPath();
        $path = ltrim($path, '/');
        Assert::assertNotSame('/', $path[0]); // path NOT starts with /

        /** @var File $file */
        $file = $this->api->searchWorkbook($path);
        Assert::assertNotNull($file);
        Assert::assertSame('one_sheet.xlsx', $file->getName());
        Assert::assertSame(['my', '__wr-onedrive-test-folder', 'valid'], $file->getPath());
        Assert::assertSame($fixture->getDriveId(), $file->getDriveId());
        Assert::assertSame($fixture->getFileId(), $file->getFileId());
    }

    public function testSearchByPathInMeDriveNotFound(): void
    {
        $this->expectException(FileInDriveNotFoundException::class);
        $this->api->searchWorkbook('/file/not/found');
    }

    public function testSearchByPathInMeDriveInvalidFileType(): void
    {
        $this->expectException(InvalidFileTypeException::class);
        $this->expectExceptionMessage(
            'File is not in the "XLSX" Excel format. Mime type: "application/vnd.oasis.opendocument.text"'
        );
        $this->api->searchWorkbook(
            $this->fixtures->getMeDrive()->getFile(FixturesCatalog::FILE_ODT)->getPath()
        );
    }

    public function testSearchByPathInDrive(): void
    {
        $drive = $this->fixtures->getMeDrive();
        $driveId = urlencode($drive->getDriveId());
        $fixture = $drive->getFile(FixturesCatalog::FILE_ONE_SHEET);

        /** @var File $file */
        $file = $this->api->searchWorkbook("drive://{$driveId}/{$fixture->getPath()}");
        Assert::assertNotNull($file);
        Assert::assertSame($fixture->getDriveId(), $file->getDriveId());
        Assert::assertSame($fixture->getFileId(), $file->getFileId());
        Assert::assertSame($fixture->getName(), $file->getName());
        Assert::assertSame(
            $fixture->getPath(),
            '/' .implode('/', $file->getPath()) . '/' . $file->getName()
        );
    }

    public function testSearchByPathInDriveNotFound(): void
    {
        $this->expectException(FileInDriveNotFoundException::class);
        $drive = $this->fixtures->getMeDrive();
        $driveId = urlencode($drive->getDriveId());
        $this->api->searchWorkbook("drive://{$driveId}/file/not/found");
    }

    public function testSearchByPathInDriveInvalidFileType(): void
    {
        $drive = $this->fixtures->getMeDrive();
        $driveId = urlencode($drive->getDriveId());
        $fixture = $drive->getFile(FixturesCatalog::FILE_ODT);
        $path = "drive://{$driveId}/{$fixture->getPath()}";

        $this->expectException(InvalidFileTypeException::class);
        $this->expectExceptionMessage(
            'File is not in the "XLSX" Excel format. Mime type: "application/vnd.oasis.opendocument.text"'
        );
        $this->api->searchWorkbook($path);
    }

    public function testSearchByPathInSite(): void
    {
        $sharePointDrive = $this->fixtures->getSharePointDrive();
        $sharePointSiteName = $this->fixtures->getSharePointSiteName();
        if (!$sharePointDrive || !$sharePointSiteName) {
            throw new SkippedTestError('Skipped: share point drive is not set');
        }

        $siteName = urlencode($sharePointSiteName);
        $fixture = $sharePointDrive->getFile(FixturesCatalog::FILE_ONE_SHEET);

        /** @var File $file */
        $file = $this->api->searchWorkbook("site://{$siteName}/{$fixture->getPath()}");
        Assert::assertNotNull($file);
        Assert::assertSame($fixture->getDriveId(), $file->getDriveId());
        Assert::assertSame($fixture->getFileId(), $file->getFileId());
        Assert::assertSame($fixture->getName(), $file->getName());
        Assert::assertSame(
            "sites/{$sharePointSiteName}" . $fixture->getPath(),
            implode('/', $file->getPath()) . '/' . $file->getName()
        );
    }

    public function testSearchByPathInSiteNotFound(): void
    {
        $sharePointDrive = $this->fixtures->getSharePointDrive();
        if (!$sharePointDrive) {
            throw new SkippedTestError('Skipped: share point drive is not set');
        }

        $this->expectException(FileInDriveNotFoundException::class);
        $siteName = $this->fixtures->getSharePointSiteName();
        $this->api->searchWorkbook("site://{$siteName}/file/not/found");
    }

    public function testSearchByPathInSiteInvalidFileType(): void
    {
        $sharePointDrive = $this->fixtures->getSharePointDrive();
        if (!$sharePointDrive) {
            throw new SkippedTestError('Skipped: share point drive is not set');
        }

        $siteName = $this->fixtures->getSharePointSiteName();
        $fixture = $sharePointDrive->getFile(FixturesCatalog::FILE_ODT);
        $path = "site://{$siteName}/{$fixture->getPath()}";

        $this->expectException(InvalidFileTypeException::class);
        $this->expectExceptionMessage(
            'File is not in the "XLSX" Excel format. Mime type: "application/vnd.oasis.opendocument.text"'
        );
        $this->api->searchWorkbook($path);
    }

    public function testSearchByUrlMeDrive(): void
    {
        $fixture = $this->fixtures->getMeDrive()->getFile(FixturesCatalog::FILE_ONE_SHEET);

        /** @var File $file */
        $file = $this->api->searchWorkbook($fixture->getSharingLink());
        Assert::assertNotNull($file);
        Assert::assertSame('one_sheet.xlsx', $file->getName());
    }

    public function testSearchByUrlSharePoint(): void
    {
        $sharePointDrive = $this->fixtures->getSharePointDrive();
        if (!$sharePointDrive) {
            throw new SkippedTestError('Skipped: share point drive is not set');
        }

        $fixture = $this->fixtures->getMeDrive()->getFile(FixturesCatalog::FILE_ONE_SHEET);

        /** @var File $file */
        $file = $this->api->searchWorkbook($fixture->getSharingLink());
        Assert::assertNotNull($file);
        Assert::assertSame('one_sheet.xlsx', $file->getName());
    }

    public function testSearchByUrlInvalidFileTypeMeDrive(): void
    {
        $sharePointDrive = $this->fixtures->getSharePointDrive();
        if (!$sharePointDrive) {
            throw new SkippedTestError('Skipped: share point drive is not set');
        }

        $this->expectException(InvalidFileTypeException::class);
        $this->expectExceptionMessage(
            'File is not in the "XLSX" Excel format. Mime type: "application/vnd.oasis.opendocument.text"'
        );
        $fixture = $sharePointDrive->getFile(FixturesCatalog::FILE_ODT);
        $this->api->searchWorkbook($fixture->getSharingLink());
    }

    public function testSearchByUrlInvalidFileTypeSharePoint(): void
    {
        $sharePointDrive = $this->fixtures->getSharePointDrive();
        if (!$sharePointDrive) {
            throw new SkippedTestError('Skipped: share point drive is not set');
        }

        $this->expectException(InvalidFileTypeException::class);
        $this->expectExceptionMessage(
            'File is not in the "XLSX" Excel format. Mime type: "application/vnd.oasis.opendocument.text"'
        );
        $fixture = $sharePointDrive->getFile(FixturesCatalog::FILE_ODT);
        $this->api->searchWorkbook($fixture->getSharingLink());
    }

    public function testSearchByInvalidUrl(): void
    {
        $notExistsUrl = 'https://keboolads.sharepoint.com/:x:/r/sites/KeboolaExtraction/Excel/invalid';
        $this->expectException(ShareLinkException::class);
        $this->expectExceptionMessageMatches(
            '~The sharing link ".*" not exists, or you do not have permission to access it\.~',
        );
        $this->api->searchWorkbook($notExistsUrl);
    }
}



================================================
FILE: tests/datadir/DatadirTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\DataDirTests;

use Keboola\OneDriveWriter\Fixtures\File;
use Keboola\OneDriveWriter\Fixtures\FixturesUtils;
use PHPUnit\Framework\SkippedTestError;
use RuntimeException;
use ReflectionClass;
use Keboola\OneDriveWriter\Fixtures\FixturesCatalog;
use Keboola\DatadirTests\AbstractDatadirTestCase;
use Keboola\DatadirTests\DatadirTestSpecificationInterface;
use Keboola\DatadirTests\DatadirTestsProviderInterface;
use Symfony\Component\Process\Process;

class DatadirTest extends AbstractDatadirTestCase
{
    protected FixturesCatalog $fixtures;

    protected FixturesUtils $utils;

    protected ReflectionClass $fixturesCatalogRef;

    /** @var File[] */
    protected array $tmpFiles;

    protected function setUp(): void
    {
        parent::setUp();
        $this->fixtures = FixturesCatalog::load();
        $this->utils = new FixturesUtils();
        $this->fixturesCatalogRef = new ReflectionClass(FixturesCatalog::class);
        $this->tmpFiles = [];
    }


    /**
     * @dataProvider provideDatadirSpecifications
     */
    public function testDatadir(DatadirTestSpecificationInterface $specification): void
    {
        $tempDatadir = $this->getTempDatadir($specification);

        // Replace environment variables in config.json
        $configPath = $tempDatadir->getTmpFolder() . '/config.json';
        if (file_exists($configPath)) {
            $configContent = $this->modifyConfigFile((string) file_get_contents($configPath));
            file_put_contents($configPath, $configContent);
        }

        $process = $this->runScript($tempDatadir->getTmpFolder());

        $this->assertMatchesSpecification($specification, $process, $tempDatadir->getTmpFolder());
    }

    /**
     * @return DatadirTestsProviderInterface[]
     */
    protected function getDataProviders(): array
    {
        return [
            new DatadirTestsProvider($this->getTestFileDir()),
        ];
    }

    protected function modifyConfigFile(string $content): string
    {
        return (string) preg_replace_callback('~\$\{([^{}]+)}~', function (array $m) {
            $var = $m[1];
            $parts = explode('::', $var);

            switch (true) {
                // Special OAUTH_DATA variable
                case $var === 'OAUTH_DATA':
                    return (string) addslashes((string) json_encode([
                        'access_token' => getenv('OAUTH_ACCESS_TOKEN'),
                        'refresh_token' => getenv('OAUTH_REFRESH_TOKEN'),
                    ]));

                case $var === 'FIXTURES_CATALOG::getSharePointSiteName':
                    $sharePointSiteName = $this->fixtures->getSharePointSiteName();
                    if (!$sharePointSiteName) {
                        throw new SkippedTestError('SharePoint environment is not set.');
                    }
                    return $sharePointSiteName;

                case $var === 'FIXTURES_CATALOG::getDriveId':
                    return $this->fixtures->getDriveId();

                case $var === 'FIXTURES_CATALOG::getMeDriveId':
                    return $this->fixtures->getMeDriveId();

                // Get file's property from FixturesCatalog
                case $parts[0] === 'FIXTURES_CATALOG':
                    array_shift($parts);
                    $driveType = (string) array_shift($parts);
                    $fileConst = (string) array_shift($parts);

                    // Get drive
                    switch ($driveType) {
                        case 'DRIVE':
                            $drive = $this->fixtures->getDrive();
                            break;

                        case 'ME_DRIVE':
                            $drive = $this->fixtures->getMeDrive();
                            break;

                        case 'SHAREPOINT_DRIVE':
                            $drive = $this->fixtures->getSharePointDrive();
                            break;

                        default:
                            throw new RuntimeException(sprintf('Unexpected drive type ""%s.', $driveType));
                    }

                    if (!$drive) {
                        throw new SkippedTestError('Required type of "drive" is not present.');
                    }

                    switch ($fileConst) {
                        case 'CREATE_TMP_FILE_PATH':
                            return implode('/', FixturesUtils::createTmpFilePath());

                        case 'TMP_FILE':
                            $fileConst = (string) array_shift($parts);
                            if (isset($this->tmpFiles[$fileConst])) {
                                // Get already uploaded file from cache
                                $file = $this->tmpFiles[$fileConst];
                            } else {
                                // Upload tmp file
                                $localPath = $this->getTestFilePath($fileConst);
                                $file = $this->utils->uploadTmpFile($drive->getDriveId(), $localPath);
                                $this->tmpFiles[$fileConst] = $file;
                                sleep(1);
                            }
                            break;

                        default:
                            // Get already uploaded file
                            $file = $drive->getFile($this->fixturesCatalogRef->getConstant($fileConst));
                    }

                    // Return file property
                    $method = (string) array_shift($parts);
                    $args = array_map(fn($arg) => is_numeric($arg) ? (int) $arg : $arg, $parts);
                    return $file->{$method}(...$args);

                // Return environment variable
                default:
                    $value = getenv($var);
                    if (!$value) {
                        throw new RuntimeException(sprintf('Environment variable "%s" not found.', $var));
                    }
                    return $value;
            }
        }, $content);
    }

    protected function assertMatchesSpecification(
        DatadirTestSpecificationInterface $specification,
        Process $runProcess,
        string $tempDatadir
    ): void {
        // Remove state.json, we cannot check it, it contains a dynamic new tokens, see OAuthTest
        @unlink($tempDatadir . '/out/state.json');

        if ($specification->getExpectedReturnCode() !== null) {
            $this->assertProcessReturnCode($specification->getExpectedReturnCode(), $runProcess);
        } else {
            $this->assertNotSame(0, $runProcess->getExitCode(), 'Exit code should have been non-zero');
        }
        if ($specification->getExpectedStdout() !== null) {
            // Match format, not exact same
            // Filter out InvalidSession retry messages (transient API errors that are automatically retried)
            $actualOutput = $this->filterInvalidSessionRetryMessages($runProcess->getOutput());
            $this->assertStringMatchesFormat(
                trim($specification->getExpectedStdout()),
                trim($actualOutput),
                'Failed asserting stdout output'
            );
        }
        if ($specification->getExpectedStderr() !== null) {
            // Match format, not exact same
            $this->assertStringMatchesFormat(
                trim($specification->getExpectedStderr()),
                trim($runProcess->getErrorOutput()),
                'Failed asserting stderr output'
            );
        }
        if ($specification->getExpectedOutDirectory() !== null) {
            $this->assertDirectoryContentsSame(
                $specification->getExpectedOutDirectory(),
                $tempDatadir . '/out'
            );
        }
    }

    protected function getScript(): string
    {
        return $this->getTestFileDir() . '/../../src/run.php';
    }

    private function getTestFilePath(string $classConst): string
    {
        $localPath = $this->fixturesCatalogRef->getConstant($classConst);
        if (!$localPath) {
            throw new RuntimeException(sprintf('Constant FixtureCatalog::"%s" not found.', $classConst));
        }

        return $localPath;
    }

    private function filterInvalidSessionRetryMessages(string $output): string
    {
        $lines = explode("\n", $output);
        $filteredLines = array_filter($lines, function (string $line): bool {
            // Filter out InvalidSession retry messages
            if (strpos($line, 'Session expired, will recreate and retry.') !== false) {
                return false;
            }
            if (strpos($line, 'InvalidSession:') !== false && strpos($line, 'Retrying...') !== false) {
                return false;
            }
            return true;
        });
        return implode("\n", $filteredLines);
    }
}



================================================
FILE: tests/datadir/DatadirTestsProvider.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\DataDirTests;

use Keboola\DatadirTests\DatadirTestsFromDirectoryProvider;
use Keboola\DatadirTests\DatadirTestSpecification;
use Keboola\DatadirTests\DatadirTestSpecificationInterface;
use Symfony\Component\Finder\SplFileInfo;

class DatadirTestsProvider extends DatadirTestsFromDirectoryProvider
{
    private string $testDirectory;

    /** @var DatadirTestSpecification[][] */
    protected array $datapoints;

    public function __construct(string $testDirectory = 'tests/functional')
    {
        parent::__construct($testDirectory);
        $this->testDirectory = $testDirectory;
    }

    /**
     * @return DatadirTestSpecificationInterface[][]
     */
    public function __invoke(): array
    {
        $this->datapoints = [];
        $this->processDirectory($this->testDirectory);
        return $this->datapoints;
    }

    protected function processOneTest(SplFileInfo $testSuite): void
    {
        $workingDirectory = $testSuite->getPathname();

        $name = $testSuite->getBasename();
        $sourceDatadirDirectory = $workingDirectory . '/source/data';
        $expectedStdoutFile = $workingDirectory . '/expected-stdout';
        $expectedStdout = null;
        $expectedStderrFile = $workingDirectory . '/expected-stderr';
        $expectedStderr = null;
        $expectedReturnCodeFile = $workingDirectory . '/expected-code';
        $expectedReturnCode = null;
        $expectedOutputDirectory = null;
        $outTemplateDir = $workingDirectory . '/expected/data/out';

        // Added, load stdout from file
        if (file_exists($expectedStdoutFile)) {
            $expectedStdout = (string) file_get_contents($expectedStdoutFile);
        }

        // Added, load stderr from file
        if (file_exists($expectedStderrFile)) {
            $expectedStderr = (string) file_get_contents($expectedStderrFile);
        }

        if (file_exists($expectedReturnCodeFile)) {
            $returnCode = trim((string) file_get_contents($expectedReturnCodeFile));
            if (preg_match('~^[012]$~', $returnCode)) {
                $expectedReturnCode = (int) $returnCode;
            } else {
                throw new \InvalidArgumentException(sprintf(
                    '%s: Expecting invalid return code (%s). Possible codes are: 0, 1, 2.',
                    $name,
                    $returnCode
                ));
            }
        }

        if (file_exists($outTemplateDir)) {
            if (is_null($expectedReturnCode)) {
                $expectedReturnCode = 0;
            }
            $expectedOutputDirectory = $outTemplateDir;
        }

        $this->datapoints[$name] = [
            new DatadirTestSpecification(
                $sourceDatadirDirectory,
                $expectedReturnCode,
                $expectedStdout,
                $expectedStderr,
                $expectedOutputDirectory
            ),
        ];
    }
}



================================================
FILE: tests/datadir/create-workbook/expected-stdout
================================================
{"file":{"driveId":"%a","fileId":"%a"}}



================================================
FILE: tests/datadir/create-workbook-already-exists/expected-code
================================================
1



================================================
FILE: tests/datadir/create-workbook-already-exists/expected-stderr
================================================
Workbook "drive://%a/__wr-onedrive-test-folder/valid/one_sheet.xlsx" already exists.



================================================
FILE: tests/datadir/create-worksheet/expected-stdout
================================================
{"worksheet":{"driveId":"%a","fileId":"%a","worksheetId":"%a"}}



================================================
FILE: tests/datadir/create-worksheet-already-exists/expected-code
================================================
1



================================================
FILE: tests/datadir/create-worksheet-already-exists/expected-stderr
================================================
Worksheet "Only One Sheet" already exists.



================================================
FILE: tests/datadir/escape-expression/expected-stdout
================================================
Write data using the session.
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/get-worksheets-by-path/expected-stdout
================================================
{"worksheets":[{"position":0,"name":"Only One Sheet","title":"Only One Sheet","driveId":"%s","fileId":"%s","worksheetId":"%s","visible":true,"header":["Col_1","Col_2","Col_3"]}]}



================================================
FILE: tests/datadir/get-worksheets-empty-sheet/expected-stdout
================================================
{"worksheets":[{"position":0,"name":"Sheet1","title":"Sheet1","driveId":"%s","fileId":"%s","worksheetId":"%s","visible":true,"header":[]}]}



================================================
FILE: tests/datadir/get-worksheets-hidden-sheet/expected-stdout
================================================
{"worksheets":[{"position":0,"name":"Sheet1","title":"Sheet1","driveId":"%s","fileId":"%s","worksheetId":"%s","visible":true,"header":["Col_1","Col_2","Col_3"]},{"position":1,"name":"Zo\u0161it 2","title":"Zo\u0161it 2","driveId":"%s","fileId":"%s","worksheetId":"%s","visible":true,"header":["Col_1","Col_2","Col_3"]},{"position":2,"name":"Hidden Sheet 3","title":"Hidden Sheet 3 (hidden)","driveId":"%s","fileId":"%s","worksheetId":"%s","visible":false,"header":["Col_4","Col_5","Col_6"]},{"position":3,"name":"sheet=4","title":"sheet=4","driveId":"%s","fileId":"%s","worksheetId":"%s","visible":true,"header":["Col_1","Col_2","Col_3"]}]}



================================================
FILE: tests/datadir/get-worksheets-invalid-drive-id/expected-code
================================================
1



================================================
FILE: tests/datadir/get-worksheets-invalid-drive-id/expected-stderr
================================================
Bad request error. Please check configuration. It can be caused by typo in an ID, or resource doesn't exists. API error: InvalidRequest: The provided drive id appears to be malformed, or does not represent a valid drive.



================================================
FILE: tests/datadir/get-worksheets-invalid-file-id/expected-code
================================================
1



================================================
FILE: tests/datadir/get-worksheets-invalid-file-id/expected-stderr
================================================
Configured workbook XLSX file not found.



================================================
FILE: tests/datadir/get-worksheets-invalid-file-type/expected-code
================================================
1



================================================
FILE: tests/datadir/get-worksheets-invalid-file-type/expected-stderr
================================================
It looks like the specified file is not in the "XLSX" Excel format. Error: "AccessDenied: Could not obtain a WAC access token."



================================================
FILE: tests/datadir/get-worksheets-many-sheets/expected-stdout
================================================
{"worksheets":[{%A"Sheet1"%A"Sheet25"%A}]}



================================================
FILE: tests/datadir/get-worksheets-not-found-drive-id/expected-code
================================================
1



================================================
FILE: tests/datadir/get-worksheets-not-found-drive-id/expected-stderr
================================================
Configured workbook XLSX file not found.



================================================
FILE: tests/datadir/get-worksheets-not-found-file-id/expected-code
================================================
1



================================================
FILE: tests/datadir/get-worksheets-not-found-file-id/expected-stderr
================================================
Bad request error. Please check configuration. It can be caused by typo in an ID, or resource doesn't exists. API error: InvalidRequest: Invalid request



================================================
FILE: tests/datadir/get-worksheets-one-sheet/expected-stdout
================================================
{"worksheets":[{"position":0,"name":"Only One Sheet","title":"Only One Sheet","driveId":"%s","fileId":"%s","worksheetId":"%s","visible":true,"header":["Col_1","Col_2","Col_3"]}]}



================================================
FILE: tests/datadir/search-file-path-drive/expected-stdout
================================================
{"file":{"driveId":"%s","fileId":"%s","name":"one_sheet.xlsx","path":"__wr-onedrive-test-folder\/valid"}}



================================================
FILE: tests/datadir/search-file-path-drive-me/expected-stdout
================================================
{"file":{"driveId":"%s","fileId":"%s","name":"one_sheet.xlsx","path":"my\/__wr-onedrive-test-folder\/valid"}}



================================================
FILE: tests/datadir/search-file-path-drive-site/expected-stdout
================================================
{"file":{"driveId":"%s","fileId":"%s","name":"one_sheet.xlsx","path":"sites\/%s\/__wr-onedrive-test-folder\/valid"}}



================================================
FILE: tests/datadir/search-file-path-not-found/expected-stdout
================================================
{"file":null}



================================================
FILE: tests/datadir/search-sharing-link/expected-stdout
================================================
{"file":{"driveId":"%s","fileId":"%s","name":"one_sheet.xlsx","path":"__wr-onedrive-test-folder\/valid"}}



================================================
FILE: tests/datadir/search-sharing-link-not-found/expected-code
================================================
1



================================================
FILE: tests/datadir/search-sharing-link-not-found/expected-stderr
================================================
The sharing link "https://example.com/a/b/c/not/fo..." not exists, or you do not have permission to access it.



================================================
FILE: tests/datadir/write-append-empty-file/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Sheet1" at position "0".
Found input CSV file "input-file.csv".
Sheet is empty.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-append-hidden-sheet/expected-stderr
================================================
Headers mismatch. Ignored new header: "Col1", "Col2", "Col3"



================================================
FILE: tests/datadir/write-append-hidden-sheet/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Hidden Sheet 3" at position "2".
Found input CSV file "input-file.csv".
Current sheet range: "A48:C50"
Current sheet header "A48:C48": "Col_4", "Col_5", "Col_6"
Inserted 2 rows.




================================================
FILE: tests/datadir/write-append-one-sheet-file/expected-stderr
================================================
Headers mismatch. Ignored new header: "Col1", "Col2", "Col3"



================================================
FILE: tests/datadir/write-append-one-sheet-file/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Current sheet range: "A1:C3"
Current sheet header "A1:C1": "Col_1", "Col_2", "Col_3"
Inserted 2 rows.




================================================
FILE: tests/datadir/write-empty-csv-file/expected-stderr
================================================
Ignored empty CSV file "input-file.csv".



================================================
FILE: tests/datadir/write-empty-csv-file/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Sheet1" at position "0".
Found input CSV file "input-file.csv".



================================================
FILE: tests/datadir/write-file-invalid-drive-id/expected-code
================================================
1



================================================
FILE: tests/datadir/write-file-invalid-drive-id/expected-stderr
================================================
Bad request error. Please check configuration. It can be caused by typo in an ID, or resource doesn't exists. API error: InvalidRequest: The provided drive id appears to be malformed, or does not represent a valid drive.



================================================
FILE: tests/datadir/write-file-invalid-file-id/expected-code
================================================
1



================================================
FILE: tests/datadir/write-file-invalid-file-id/expected-stderr
================================================
Configured workbook XLSX file not found.



================================================
FILE: tests/datadir/write-file-not-found-drive-id/expected-code
================================================
1



================================================
FILE: tests/datadir/write-file-not-found-drive-id/expected-stderr
================================================
Configured workbook XLSX file not found.



================================================
FILE: tests/datadir/write-file-not-found-file-id/expected-code
================================================
1



================================================
FILE: tests/datadir/write-file-not-found-file-id/expected-stderr
================================================
Bad request error. Please check configuration. It can be caused by typo in an ID, or resource doesn't exists. API error: InvalidRequest: Invalid request



================================================
FILE: tests/datadir/write-file-path-drive/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-file-path-drive-me/expected-stdout
================================================
Searching for "%a.xlsx" in personal OneDrive.
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-file-path-drive-site/expected-stdout
================================================
Searching for "%a.xlsx" in site "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-file-path-not-found-created-append/expected-stdout
================================================
Searching for "%a" in personal OneDrive.
Write data using the session.
New workbook "%a" created.
Found worksheet "New" at position "0".
Found input CSV file "input-file.csv".
Sheet renamed to "Sheet Test Name".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-file-path-not-found-created-overwrite/expected-stdout
================================================
Searching for "%a" in personal OneDrive.
Write data using the session.
New workbook "%a" created.
Found worksheet "New" at position "0".
Found input CSV file "input-file.csv".
Sheet renamed to "Sheet Test Name".
Sheet is empty.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-multiple-csv-files/expected-code
================================================
1



================================================
FILE: tests/datadir/write-multiple-csv-files/expected-stderr
================================================
Expected one CSV file, found multiple: "file%d.csv", "file%d.csv".



================================================
FILE: tests/datadir/write-no-csv-file/expected-code
================================================
1



================================================
FILE: tests/datadir/write-no-csv-file/expected-stderr
================================================
No CSV file found in "/%a/in/tables".



================================================
FILE: tests/datadir/write-overwrite-empty-file/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Sheet1" at position "0".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-overwrite-hidden-sheet/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Hidden Sheet 3" at position "2".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-overwrite-one-sheet-file/expected-stdout
================================================
Searching for "%a.xlsx" in drive "%a".
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-rename-sheet/expected-stdout
================================================
Searching for "%a.xlsx" in personal OneDrive.
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Sheet renamed to "New Sheet Name".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-same-sheet-name/expected-stdout
================================================
Searching for "%a.xlsx" in personal OneDrive.
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-sheet-by-id/expected-stdout
================================================
Write data using the session.
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-sheet-by-name-found/expected-stdout
================================================
Searching for "%a.xlsx" in personal OneDrive.
Write data using the session.
Found workbook "%a.xlsx".
Found worksheet "Only One Sheet" at position "0".
Found input CSV file "input-file.csv".
Sheet cleared.
Inserted 3 rows.



================================================
FILE: tests/datadir/write-sheet-by-name-not-found-created-append/expected-stdout
================================================
Searching for "%a.xlsx" in personal OneDrive.
Write data using the session.
Found workbook "%a.xlsx".
New sheet "Not Found Sheet" created.
Found input CSV file "input-file.csv".
Inserted 3 rows.



================================================
FILE: tests/datadir/write-sheet-by-name-not-found-created-overwrite/expected-stdout
================================================
Searching for "%a.xlsx" in personal OneDrive.
Write data using the session.
Found workbook "%a.xlsx".
New sheet "Not Found Sheet" created.
Found input CSV file "input-file.csv".
Inserted 3 rows.



================================================
FILE: tests/fixtures/Drive.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Fixtures;

use InvalidArgumentException;

class Drive
{
    private string $driveId;

    private array $files = [];

    public function __construct(string $driveId, array $files)
    {
        assert(strlen($driveId) > 0);
        $this->driveId = $driveId;
        $this->files = $files;
    }

    public function getDriveId(): string
    {
        return $this->driveId;
    }

    public function getFile(string $path): File
    {
        if (isset($this->files[$path])) {
            return $this->files[$path];
        }
        throw new InvalidArgumentException(sprintf('Fixture file "%s" not found.', $path));
    }

    public function addFile(File $file): void
    {
        $this->files[$file->getPath()] = $file;
    }
}



================================================
FILE: tests/fixtures/File.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Fixtures;

use RuntimeException;

class File
{
    private FixturesUtils $utils;

    private string $path;

    private string $driveId;

    private string $fileId;

    private string $sharingLink;

    private array $worksheetIds;

    public function __construct(string $path, string $driveId, string $fileId, string $sharingLink, array $worksheetIds)
    {
        assert(strlen($path) > 0);
        assert(strlen($driveId) > 0);
        assert(strlen($fileId) > 0);
        assert(strlen($sharingLink) > 0);
        $this->path = $path;
        $this->driveId = $driveId;
        $this->fileId = $fileId;
        $this->sharingLink = $sharingLink;
        $this->worksheetIds = $worksheetIds;
    }

    public function getPath(): string
    {
        return $this->path;
    }

    public function getName(): string
    {
        return basename($this->path);
    }

    public function getNameWithoutExt(): string
    {
        return pathinfo($this->path, PATHINFO_FILENAME);
    }

    public function getDir(): string
    {
        return dirname($this->path);
    }

    public function getDriveId(): string
    {
        return $this->driveId;
    }

    public function getFileId(): string
    {
        return $this->fileId;
    }

    public function getSharingLink(): string
    {
        return $this->sharingLink;
    }

    public function getWorksheetIds(): array
    {
        return $this->worksheetIds;
    }

    public function getWorksheetId(int $position): string
    {
        if (empty($this->worksheetIds)) {
            throw new RuntimeException(sprintf('File "%s" has no worksheets.', $this->getPath()));
        }

        if (!isset($this->worksheetIds[$position])) {
            throw new RuntimeException(sprintf('File "%s" has no worksheet "%d".', $this->getPath(), $position));
        }

        return $this->worksheetIds[$position];
    }
}



================================================
FILE: tests/fixtures/FixturesApi.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Fixtures;

use ArrayObject;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use Keboola\OneDriveWriter\Api\Api;
use Keboola\OneDriveWriter\Api\GraphApiFactory;
use Keboola\OneDriveWriter\Api\Helpers;
use Keboola\OneDriveWriter\Auth\RefreshTokenProvider;
use Keboola\OneDriveWriter\Auth\TokenDataManager;
use Keboola\OneDriveWriter\Exception\BatchRequestException;
use Psr\Log\NullLogger;
use Retry\BackOff\ExponentialBackOffPolicy;
use Retry\Policy\CallableRetryPolicy;
use Retry\RetryProxy;
use Microsoft\Graph\Graph;
use Microsoft\Graph\Http\GraphResponse;

class FixturesApi
{
    private const RETRY_HTTP_CODES = Api::RETRY_HTTP_CODES + [401, 404];

    private Graph $graphApi;

    public function __construct()
    {
        $this->graphApi = $this->createGraphApi();
    }

    public function getGraph(): Graph
    {
        return $this->graphApi;
    }

    public function get(string $uri, array $params = []): GraphResponse
    {
        return $this->executeWithRetry('GET', $uri, $params);
    }

    public function post(string $uri, array $params = [], array $body = []): GraphResponse
    {
        return $this->executeWithRetry('POST', $uri, $params, $body);
    }

    public function delete(string $uri, array $params = []): GraphResponse
    {
        return $this->executeWithRetry('DELETE', $uri, $params);
    }

    public function executeWithRetry(string $method, string $uri, array $params = [], array $body = []): GraphResponse
    {
        $proxy = $this->createRetryProxy();
        return $proxy->call(function () use ($method, $uri, $params, $body) {
            return $this->execute($method, $uri, $params, $body);
        });
    }

    public function createRetryProxy(): RetryProxy
    {
        $backOffPolicy = new ExponentialBackOffPolicy(500, 2.0, 5000);
        $retryPolicy = new CallableRetryPolicy(function (\Throwable $e) {
            // Retry on connect exception, eg. Could not resolve host: login.microsoftonline.com
            if ($e instanceof ConnectException) {
                return true;
            }

            if ($e instanceof RequestException || $e instanceof BatchRequestException) {
                // Retry only on defined HTTP codes
                if (in_array($e->getCode(), self::RETRY_HTTP_CODES, true)) {
                    return true;
                }

                // Retry if communication problems
                if (strpos($e->getMessage(), 'There were communication or server problems') !== false) {
                    return true;
                }

                // Retry if resource modified
                if (strpos($e->getMessage(), 'The resource has changed') !== false) {
                    return true;
                }
            }

            return false;
        }, Api::RETRY_MAX_ATTEMPTS);

        return new RetryProxy($retryPolicy, $backOffPolicy);
    }

    public function execute(string $method, string $uri, array $params = [], array $body = []): GraphResponse
    {
        $uri = Helpers::replaceParamsInUri($uri, $params);
        $request = $this->graphApi->createRequest($method, $uri);
        if ($body) {
            $request->attachBody($body);
        }

        try {
            return $request->execute();
        } catch (RequestException $e) {
            throw Helpers::processRequestException($e);
        }
    }

    public function pathToUrl(string $driveId, string $path): string
    {
        $driveId = urlencode($driveId);
        $path = Helpers::convertPathToApiFormat($path);
        return "/drives/{$driveId}/root{$path}";
    }

    private function createGraphApi(): Graph
    {
        $appId = (string) getenv('OAUTH_APP_ID');
        $appSecret = (string) getenv('OAUTH_APP_SECRET');
        $accessToken = (string) getenv('OAUTH_ACCESS_TOKEN');
        $refreshToken = (string) getenv('OAUTH_REFRESH_TOKEN');
        $oauthData = [
            'access_token' => $accessToken,
            'refresh_token' => $refreshToken,
        ];
        $dataManager = new TokenDataManager($oauthData, new ArrayObject());
        $tokenProvider = new RefreshTokenProvider($appId, $appSecret, null, $dataManager, new NullLogger());
        $apiFactory = new GraphApiFactory();
        return $apiFactory->create($tokenProvider->get());
    }
}



================================================
FILE: tests/fixtures/FixturesCatalog.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Fixtures;

use Keboola\OneDriveWriter\Exception\ResourceNotFoundException;
use RuntimeException;

/**
 * This class stores metadata about fixtures stored in OneDrive.
 * Fixtures are uploaded at initialization from bootstrap.php.
 * Then are metadata loaded from file in functional tests.
 */
class FixturesCatalog
{
    public const
        CATALOG_FILE = __DIR__ . '/.fixturesCatalog',
        DATA_DIR = __DIR__ . '/data',
        BASE_DIR = '/__wr-onedrive-test-folder',
        TMP_DIR = self::BASE_DIR . '/tmp',
        // Valid
        FILE_EMPTY = self::BASE_DIR . '/valid/empty.xlsx',
        FILE_HIDDEN_SHEET = self::BASE_DIR . '/valid/hidden_sheet.xlsx',
        FILE_ONE_SHEET = self::BASE_DIR . '/valid/one_sheet.xlsx',
        FILE_MANY_SHEETS = self::BASE_DIR . '/valid/many_sheets.xlsx',
        FILE_ONLY_HEADER = self::BASE_DIR . '/valid/only_header.xlsx',
        FILE_ONLY_ONE_COLUMN = self::BASE_DIR . '/valid/only_one_column.xlsx',
        FILE_SPECIAL_CASES = self::BASE_DIR . '/valid/special_cases.xlsx',
        FILE_TABLE_OFFSET = self::BASE_DIR . '/valid/table_offset.xlsx',
        // Invalid
        FILE_CSV = self::BASE_DIR . '/invalid/csv_type.csv',
        FILE_ODS = self::BASE_DIR . '/invalid/ods_type.ods',
        FILE_ODT = self::BASE_DIR . '/invalid/odt_type.odt',
        FILE_XLS = self::BASE_DIR . '/invalid/xls_type.xls';

    private Drive $meDrive;

    private ?string $sharePointSiteName;

    private ?Drive $sharePointDrive;

    private string $envHash;

    public static function initialize(): void
    {
        // Initialization is slow, run only once
        $envHash = self::generateEnvHash();
        if (file_exists(self::CATALOG_FILE)) {
            $catalog = self::load();
            if ($envHash === $catalog->getEnvHash()) {
                // No changes in environment => initialization is not needed
                return;
            }
        }

        $utils = new FixturesUtils();

        // Info
        FixturesUtils::log('');
        FixturesUtils::log('Uploading fixtures to OneDrive');
        FixturesUtils::log('PLEASE CLOSE ALL OPENED FILES ON OneDrive!!!');

        // Me drive
        $meDriveId = $utils->getMeDriveId();
        FixturesUtils::log('');
        FixturesUtils::log('Uploading fixtures to me Drive:');
        $meDriveFiles = iterator_to_array($utils->uploadRecursive($meDriveId, __DIR__ . '/data'));
        $meDrive = new Drive($meDriveId, $meDriveFiles);

        // Share point drive
        /** @var string|null $sharePointSiteName */
        $sharePointSiteName = getenv('TEST_SHAREPOINT_SITE') ?: null;
        if ($sharePointSiteName) {
            FixturesUtils::log('');
            FixturesUtils::log('Env variable TEST_SHAREPOINT_SITE is set.');
            FixturesUtils::log("Loading drive id for SharePoint site: \"{$sharePointSiteName}\"");
            FixturesUtils::log('Uploading fixtures to SharePoint drive:');
            $sharePointDriveId = $utils->getSharePointSiteDriveId($sharePointSiteName);
            $sharePointDriveFiles = iterator_to_array($utils->uploadRecursive($sharePointDriveId, __DIR__ . '/data'));
            $sharePointDrive = new Drive($sharePointDriveId, $sharePointDriveFiles);
        } else {
            FixturesUtils::log('');
            FixturesUtils::log('Env variable TEST_SHAREPOINT_SITE is not set.');
            FixturesUtils::log('SKIPPED upload of fixtures to SharePoint drive.');
            $sharePointSiteName = null;
            $sharePointDrive = null;
        }

        $catalog = new self($meDrive, $sharePointSiteName, $sharePointDrive, $envHash);
        $catalog->store();

        FixturesUtils::log('sleep 60s');
        sleep(60);
    }

    public static function load(): self
    {
        if (!file_exists(self::CATALOG_FILE)) {
            throw new RuntimeException(
                'FixturesCatalog is not initialized. You should call initialize() from bootstrap.php.'
            );
        }

        $catalog = unserialize((string) file_get_contents(self::CATALOG_FILE));
        assert($catalog instanceof self);
        $catalog->clearTmp();

        return $catalog;
    }

    public function store(): void
    {
        file_put_contents(self::CATALOG_FILE, serialize($this));
    }

    public function clearTmp(): void
    {
        $api = new FixturesApi();
        try {
            $api->delete($api->pathToUrl($this->getMeDriveId(), self::TMP_DIR));
        } catch (\Throwable $e) {
            FixturesUtils::log(
                'Warning, cannot clear tmp dir in site drive. Probably API random lock problem.'
            );
        }

        $sharePointDrive = $this->getSharePointDrive();
        if ($sharePointDrive) {
            try {
                $api->delete($api->pathToUrl($sharePointDrive->getDriveId(), self::TMP_DIR));
            } catch (\Throwable $e) {
                FixturesUtils::log(
                    'Warning, cannot clear tmp dir in site drive. Probably API random lock problem.'
                );
            }
        }
    }

    protected function __construct(Drive $meDrive, ?string $siteName, ?Drive $siteDrive, string $envHash)
    {
        $this->meDrive = $meDrive;
        $this->sharePointSiteName = $siteName;
        $this->sharePointDrive = $siteDrive;
        $this->envHash = $envHash;
    }

    public function getDrive(): Drive
    {
        return $this->getSharePointDrive() ?? $this->getMeDrive();
    }

    public function getDriveId(): string
    {
        return $this->getDrive()->getDriveId();
    }

    public function getMeDrive(): Drive
    {
        return $this->meDrive;
    }

    public function getMeDriveId(): string
    {
        return $this->meDrive->getDriveId();
    }

    public function getSharePointSiteName(): ?string
    {
        return $this->sharePointSiteName;
    }

    public function getSharePointDrive(): ?Drive
    {
        return $this->sharePointDrive;
    }

    public function getEnvHash(): string
    {
        return $this->envHash;
    }

    private static function generateEnvHash(): string
    {
        $envFingerPrint = getenv('TEST_SHAREPOINT_SITE') ?? ''; // TEST_SHAREPOINT_SITE is optional

        $requiredEnVars = [
            'OAUTH_APP_NAME',
            'OAUTH_APP_ID',
            'OAUTH_APP_SECRET',
            'OAUTH_ACCESS_TOKEN',
            'OAUTH_REFRESH_TOKEN',
        ];

        // Check environment and create env hash
        foreach ($requiredEnVars as $var) {
            $value = getenv($var);
            if (empty($value)) {
                throw new RuntimeException(sprintf('Missing environment var "%s".', $var));
            }
            $envFingerPrint .= $var . ':' . $value . '|';
        }

        return md5($envFingerPrint);
    }
}



================================================
FILE: tests/fixtures/FixturesUtils.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Fixtures;

use Iterator;
use Throwable;
use RuntimeException;
use GuzzleHttp\Exception\ClientException;
use Microsoft\Graph\Model;
use Symfony\Component\Finder\Finder;
use Keboola\OneDriveWriter\Api\Helpers;

class FixturesUtils
{
    private static bool $logEnabled = true;

    private FixturesApi $api;

    public static function disableLog(): void
    {
        self::$logEnabled = false;
    }

    public static function log(string $text): void
    {
        if (self::$logEnabled) {
            echo empty($text) ? "\n" : "FixturesUtils: {$text}\n";
        }
    }

    public static function createTmpFilePath(?string $name = null): array
    {
        $drivePath = FixturesCatalog::TMP_DIR;
        if (!$name) {
            $name = 'tmp_' . substr(uniqid(), 0, 16) . '.xlsx';
        }
        return [$drivePath, $name];
    }

    public function __construct()
    {
        $this->api = new FixturesApi();
    }

    public function getMeDriveId(): string
    {
        $response = $this->api->get('/me/drive?$select=id');
        $body = $response->getBody();
        return $body['id'];
    }

    public function getSharePointSiteDriveId(string $siteName): string
    {
        // Load site
        $uri = '/sites?search={siteName}&$select=id,name';
        $body = $this->api->get($uri, ['siteName' => $siteName])->getBody();
        $sites = $body['value'];
        if (count($body['value']) === 0) {
            throw new RuntimeException(sprintf(
                'SharePoint site "%s" not found.',
                $siteName
            ));
        } elseif (count($body['value']) > 1) {
            throw new RuntimeException(sprintf(
                'Multiple SharePoint sites "%s" found when searching for "%s".',
                implode('", "', array_map(fn(array $site) => $site['name'], $sites)),
                $siteName
            ));
        }

        // Load drive id
        $siteId = $body['value'][0]['id'];
        $uri = '/sites/{siteId}/drive?$select=id';
        $body = $this->api->get($uri, ['siteId' => $siteId])->getBody();
        return $body['id'];
    }

    public function uploadRecursive(string $driveId, string $relativePath): Iterator
    {
        // Upload file structure, folders are created automatically
        $finder = new Finder();
        foreach ($finder->files()->in($relativePath)->getIterator() as $item) {
            $localPath = $item->getPathname();
            $relativePath = '/' . $item->getRelativePath();
            $relativePath = $relativePath !== '/' ? $relativePath : '';
            $name = $item->getFilename();

            // API sometimes accidentally returns an error, retry!
            $retry = 3;
            while (true) {
                try {
                    $file = $this->uploadFile($driveId, $localPath, $relativePath, $name);
                    yield $file->getPath() => $file;
                    break;
                } catch (Throwable $e) {
                    // Delete file, can be partially uploaded
                    if ($retry === 3) {
                        try {
                            $url = $this->api->pathToUrl($driveId, $relativePath . '/' . $name);
                            $this->api->delete($url);
                        } catch (Throwable $e) {
                            // ignore if file not exits
                        }
                    }

                    if ($retry-- <= 0) {
                        throw $e;
                    }
                }
            }
        }
    }

    public function uploadTmpFile(string $driveId, string $localPath, ?string $name = null): File
    {
        $localPath = FixturesCatalog::DATA_DIR . '/' . ltrim($localPath, '/');
        [$drivePath, $name] = self::createTmpFilePath($name);
        return $this->uploadFile($driveId, $localPath, $drivePath, $name);
    }

    public function uploadFile(string $driveId, string $localPath, string $drivePath, string $name): File
    {
        // The size of each byte range MUST be a multiple of 320 KiB
        // https://docs.microsoft.com/cs-cz/graph/api/driveitem-createuploadsession?view=graph-rest-1.0#upload-bytes-to-the-upload-session
        $uploadFragSize = 320 * 1024 * 10; // 3.2 MiB
        $fileSize = filesize($localPath);
        $path = $drivePath . '/' . $name;
        $url = $this->api->pathToUrl($driveId, $drivePath . '/' . $name);

        // Create upload session
        $retryProxy = $this->api->createRetryProxy();
        /** @var Model\UploadSession $uploadSession */
        $uploadSession = $retryProxy->call(function () use ($url) {
            return $this
                ->api
                ->getGraph()
                ->createRequest('POST', $url . 'createUploadSession')
                ->attachBody(['@microsoft.graph.conflictBehavior'=> 'replace' ])
                ->setReturnType(Model\UploadSession::class)
                ->setTimeout('1000')
                ->execute();
        });

        // Upload file in parts
        $file = fopen($localPath, 'r');
        if (!$file) {
            throw new RuntimeException(sprintf('Cannot open file "%s".', $localPath));
        }
        try {
            while (!feof($file)) {
                $start = ftell($file);
                $data = fread($file, $uploadFragSize);
                $end = ftell($file);
                $uploadSession = $retryProxy->call(function () use ($uploadSession, $start, $end, $fileSize, $data) {
                    return $this
                        ->api
                        ->getGraph()
                        ->createRequest('PUT', $uploadSession->getUploadUrl())
                        ->addHeaders([
                            'Authorization' => '',
                            'Content-Length' => $end - $start,
                            'Content-Range' => sprintf('bytes %d-%d/%d', $start, $end-1, $fileSize),
                        ])
                        ->attachBody($data)
                        ->setReturnType(Model\UploadSession::class)
                        ->setTimeout('1000')
                        ->execute();
                });
            }
        } finally {
            fclose($file);
        }

        // Uploaded
        $fileId = $uploadSession->getId();
        FixturesUtils::log(sprintf('"%s" - uploaded', $path));

        // Create sharing link (for search by url tests)
        $linkBody = $this->api->post($url . 'createLink', ['type' => 'view', 'scope' => 'organization'])->getBody();
        $sharingLink = $linkBody['link']['webUrl'];
        FixturesUtils::log(sprintf('"%s" - created sharing link', $path));

        // Load worksheets if XLSX file
        $worksheets = iterator_to_array($this->loadWorksheets($path, $driveId, $fileId));
        return new File($path, $driveId, $fileId, $sharingLink, $worksheets);
    }

    public function delete(string $driveId, string $path): bool
    {
        try {
            $this->api->delete($this->api->pathToUrl($driveId, $path));
            FixturesUtils::log(sprintf('"%s" - deleted', $path));
            return true;
        } catch (ClientException $e) {
            return false;
        }
    }

    public function getWorksheetContent(File $file, int $worksheet): WorksheetContent
    {
        $endpoint = '/drives/{driveId}/items/{fileId}/workbook/worksheets/{worksheetId}';
        $uri = $endpoint . '/usedRange(valuesOnly=true)?$select=address,text';
        $args = [
            'driveId' => $file->getDriveId(),
            'fileId' => $file->getFileId(),
            'worksheetId' => $file->getWorksheetId($worksheet)]
        ;

        // Get rows
        $body = $this->api->get(Helpers::replaceParamsInUri($uri, $args))->getBody();
        $rows = $body['text'];

        // If empty file, empty first cell is returned
        $empty = isset($rows[0][0]) && count($rows) === 1 && count($rows[0]) === 1 && $rows[0][0] === '';
        $rows = $empty ? [] : $rows;

        return new WorksheetContent($body['address'], $rows);
    }

    public function loadWorksheets(string $path, string $driveId, string $fileId): Iterator
    {
        if (preg_match('~\.xlsx$~', $path)) {
            $uri = '/drives/{driveId}/items/{fileId}/workbook/worksheets?$select=id,position';
            $args = ['driveId' => $driveId, 'fileId' => $fileId];
            $body = $worksheetsResponse = $this->api->get($uri, $args)->getBody();
            foreach ($body['value'] as $item) {
                yield $item['position'] => $item['id'];
            }
            FixturesUtils::log(sprintf('"%s" - loaded worksheet ids', $path));
        }
    }
}



================================================
FILE: tests/fixtures/WorksheetContent.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Fixtures;

use Keboola\OneDriveWriter\Api\Model\TableRange;

class WorksheetContent
{
    private TableRange $range;

    private array $rows;

    public function __construct(string $address, array $rows)
    {
        $this->range = TableRange::from($address);
        $this->rows = $rows;
    }

    public function getRange(): TableRange
    {
        return $this->range;
    }

    public function getRows(): array
    {
        return $this->rows;
    }

    public function isEmpty(): bool
    {
        return empty($this->rows);
    }
}



================================================
FILE: tests/phpunit/ErrorResponseHandlingTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests;

use ArrayObject;
use Generator;
use GuzzleHttp\Psr7\Response;
use Keboola\OneDriveWriter\Api\Api;
use Keboola\OneDriveWriter\Api\GraphApiFactory;
use Keboola\OneDriveWriter\Auth\RefreshTokenProvider;
use Keboola\OneDriveWriter\Auth\TokenDataManager;
use Keboola\OneDriveWriter\Exception\GatewayTimeoutException;
use Keboola\OneDriveWriter\Exception\UserException;
use Microsoft\Graph\Graph;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\TestCase;
use Psr\Log\LoggerInterface;
use Psr\Log\Test\TestLogger;
use Throwable;

class ErrorResponseHandlingTest extends TestCase
{
    /**
     * @dataProvider dataProviderBatchRequest
     * @param Response[] $responses
     */
    public function testErrorResponseHandlingOnBatchRequest(
        array $responses,
        string $expectedMessage,
        bool $checkIfRetries
    ): void {

        $logger = new TestLogger();
        try {
            $graphApi = $this->createGraphApi($logger);
            $api = new Api($graphApi, $logger);
            $httpClient = HttpClientMockBuilder::create()->setResponses($responses)->getHttpClient();
            $api->setHttpClient($httpClient);
            iterator_to_array($api->getSheets('1', '1'));
            $this->fail('Should fail');
        } catch (UserException $exception) {
            Assert::assertEquals($expectedMessage, $exception->getMessage());
        }

        if ($checkIfRetries) {
            $this->assertTrue($logger->hasInfoThatContains(
                sprintf('Retrying... [%dx]', Api::RETRY_MAX_ATTEMPTS - 1)
            ));
        }
    }

    /**
     * @dataProvider dataProviderRequest
     * @param Response[] $responses
     * @param class-string $errorClass
     */
    public function testErrorResponseHandlingRequest(
        array $responses,
        string $errorClass,
        string $expectedMessage,
        bool $checkIfRetries
    ): void {
        $logger = new TestLogger();
        $graphApi = $this->createGraphApi($logger);
        $api = new Api($graphApi, $logger);
        $httpClient = HttpClientMockBuilder::create()->setResponses($responses)->getHttpClient();
        $api->setHttpClient($httpClient);

        try {
            $api->getSite('test');
        } catch (Throwable $e) {
            $this->assertInstanceOf($errorClass, $e);
            $this->assertSame($expectedMessage, $e->getMessage());
        }

        if ($checkIfRetries) {
            $this->assertTrue($logger->hasInfoThatContains(
                sprintf('Retrying... [%dx]', Api::RETRY_MAX_ATTEMPTS - 1)
            ));
        }
    }

    private function createGraphApi(LoggerInterface $logger): Graph
    {
        $appId = (string) getenv('OAUTH_APP_ID');
        $appSecret = (string) getenv('OAUTH_APP_SECRET');
        $accessToken = (string) getenv('OAUTH_ACCESS_TOKEN');
        $refreshToken = (string) getenv('OAUTH_REFRESH_TOKEN');
        $oauthData = [
            'access_token' => $accessToken,
            'refresh_token' => $refreshToken,
        ];
        $dataManager = new TokenDataManager($oauthData, new ArrayObject());
        $tokenProvider = new RefreshTokenProvider($appId, $appSecret, null, $dataManager, $logger);
        $apiFactory = new GraphApiFactory();
        return $apiFactory->create($tokenProvider->get());
    }

    /**
     * @return Generator<string, mixed>
     */
    public function dataProviderBatchRequest(): Generator
    {
        yield 'Workbook 500 error' => [
            'responses' => [
                $this->getLoadSheetListSuccessResponse(),
                $this->getBatchErrorResponse(
                    503,
                    'GenericFileOpenError',
                    'The workbook cannot be opened.'
                ),
            ],
            'expectedMessage' => 'OneDrive API error: The workbook cannot be opened. Make sure nobody is editing it.',
            'checkIfRetires' => false,
        ];

        yield 'Service unavailable 503 error' => [
            'responses' => [
                $this->getLoadSheetListSuccessResponse(),
                $this->getBatchErrorResponse(
                    503,
                    'UnknownError',
                    'The service is unavailable.'
                ),
            ],
            'expectedMessage' => 'OneDrive API error: The service is unavailable.',
            'checkIfRetires' => false,
        ];

        $responses = [
            $this->getLoadSheetListSuccessResponse(),
        ];

        array_push(
            $responses,
            ...array_fill(
                0,
                Api::RETRY_MAX_ATTEMPTS,
                $this->getBatchErrorResponse(504, 'MaxRequestDurationExceeded', "We'" .
                    "re sorry. We couldn't finish what you asked us to do because it was taking too long.")
            )
        );
        yield 'Request took to long 504 error' => [
            'responses' => $responses,
            'expectedMessage' => 'OneDrive API error: Request took too long.',
            'checkIfRetires' => true,
        ];
    }

    protected function getLoadSheetListSuccessResponse(): Response
    {
        return new Response(200, [], '{"@odata.context":"https:\/\/graph.microsoft.com\/v1.0\/' .
            '$metadata#drives(\'b%21nZgsjp3RK0aRFp01PZWjKUicqho1KehCtKM1UhLEWybvgM_dt6mJRKV57vuJLf4Q\')\/items' .
            '(\'01GQDMCCOULCHLF6PJD5FI3CH4OWOP4ZLR\')\/workbook\/worksheets(id,position,name,visibility)","value"' .
            ':[{"@odata.id":"\/drives(\'b%21nZgsjp3RK0aRFp01PZWjKUicqho1KehCtKM1UhLEWybvgM_dt6mJRKV57vuJLf4Q\')\/' .
            'items(\'01GQDMCCOULCHLF6PJD5FI3CH4OWOP4ZLR\')\/workbook\/worksheets(%27%7B00000000-0001-0000-0000-0000' .
            '00000000%7D%27)","id":"{00000000-0001-0000-0000-000000000000}","name":"Only One Sheet","position":0,' .
            '"visibility":"Visible"}]}');
    }

    protected function getBatchErrorResponse(int $statusCode, string $errorCode, string $errorMessage): Response
    {
        return new Response(200, [], sprintf('
                    {
                      "responses": [
                            {
                              "id": "1",
                              "status": %d,
                              "body": {
                                "error": {
                                  "code": "%s",
                                  "message": "%s"
                                }
                              }
                            }
                        ]
                    }', $statusCode, $errorCode, $errorMessage));
    }

    /**
     * @return Generator<string, mixed>
     */
    public function dataProviderRequest(): Generator
    {
        yield 'Retry-After over maximum limit' => [
            'responses' => $this->get429Responses(['Retry-After' => [Api::MAX_INTERVAL + 1]]),
            'errorClass' => UserException::class,
            'expectedMessage' => sprintf('OneDrive API error: Too many requests. Retry-After (%d seconds) ' .
                'exceeded maximum retry interval (%d seconds)', Api::MAX_INTERVAL + 1, Api::MAX_INTERVAL),
            'checkIfRetires' => false,
        ];

        yield 'Retry-After within maximum limit' => [
            'responses' => $this->get429Responses(['Retry-After' => [1000]], 15),
            'errorClass' => UserException::class,
            'expectedMessage' => 'OneDrive API error: Too many requests.',
            'checkIfRetires' => true,
        ];

        yield 'Too many request without Retry-After header' => [
            'responses' => $this->get429Responses([], 15),
            'errorClass' => UserException::class,
            'expectedMessage' => 'OneDrive API error: Too many requests.',
            'checkIfRetires' => true,
        ];

        yield '504 Gateway Timeout' => [
            'responses' => $this->get504Responses(15),
            'errorClass' => GatewayTimeoutException::class,
            'expectedMessage' => 'Gateway Timeout Error. The Microsoft OneDrive API has some problems. Please try ' .
                'again later. API message: Server error: `GET v1.0/sites?search=test&$select=id,name` resulted in a ' .
                '`504 Gateway Time-out` response:
 (truncated...)
',
            'checkIfRetires' => true,
        ];

        yield 'Access denied' => [
            'responses' => [new Response(403, [], '{
                "error": {
                    "code":"accessDenied",
                    "message":"Access denied",
                    "innerError": {
                        "date":"2023-03-01T13:09:38",
                        "request-id":"0630e-452a-4535-a601-69e0a90e3aa2"
                    }
                }
             }')],
            'errorClass' => UserException::class,
            'expectedMessage' => 'OneDrive API error: AccessDenied - GET v1.0/sites?search=test&$select=id,name ' .
                'resulted in a 403 Forbidden',
            'checkIfRetires' => false,
        ];
    }

    /**
     * @param array<string, mixed> $headers
     * @return Response[]
     */
    private function get429Responses(array $headers, int $count = 1): array
    {
        return array_fill(
            0,
            $count,
            new Response(429, $headers, '{
                  "error": {
                    "code": "TooManyRequests",
                    "innerError": {
                      "code": "429",
                      "date": "2020-08-18T12:51:51",
                      "message": "Please retry after",
                      "request-id": "94fb3b52-452a-4535-a601-69e0a90e3aa2",
                      "status": "429"
                    },
                    "message": "Please retry again later."
                  }
                }')
        );
    }

    /**
     * @return Response[]
     */
    private function get504Responses(int $count = 1): array
    {
        return array_fill(
            0,
            $count,
            new Response(504, [], '{
                  "error": {
                    "code": "MaxRequestDurationExceeded",
                    "innerError": {
                      "code": "504",
                      "date": "2020-08-18T12:51:51",
                      "message": "We couldn\'t finish what you asked us to do because it was taking too long.We ' .
                'couldn\'t finish what you asked us to do because it was taking too long.",
                      "request-id": "94fb3b52-452a-4535-a601-69e0a90e3aa2",
                      "status": "429"
                    },
                    "message": "Please retry again later."
                  }
                }')
        );
    }
}



================================================
FILE: tests/phpunit/HelpersTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests;

use Keboola\OneDriveWriter\Api\Helpers;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\TestCase;

class HelpersTest extends TestCase
{
    private const
        TYPE_FILE_PATH = 'file_path',
        TYPE_DRIVE_FILE_PATH = 'drive_file_path',
        TYPE_SITE_FILE_PATH = 'site_file_path',
        TYPE_HTTPS_URL = 'https_url',
        TYPE_INVALID = 'invalid';

    /**
     * @dataProvider getInputs
     */
    public function testIsFilePath(string $type, string $path): void
    {
        Assert::assertSame($type === self::TYPE_FILE_PATH, Helpers::isFilePath($path));
    }

    /**
     * @dataProvider getInputs
     */
    public function testIsDriveFilePath(string $type, string $path): void
    {
        Assert::assertSame($type === self::TYPE_DRIVE_FILE_PATH, Helpers::isDriveFilePath($path));
    }

    /**
     * @dataProvider getInputs
     */
    public function testIsSiteFilePath(string $type, string $path): void
    {
        Assert::assertSame($type === self::TYPE_SITE_FILE_PATH, Helpers::isSiteFilePath($path));
    }

    /**
     * @dataProvider getInputs
     */
    public function testIsHttpsUrl(string $type, string $path): void
    {
        Assert::assertSame($type === self::TYPE_HTTPS_URL, Helpers::isHttpsUrl($path));
    }

    /**
     * @dataProvider getDriveFilePaths
     */
    public function testExplodeDriveFilePath(array $expected, string $input): void
    {
        Assert::assertSame($expected, Helpers::explodeDriveFilePath($input));
    }

    /**
     * @dataProvider getSiteFilePaths
     */
    public function testExplodeSiteFilePath(array $expected, string $input): void
    {
        Assert::assertSame($expected, Helpers::explodeSiteFilePath($input));
    }

    /**
     * @dataProvider getReplaceParamsInUriInputs
     */
    public function testReplaceParamsInUri(string $uri, array $params, string $expectedUri): void
    {
        Assert::assertSame($expectedUri, Helpers::replaceParamsInUri($uri, $params));
    }

    /**
     * @dataProvider getApiPathInputs
     */
    public function testConvertPathToApiFormat(string $input, string $expected): void
    {
        Assert::assertSame($expected, Helpers::convertPathToApiFormat($input));
    }

    /**
     * @dataProvider getToAsciiInputs
     */
    public function testToAscii(string $intput, string $expected): void
    {
        Assert::assertSame($expected, Helpers::toAscii($intput));
    }

    /**
     * @dataProvider getStringsForTruncate
     */
    public function testTruncate(string $intput, int $maxLength, string $expected): void
    {
        Assert::assertSame($expected, Helpers::truncate($intput, $maxLength));
    }

    /**
     * @dataProvider getIterables
     */
    public function testFormatIterable(iterable $values, int $maxItems, string $expected): void
    {
        Assert::assertSame($expected, Helpers::formatIterable($values, $maxItems, 10));
    }

    /**
     * @dataProvider getColumns
     */
    public function testColumnIntToStr(int $input, string $expected): void
    {
        Assert::assertSame($expected, Helpers::columnIntToStr($input));
    }

    /**
     * @dataProvider getColumns
     */
    public function testColumnStrToInt(int $expected, string $input): void
    {
        Assert::assertSame($expected, Helpers::columnStrToInt($input));
    }

    public function testEscapeExcelExpression(): void
    {
        $values = [['a', 'b', 'c'], ['d', '=1+1', '=foo-bar;-']];
        Helpers::escapeExcelExpressions($values);
        Assert::assertEquals([['a', 'b', 'c'], ['d', "'=1+1", "'=foo-bar;-"]], $values);
    }


    public function getInputs(): array
    {
        return [
            [self::TYPE_INVALID, ''],
            [self::TYPE_INVALID, '/'],
            [self::TYPE_INVALID, '/foo/'],
            [self::TYPE_INVALID, '/foo/bar/'],
            [self::TYPE_INVALID, '/special_chars/abc123čřž#$%_-/bar/'],
            [self::TYPE_INVALID, 'special_chars/abc123čřž#$%_-/bar/'],
            [self::TYPE_INVALID, 'site://foo'],
            [self::TYPE_INVALID, 'site://foo.xlsx'],
            [self::TYPE_FILE_PATH, 'file'],
            [self::TYPE_FILE_PATH, 'file.xlsx'],
            [self::TYPE_FILE_PATH, '/file'],
            [self::TYPE_FILE_PATH, '/file.xlsx'],
            [self::TYPE_FILE_PATH, '/some/path/file.xlsx'],
            [self::TYPE_FILE_PATH, 'some/path/file.xlsx'],
            [self::TYPE_FILE_PATH, '/some/path1/path2/file.xlsx'],
            [self::TYPE_FILE_PATH, 'some/path1/path2/file.xlsx'],
            [self::TYPE_FILE_PATH, '/some/path1/path2/file.ext1.ext2'],
            [self::TYPE_FILE_PATH, '/dir with space/foo bar/bar'],
            [self::TYPE_FILE_PATH, 'dir with space/foo bar/bar'],
            [self::TYPE_FILE_PATH, '/special_chars/abc123čřž#$%_-/bar'],
            [self::TYPE_FILE_PATH, 'special_chars/abc123čřž#$%_-/bar'],
            [self::TYPE_FILE_PATH, '/special_chars/abc123čřž#$%_-/abc123čřž#$%_-'],
            [self::TYPE_FILE_PATH, 'special_chars/abc123čřž#$%_-/barabc123čřž#$%_-'],
            [self::TYPE_DRIVE_FILE_PATH, 'drive://1234driveId5678/some/path/file'],
            [self::TYPE_DRIVE_FILE_PATH, 'drive://1234driveId5678/ssome/path/file.xlsx'],
            [self::TYPE_DRIVE_FILE_PATH, 'drive://1234driveId5678/ssome/path1/path2/file.xlsx'],
            [self::TYPE_DRIVE_FILE_PATH, 'drive://1234driveId5678/ssome/path1/path2/file.ext1.ext2'],
            [self::TYPE_SITE_FILE_PATH, 'site://site/some/path/file'],
            [self::TYPE_SITE_FILE_PATH, 'site://site/some/path/file.xlsx'],
            [self::TYPE_SITE_FILE_PATH, 'site://site/some/path1/path2/file.xlsx'],
            [self::TYPE_SITE_FILE_PATH, 'site://site/some/path1/path2/file.ext1.ext2'],
            [self::TYPE_SITE_FILE_PATH, 'site://site name with spaces/dir/file'],
            [self::TYPE_SITE_FILE_PATH, 'site://site name with spaces/dir/file.xlsx'],
            [self::TYPE_SITE_FILE_PATH, 'site://special chars abc123čřž#$%_-/dir/file'],
            [self::TYPE_SITE_FILE_PATH, 'site://special chars abc123čřž#$%_-/dir/file.xlsx'],
            [self::TYPE_SITE_FILE_PATH, 'site://special chars abc123čřž#$%_-/abc123 čřž#$%_-'],
            [self::TYPE_SITE_FILE_PATH, 'site://special chars abc123čřž#$%_-/abc123 čřž#$%_-.xlsx'],
            [self::TYPE_HTTPS_URL, 'https://foo'],
            [self::TYPE_HTTPS_URL, 'https://foo.xlsx'],
            [self::TYPE_HTTPS_URL, 'https://some/path2/file.xlsx'],
            [self::TYPE_HTTPS_URL, 'https://some/path1/path2/file.xlsx'],
            [self::TYPE_HTTPS_URL, 'https://some/path1/path2/file.ext1.ext2'],
        ];
    }

    public function getDriveFilePaths(): array
    {
        return [
            [
                ['1234driveId5678', 'some/path/file'],
                'drive://1234driveId5678/some/path/file',
            ],
            [
                ['1234driveId5678', 'path/file.xlsx'],
                'drive://1234driveId5678/path/file.xlsx',
            ],
            [
                ['1234driveId5678', 'path1/path2/file.xlsx'],
                'drive://1234driveId5678/path1/path2/file.xlsx',
            ],
        ];
    }

    public function getSiteFilePaths(): array
    {
        return [
            [
                ['some', 'path/file'],
                'site://some/path/file',
            ],
            [
                ['some', 'path/file.xlsx'],
                'site://some/path/file.xlsx',
            ],
            [
                ['some', 'path1/path2/file.xlsx'],
                'site://some/path1/path2/file.xlsx',
            ],
            [
                ['site name with spaces', 'dir/file'],
                'site://site name with spaces/dir/file',
            ],
            [
                ['site name with spaces', 'dir/file.xlsx'],
                'site://site name with spaces/dir/file.xlsx',
            ],
            [
                ['special chars abc123čřž#$%_-', 'dir/file'],
                'site://special chars abc123čřž#$%_-/dir/file',
            ],
            [
                ['special chars abc123čřž#$%_-', 'dir/file.xlsx'],
                'site://special chars abc123čřž#$%_-/dir/file.xlsx',
            ],
            [
                ['special chars abc123čřž#$%_-', 'abc123 čřž#$%_-'],
                'site://special chars abc123čřž#$%_-/abc123 čřž#$%_-',
            ],
            [
                ['special chars abc123čřž#$%_-', 'abc123 čřž#$%_-.xlsx'],
                'site://special chars abc123čřž#$%_-/abc123 čřž#$%_-.xlsx',
            ],
        ];
    }

    public function getReplaceParamsInUriInputs(): array
    {
        return [
            ['', [], ''],
            ['http://abc', [], 'http://abc'],
            ['http://abc/{foo}', [], 'http://abc/{foo}'],
            ['http://abc/{foo}', ['foo' => 'bar'], 'http://abc/bar'],
            ['http://abc/{a}/{b}?{c}=value', ['a' => 'd', 'b' => 'e', 'c' => 'f'], 'http://abc/d/e?f=value'],
            ['http://abc/{foo}', ['foo' => 'one or more spaces'], 'http://abc/one+or+more+spaces'],
            [
                'http://abc/{foo}',
                ['foo' => 'special/chars123úěš!@#'],
                'http://abc/special%2Fchars123%C3%BA%C4%9B%C5%A1%21%40%23',
            ],
        ];
    }

    public function getApiPathInputs(): array
    {
        return [
            ['', '/'],
            ['/', '/'],
            ['abc', ':/abc:/'],
            ['/abc', ':/abc:/'],
            ['path/to/file.xlsx', ':/path/to/file.xlsx:/'],
            ['/path/to/file.xlsx', ':/path/to/file.xlsx:/'],
        ];
    }

    public function getToAsciiInputs(): array
    {
        return [
            ['', ''],
            ['aBc', 'aBc'],
            ['!@#', ''],
            ['úěš', 'ues'],
            ['指事字', ''],
            ["a\n\tb_xy", 'a_b_xy'],
        ];
    }

    public function getStringsForTruncate(): array
    {
        return [
            ['abc', -5, '...'],
            ['abc', 0, '...'],
            ['abc', 3, 'abc'],
            ['abcd', 3, 'abc...'],
            ['some longer str', 10, 'some longe...'],
            ['some longer str', 20, 'some longer str'],
            ['special123úěš!@#', 12, 'special123úě...'],
            ['special123úěš!@#', 20, 'special123úěš!@#'],
        ];
    }

    public function getIterables(): array
    {
        return [
            [[], -5, '(empty)'],
            [[], 0, '(empty)'],
            [[], 10, '(empty)'],
            [['a', 'b', 'c'], 3, '"a", "b", "c"'],
            [['a', 'b', 'c'], 2, '"a", "b", ...'],
            [['some long string', 'b', 'c'], 3, '"some long ...", "b", "c"'],
            [['a', 'some long string', 'c'], 3, '"a", "some long ...", "c"'],
            [['a', 'b', 'some long string'], 3, '"a", "b", "some long ..."'],
            [['some long string', 'b', 'c'], 2, '"some long ...", "b", ...'],
            [['a', 'some long string', 'c'], 2, '"a", "some long ...", ...'],
            [['a', 'b', 'some long string'], 2, '"a", "b", ...'],

        ];
    }

    public function getColumns(): array
    {
        return [
            [1, 'A'],
            [2, 'B'],
            [3, 'C'],
            [26, 'Z'],
            [27, 'AA'],
            [28, 'AB'],
            [29, 'AC'],
            [52, 'AZ'],
            [53, 'BA'],
            [731, 'ABC'],
        ];
    }
}



================================================
FILE: tests/phpunit/HttpClientMockBuilder.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use Psr\Http\Message\ResponseInterface;

class HttpClientMockBuilder
{
    private array $responses = [];

    public static function create(): self
    {
        return new self();
    }

    public function getHttpClient(): Client
    {
        $handlerStack = HandlerStack::create(new MockHandler($this->responses));
        return new Client(['handler' => $handlerStack]);
    }

    /**
     * @param ResponseInterface[] $responses
     */
    public function setResponses(array $responses): self
    {
        $this->responses = $responses;
        return $this;
    }
}



================================================
FILE: tests/phpunit/TableHeaderTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests;

use Keboola\OneDriveWriter\Api\Model\TableHeader;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\TestCase;

class TableHeaderTest extends TestCase
{
    public function testGetters(): void
    {
        $row = TableHeader::from('Sheet1!B123:I456', ['a', 'b', 'b', 'c']);
        Assert::assertSame('B', $row->getStartColumn());
        Assert::assertSame('B123', $row->getStartCell());
        Assert::assertSame('I', $row->getEndColumn());
        Assert::assertSame('I123', $row->getEndCell());
        Assert::assertSame(123, $row->getFirstRowNumber());
        Assert::assertSame(123, $row->getLastRowNumber());
        Assert::assertSame(['a', 'b', 'b-1', 'c'], $row->getColumns());
    }

    /**
     * @dataProvider getColumns
     */
    public function testParseColumns(array $input, array $expected): void
    {
        Assert::assertSame($expected, TableHeader::parseColumns($input));
    }

    public function getColumns(): array
    {
        return [
            [
                [],
                [],
            ],
            [
                ['', 'b', ''],
                ['column-1', 'b', 'column-3'],
            ],
            [
                ['', 'column-1', '', 'column-3', 'column-1', 'column-3'],
                ['column-1', 'column-1-1', 'column-3', 'column-3-1', 'column-1-2', 'column-3-2'],
            ],
            [
                ['a', 'b', 'c'],
                ['a', 'b', 'c'],
            ],
            [
                ['!@#', 'úěš', '指事字'],
                ['column-1', 'ues', 'column-3'],
            ],
            [
                ['col1', 'col1', 'col1'],
                ['col1', 'col1-1', 'col1-2'],
            ],
        ];
    }
}



================================================
FILE: tests/phpunit/TableRangeTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests;

use InvalidArgumentException;
use Keboola\OneDriveWriter\Api\Model\TableRange;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\TestCase;

class TableRangeTest extends TestCase
{
    public function testGetters(): void
    {
        $row = TableRange::from('Sheet1!B123:I456');
        Assert::assertSame('B', $row->getStartColumn());
        Assert::assertSame('B123', $row->getStartCell());
        Assert::assertSame('I', $row->getEndColumn());
        Assert::assertSame('I456', $row->getEndCell());
        Assert::assertSame(123, $row->getFirstRowNumber());
        Assert::assertSame(456, $row->getLastRowNumber());
    }

    /**
     * @dataProvider getStartsEndsValid
     */
    public function testParseStartEndSuccess(string $input, array $expected): void
    {
        Assert::assertSame($expected, TableRange::parseStartEnd($input));
    }

    /**
     * @dataProvider getStartsEndsInvalid
     */
    public function testParseStartEndFail(string $input): void
    {
        $this->expectException(InvalidArgumentException::class);
        TableRange::parseStartEnd($input);
    }

    public function getStartsEndsValid(): array
    {
        return [
            [
                'Sheet1!B123:I123',
                ['B', 'I', 123, 123],
            ],
            [
                'Sheet1!B123:I456',
                ['B', 'I', 123, 456],
            ],
            [
                'Sheet1!A10',
                ['A', 'A', 10, 10],
            ],
            [
                'B123:I123',
                ['B', 'I', 123, 123],
            ],
            [
                'B123:I456',
                ['B', 'I', 123, 456],
            ],
            [
                'A10',
                ['A', 'A', 10, 10],
            ],
            [
                'Sheet1 a b c !!!X10:Y20 def ščřšč!B123:I456',
                ['B', 'I', 123, 456],
            ],
            [
                'Sheet1 a b c !!!X10:Y20 def ščřšč!A10',
                ['A', 'A', 10, 10],
            ],
        ];
    }

    public function getStartsEndsInvalid(): array
    {
        return [
            [''],
            ['abc'],
        ];
    }
}



================================================
FILE: tests/phpunit/Config/BaseConfigTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests\Config;

use PHPUnit\Framework\TestCase;

abstract class BaseConfigTest extends TestCase
{
    protected function getValidAuthorization(): array
    {
        return [
            'oauth_api' => [
                'credentials' => [
                    '#data' => '{"access_token": "access", "refresh_token": "refresh"}',
                    '#appSecret' => 'secret',
                    'appKey' => 'key',
                ],
            ],
        ];
    }
}



================================================
FILE: tests/phpunit/Config/CreateWorkbookConfigTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests\Config;

use Keboola\OneDriveWriter\Configuration\Config;
use Keboola\OneDriveWriter\Configuration\CreateWorkbookConfigDefinition;
use Symfony\Component\Config\Definition\Exception\InvalidConfigurationException;

class CreateWorkbookConfigTest extends BaseConfigTest
{
    /**
     * @dataProvider validConfigProvider
     */
    public function testValidConfig(array $config): void
    {
        new Config($config, new CreateWorkbookConfigDefinition());
        $this->addToAssertionCount(1); // Assert no error
    }

    /**
     * @dataProvider invalidConfigProvider
     */
    public function testInvalidConfig(string $expectedMsg, array $config): void
    {
        $this->expectException(InvalidConfigurationException::class);
        $this->expectExceptionMessage($expectedMsg);
        new Config($config, new CreateWorkbookConfigDefinition());
    }

    public function validConfigProvider(): array
    {
        return [
            'valid-path' => [
                [
                    'action' => 'createWorkbook',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                    ],
                ],
            ],
        ];
    }

    public function invalidConfigProvider(): array
    {
        return [
            'empty' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [
                    'action' => 'createWorkbook',
                ],
            ],
            'missing-authorization' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [
                    'action' => 'createWorkbook',
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                    ],
                ],
            ],
            'missing-workbook' => [
                'The child node "workbook" at path "root.parameters" must be configured.',
                [
                    'action' => 'createWorkbook',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [

                    ],
                ],
            ],
            'ids' => [
                'Unrecognized options "driveId, fileId" under "root.parameters.workbook". Available option is "path".',
                [
                    'action' => 'createWorkbook',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '...',
                            'fileId' => '...',
                        ],
                    ],
                ],
            ],
            'drive-id' => [
                'Unrecognized option "driveId" under "root.parameters.workbook". Available option is "path".',
                [
                    'action' => 'createWorkbook',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                            'driveId' => '1234abc',
                        ],
                    ],
                ],
            ],
            'file-id' => [
                'Unrecognized option "fileId" under "root.parameters.workbook". Available option is "path".',
                [
                    'action' => 'createWorkbook',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                            'fileId' => '1234abc',
                        ],
                    ],
                ],
            ],
        ];
    }
}



================================================
FILE: tests/phpunit/Config/CreateWorksheetConfigTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests\Config;

use Keboola\OneDriveWriter\Configuration\Config;
use Keboola\OneDriveWriter\Configuration\CreateWorksheetConfigDefinition;
use Symfony\Component\Config\Definition\Exception\InvalidConfigurationException;

class CreateWorksheetConfigTest extends BaseConfigTest
{
    /**
     * @dataProvider validConfigProvider
     */
    public function testValidConfig(array $config): void
    {
        new Config($config, new CreateWorksheetConfigDefinition());
        $this->addToAssertionCount(1); // Assert no error
    }

    /**
     * @dataProvider invalidConfigProvider
     */
    public function testInvalidConfig(string $expectedMsg, array $config): void
    {
        $this->expectException(InvalidConfigurationException::class);
        $this->expectExceptionMessage($expectedMsg);
        new Config($config, new CreateWorksheetConfigDefinition());
    }

    public function validConfigProvider(): array
    {
        return [
            'valid-name' => [
                [
                    'action' => 'createWorksheet',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '...',
                            'fileId' => '...',
                        ],
                        'worksheet' => [
                            'name' => 'New Sheet 1',
                        ],
                    ],
                ],
            ],
        ];
    }

    public function invalidConfigProvider(): array
    {
        return [
            'empty' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [
                    'action' => 'createWorksheet',
                ],
            ],
            'missing-authorization' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [
                    'action' => 'createWorksheet',
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '...',
                            'fileId' => '...',
                        ],
                        'worksheet' => [
                            'name' => 'New Sheet 1',
                        ],
                    ],
                ],
            ],
            'missing-all' => [
                'The child node "workbook" at path "root.parameters" must be configured.',
                [
                    'action' => 'createWorksheet',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [

                    ],
                ],
            ],
            'missing-worksheet' => [
                'The child node "worksheet" at path "root.parameters" must be configured.',
                [
                    'action' => 'createWorksheet',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                    ],
                ],
            ],
            'worksheet-position' => [
                'Unrecognized option "position" under "root.parameters.worksheet". Available option is "name".',
                [
                    'action' => 'createWorksheet',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '...',
                            'fileId' => '...',
                        ],
                        'worksheet' => [
                            'position' => 4,
                            'name' => 'New Sheet 1',
                        ],
                    ],
                ],
            ],
            'worksheet-id' => [
                'Unrecognized option "id" under "root.parameters.worksheet". Available option is "name".',
                [
                    'action' => 'createWorksheet',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '...',
                            'fileId' => '...',
                        ],
                        'worksheet' => [
                            'id' => '...',
                            'name' => 'New Sheet 1',
                        ],
                    ],
                ],
            ],
        ];
    }
}



================================================
FILE: tests/phpunit/Config/RunConfigTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests\Config;

use Keboola\OneDriveWriter\Configuration\Config;
use Keboola\OneDriveWriter\Configuration\ConfigDefinition;
use Symfony\Component\Config\Definition\Exception\InvalidConfigurationException;

class RunConfigTest extends BaseConfigTest
{
    /**
     * @dataProvider validConfigProvider
     */
    public function testValidConfig(array $config): void
    {
        new Config($config, new ConfigDefinition());
        $this->expectNotToPerformAssertions();
    }

    /**
     * @dataProvider invalidConfigProvider
     */
    public function testInvalidConfig(string $expectedMsg, array $config): void
    {
        $this->expectException(InvalidConfigurationException::class);
        $this->expectExceptionMessage($expectedMsg);
        new Config($config, new ConfigDefinition());
    }

    public function validConfigProvider(): array
    {
        return [
            'valid-path-position' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'valid-file-id' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'valid-worksheet-name' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                        ],
                    ],
                ],
            ],
            'valid-worksheet-id' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                        ],
                        'worksheet' => [
                            'id' => '9012xyz',
                        ],
                    ],
                ],
            ],
            'valid-worksheet-id-name' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'id' => '9012xyz',
                        ],
                    ],
                ],
            ],
            'valid-worksheet-position' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                        ],
                        'worksheet' => [
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'valid-worksheet-position-name' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'valid-default-bucket' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'id' => '9012xyz',
                        ],
                    ],
                ],
            ],
            'valid-plus-metadata' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '5678def',
                            'metadata' => [
                                'a' => 1,
                                'b' => 'abc',
                            ],
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'id' => '9012xyz',
                            'metadata' => [
                                'a' => 1,
                                'b' => 'abc',
                            ],
                        ],
                    ],
                ],
            ],
            'valid-batch-size' => [
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'batchSize' => 12345,
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
        ];
    }

    public function invalidConfigProvider(): array
    {
        return [
            'empty' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [],
            ],
            'missing-authorization' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'missing-workbook' => [
                'The child node "workbook" at path "root.parameters" must be configured.',
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'missing-worksheet' => [
                'The child node "worksheet" at path "root.parameters" must be configured.',
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                    ],
                ],
            ],
            'missing-file-id' => [
                'Both "workbook.driveId" and "workbook.fileId" must be configured.',
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'missing-drive-id' => [
                'Both "workbook.driveId" and "workbook.fileId" must be configured.',
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'fileId' => '1234abc',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'extra-workbook-path-key' => [
                'In config is present "workbook.path", ' .
                'therefore "workbook,driveId" and "workbook.fileId" are not expected.',
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                            'driveId' => '1234abc',
                            'fileId' => '4567def',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
            'extra-worksheet-position' => [
                'In config must be ONLY ONE OF "worksheet.id" OR "worksheet.position". Both given.',
                [
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                            'fileId' => '4567def',
                        ],
                        'worksheet' => [
                            'name' => 'Sheet 1',
                            'id' => '901xyz',
                            'position' => 0,
                        ],
                    ],
                ],
            ],
        ];
    }
}



================================================
FILE: tests/phpunit/Config/SyncActionConfigTest.php
================================================
<?php

declare(strict_types=1);

namespace Keboola\OneDriveWriter\Tests\Config;

use Keboola\OneDriveWriter\Configuration\Config;
use Keboola\OneDriveWriter\Configuration\SyncActionConfigDefinition;
use Symfony\Component\Config\Definition\Exception\InvalidConfigurationException;

class SyncActionConfigTest extends BaseConfigTest
{
    /**
     * @dataProvider validConfigProvider
     */
    public function testValidConfig(array $config): void
    {
        new Config($config, new SyncActionConfigDefinition());
        $this->addToAssertionCount(1); // Assert no error
    }

    /**
     * @dataProvider invalidConfigProvider
     */
    public function testInvalidConfig(string $expectedMsg, array $config): void
    {
        $this->expectException(InvalidConfigurationException::class);
        $this->expectExceptionMessage($expectedMsg);
        new Config($config, new SyncActionConfigDefinition());
    }

    public function validConfigProvider(): array
    {
        return [
            'valid-path' => [
                [
                    'action' => 'path',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                    ],
                ],
            ],
            'valid-ids' => [
                [
                    'action' => 'path',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '...',
                            'fileId' => '...',
                        ],
                    ],
                ],
            ],
            'valid-ids-plus-metadata' => [
                [
                    'action' => 'path',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '...',
                            'fileId' => '...',
                            'metadata' => [
                                'a' => 1,
                                'b' => 'abc',
                            ],
                        ],
                    ],
                ],
            ],
        ];
    }

    public function invalidConfigProvider(): array
    {
        return [
            'empty' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [
                    'action' => 'getWorksheets',
                ],
            ],
            'missing-authorization' => [
                'Missing OAuth credentials, ' .
                'please set "authorization.oauth_api.credentials.{appKey,#appSecret,#data}".',
                [
                    'action' => 'getWorksheets',
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                        ],
                    ],
                ],
            ],
            'missing-workbook' => [
                'The child node "workbook" at path "root.parameters" must be configured.',
                [
                    'action' => 'getWorksheets',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [

                    ],
                ],
            ],
            'missing-file-id' => [
                'Both "workbook.driveId" and "workbook.fileId" must be configured.',
                [
                    'action' => 'getWorksheets',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'driveId' => '1234abc',
                        ],
                    ],
                ],
            ],
            'missing-drive-id' => [
                'Both "workbook.driveId" and "workbook.fileId" must be configured.',
                [
                    'action' => 'getWorksheets',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'fileId' => '1234abc',
                        ],
                    ],
                ],
            ],
            'extra-workbook-path-key' => [
                'In config is present "workbook.path", ' .
                'therefore "workbook,driveId" and "workbook.fileId" are not expected.',
                [
                    'action' => 'getWorksheets',
                    'authorization' => $this->getValidAuthorization(),
                    'parameters' => [
                        'workbook' => [
                            'path' => '/path/to/file',
                            'driveId' => '1234abc',
                            'fileId' => '4567def',
                        ],
                    ],
                ],
            ],
        ];
    }
}



================================================
FILE: utils/oauth-app-list.sh
================================================
#!/usr/bin/env bash

set -o errexit          # Exit on most errors (see the manual)
set -o errtrace         # Make sure any error trap is inherited
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline
#set -o xtrace          # Trace the execution of the script (debug)

# Load env variables
if [ -f ".env" ]; then
  IFS=' ' read -ra envPairs <<< "$(xargs < .env)" >/dev/null 2>&1
  if [ -n "${envPairs:-}" ]; then export "${envPairs[@]}"; fi
fi

# Required environment variables
: "${OAUTH_APP_NAME:?Need to set OAUTH_APP_NAME env variable}"

# Constants
SCRIPT=$(realpath "$0")
SCRIPT_DIR=$(dirname "$SCRIPT")
SCRIPT_FILENAME=$(basename "$SCRIPT")
AZ_CLI_IMG="mcr.microsoft.com/azure-cli"

# If NOT runned in Docker container AND "az" executable not exists locally ...
if [ ! -f /.dockerenv ] && ! command -v az >/dev/null 2>&1; then
  # ... run script in Docker container
  echo "Running in Docker container ..."
  exec docker run \
    --rm -it \
    --volume "$SCRIPT_DIR:/utils" \
    -e OAUTH_APP_NAME \
    "$AZ_CLI_IMG" \
    "/utils/$SCRIPT_FILENAME"
fi

# Check if logged in, if not then login
if az account show >/dev/null 2>&1; then
  echo "You are already logged in!"  >&2
else
  az login --use-device-code >&2
  echo "You have been successfully logged in!"  >&2
fi

# List app info
echo "Getting info about app \"$OAUTH_APP_NAME\""
az ad app list \
    --output json \
    --filter "displayName eq '$OAUTH_APP_NAME'" "$@"
echo -e "\nDone\n"



================================================
FILE: utils/oauth-app-registration.sh
================================================
#!/usr/bin/env bash

set -o errexit          # Exit on most errors (see the manual)
set -o errtrace         # Make sure any error trap is inherited
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline
#set -o xtrace          # Trace the execution of the script (debug)

# Load env variables from .env file, but not overwrite the existing one
if [ -f ".env" ]; then
  source <(grep -v '^#' .env | sed -E 's|^([^=]+)=(.*)$|: ${\1=\2}; export \1|g')
fi

# Required environment variables
: "${OAUTH_APP_NAME:?Need to set OAUTH_APP_NAME env variable}"

# Constants
SCRIPT=$(realpath "$0")
SCRIPT_DIR=$(dirname "$SCRIPT")
SCRIPT_FILENAME=$(basename "$SCRIPT")
AZ_CLI_IMG="mcr.microsoft.com/azure-cli"

# Permissions
# https://www.shawntabrizi.com/aad/common-microsoft-resources-azure-active-directory/
api_id="00000003-0000-0000-c000-000000000000"
# https://github.com/stephaneey/azure-ad-vsts-extension/blob/master/overview.md
declare -A permissions
permissions["offline_access"]="7427e0e9-2fba-42fe-b0c0-848c9e6a8182"
permissions["User.Read"]="e1fe6dd8-ba31-4d61-89e7-88639da4683d"
permissions["Files.ReadWrite.All"]="863451e7-0667-486c-a5d6-d135439485f0"
permissions["Sites.ReadWrite.All"]="89fe6a52-be36-487e-b7d8-d061c450a026"

# If NOT run in the Docker container AND "az" executable not exists locally ...
if [ ! -f /.dockerenv ] && ! command -v az >/dev/null 2>&1; then
  # ... run script in Docker container
  echo "Running in Docker container ..."
  exec docker run \
    --rm -it \
    --volume "$SCRIPT_DIR:/utils" \
    -e OAUTH_APP_NAME \
    "$AZ_CLI_IMG" \
    "/utils/$SCRIPT_FILENAME"
fi

# Check if logged in, if not then login
subscriptionId=$(az account show --query "tenantId" --output tsv || true)
if [ -z "$subscriptionId" ]; then
  subscriptionId=$(az login --use-device-code --query "[].tenantId | [0]" --output tsv)
  echo "You have been successfully logged in!"
else
  echo "You are already logged in!"
fi

# Get app id if exists
echo "Testing if the application \"$OAUTH_APP_NAME\" exists ..."
OAUTH_APP_ID=$(az ad app list --output tsv --filter "displayName eq '$OAUTH_APP_NAME'" --query "[].appId | [0]")

# Create app if not exists
if [ -z "$OAUTH_APP_ID" ]; then
  echo "Application does not exist."
  echo "Creating application \"$OAUTH_APP_NAME\""
  OAUTH_APP_ID=$(
   az ad app create \
        --output tsv \
        --query "appId" \
        --is-fallback-public-client false \
        --display-name "$OAUTH_APP_NAME" \
        --enable-access-token-issuance true \
        --sign-in-audience AzureADandPersonalMicrosoftAccount \
        --end-date '2050-12-31'
  )
  echo "Application created, OAUTH_APP_ID=\"$OAUTH_APP_ID\""

  # Get secret
  OAUTH_APP_SECRET=$(az ad app credential reset \
    --output tsv \
    --query "password" \
    --id "$OAUTH_APP_ID"
  )

  echo "SAVE SECRET KEY!!! -> OAUTH_APP_SECRET=\"$OAUTH_APP_SECRET\""
else
  echo "Application already exists, OAUTH_APP_ID=\"$OAUTH_APP_ID\""
fi

# Load active permissions
echo "Checking permission"
activePerms=$(az ad app list --output tsv --filter "displayName eq '$OAUTH_APP_NAME'"  --query "[].requiredResourceAccess[].resourceAccess[].id")

# Set permissions
perms_arg=()
for perm_name in "${!permissions[@]}"; do
  perm_id=${permissions[${perm_name}]}
  if [[ $activePerms != *"$perm_id"* ]]; then
    echo "Missing permission \"$perm_name\""
    perms_arg+=("$perm_id=Scope")
  fi
done

echo "Active permissions: $activePerms"

if [ ${#perms_arg[@]} -ne 0 ]; then
  echo "Setting permission"
  if ! az ad app permission add --id "$OAUTH_APP_ID" --api "$api_id" --api-permissions "${perms_arg[@]}" 2>/dev/null; then
    echo "WARNING: Error setting permissions."
    echo "WARNING: Please edit it manually in Azure Portal -> App registrations -> $OAUTH_APP_NAME -> Permissions"
  fi
fi


# Print ENV variables
echo -e "\nDone\n"
echo -e "\n-----------------------------------------------------"
echo -e "Please, add these envrioment variables to \".env\" file:\n"
echo "OAUTH_APP_NAME=\"$OAUTH_APP_NAME\""
echo "OAUTH_APP_ID=$OAUTH_APP_ID"
echo "OAUTH_APP_SECRET=${OAUTH_APP_SECRET:-...}"



================================================
FILE: utils/oauth-login.sh
================================================
#!/usr/bin/env bash

set -o errexit          # Exit on most errors (see the manual)
set -o errtrace         # Make sure any error trap is inherited
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline
#set -o xtrace          # Trace the execution of the script (debug)

# Load env variables
if [ -f ".env" ]; then
  IFS=' ' read -ra envPairs <<< "$(xargs < .env)" >/dev/null 2>&1
  if [ -n "${envPairs:-}" ]; then export "${envPairs[@]}"; fi
fi

# Required environment variables
: "${OAUTH_APP_ID:?Need to set OAUTH_APP_ID env variable}"
: "${OAUTH_APP_SECRET:?Need to set OAUTH_APP_SECRET env variable}"

# Constants
SCRIPT=$(realpath "$0")
SCRIPT_DIR=$(dirname "$SCRIPT")
SCRIPT_FILENAME=$(basename "$SCRIPT")
BASH_UTILS_IMG="bretfisher/netshoot"
HTTP_SERVER_PORT="10000"
HTTP_SERVER_URI="http://localhost:$HTTP_SERVER_PORT"

printInfo() {
  echo
  echo -e "Please open \"$HTTP_SERVER_URI\" in your browser and click \"signing in\".\n";
  echo -e "You will be redirected to the login page.\n"
  echo -e "After you receive the OAuth tokens, you can close this script.\n"
}

main() {
  case $1 in
    "handle") handle;;
    "runServer") runServer;;
    *) echo "Unexpected command '$1'." 2>&1; exit 1;;
  esac
}

runServer() {
  # If NOT runned in Docker container run script in Docker container
  # This part can be removed if all tools are locally installed
  if [ ! -f /.dockerenv ]; then
    echo "Running in Docker container ..."
    exec docker run \
      --rm -it \
      --volume "$SCRIPT_DIR:/utils" \
      -p "$HTTP_SERVER_PORT:$HTTP_SERVER_PORT" \
      -e OAUTH_APP_ID \
      -e OAUTH_APP_SECRET \
      "$BASH_UTILS_IMG" \
      "/utils/$SCRIPT_FILENAME"
  fi

  # Run http server
  printInfo
  exec socat "tcp-l:$HTTP_SERVER_PORT",reuseaddr,fork,crlf exec:"$0 handle"
}

debug() {
  echo -e "DEBUG: $1\n" 1>&2
}

handle() {
  # Read HTTP request from stdin: method path version
  read _ path _
  debug "Received http request '$path'"
  route "$path"
}

route() {
  path="$1"
  if [ "$path" == "/" ]; then render_start_page
  elif [ "$path" == "/sign-in" ]; then render_sign_in
  elif [[ "$path" =~ ^/sign-in/callback\?code=(.+)$ ]]; then render_sign_in_callback "${BASH_REMATCH[1]}"
  elif [[ "$path" =~ ^/sign-in/callback\?error=(.+)\&error_description=(.+)$ ]]; then render_error_page "$(urldecode "${BASH_REMATCH[1]}: ${BASH_REMATCH[2]}")"
  else render_404_page
  fi
}

urlencode() {
  local string="${1}"
  local strlen=${#string}
  local encoded=""
  local pos c o

  for (( pos=0 ; pos<strlen ; pos++ )); do
     c=${string:$pos:1}
     case "$c" in
        [-_.~a-zA-Z0-9] ) o="${c}" ;;
        * )               printf -v o '%%%02x' "'$c"
     esac
     encoded+="${o}"
  done
  echo "${encoded}"
}

urldecode() {
  : "${*//+/ }"; echo -e "${_//%/\\x}";
}

# OAuth constants
OAUTH_AUTHORITY_URL='https://login.microsoftonline.com/common'
OAUTH_AUTHORIZE_ENDPOINT="$OAUTH_AUTHORITY_URL/oauth2/v2.0/authorize"
OAUTH_TOKEN_ENDPOINT="$OAUTH_AUTHORITY_URL/oauth2/v2.0/token"
OAUTH_SCOPE="offline_access User.Read Files.ReadWrite.All Sites.ReadWrite.All";

function get_authorize_url() {
  echo -n "$OAUTH_AUTHORIZE_ENDPOINT"
  echo -n "?client_id=$(urlencode "$OAUTH_APP_ID")"
  echo -n "&prompt=login"
  echo -n "&redirect_uri=$(urlencode "$HTTP_SERVER_URI/sign-in/callback")"
  echo -n "&scope=$(urlencode "$OAUTH_SCOPE")"
  echo -n "&response_type=code"
  echo -n "&response_mode=query"
}

function get_token_post_args() {
  authorization_code="$1"
  echo -n "client_id=$(urlencode "$OAUTH_APP_ID")"
  echo -n "&client_secret=$(urlencode "$OAUTH_APP_SECRET")"
  echo -n "&redirect_uri=$(urlencode "$HTTP_SERVER_URI/sign-in/callback")"
  echo -n "&code=$authorization_code"
  echo -n "&grant_type=authorization_code"
}

function render_404_page {
  echo 'HTTP/1.1 404 Not Found'
  echo 'Content-Type: text/html'
  echo ''
  echo '<html>'
  echo '<body>'
  echo '<h1>404 Not Found</h1>'
  echo "<p>Resource \"$path\" could not be found.</p>"
  echo '</body>'
}

function render_error_page {
  errorMsg="$1"
  echo 'HTTP/1.1 400 Bad Request'
  echo 'Content-Type: text/html'
  echo
  echo '<html>'
  echo '<body>'
  echo '<h1>An error occurred</h1>'
  echo '<p style="max-width: 600px;">'
  echo "$errorMsg"
  echo '</p>'
  echo '<p>'
  echo '<a href="/sign-in">Try signing in again</a>.'
  echo '</p>'
  echo '</body></html>'
}

function render_token_page {
  access_token="$1"
  refresh_token="$2"
  echo 'HTTP/1.1 400 Bad Request'
  echo 'Content-Type: text/html'
  echo
  echo '<html>'
  echo '<body>'
  echo '<h1>Hurray!</h1>'
  echo '<p><b>Please, add this envrioment variables to ".env" file:</b></p>'
  echo "<p style=\"max-width: 800px; word-wrap: break-word; word-break: break-all;\">"
  echo "<b>OAUTH_ACCESS_TOKEN</b>=<small>$access_token</small>"
  echo "</p>"
  echo "<p style=\"max-width: 800px; word-wrap: break-word; word-break: break-all;\">"
  echo "<b>OAUTH_REFRESH_TOKEN</b>=<small>$refresh_token</small>"
  echo "</p>"
  echo '<p>'
  echo '<a href="/sign-in">Sign in again.</a>.'
  echo '</p>'
  echo '</body></html>'
}

function render_start_page {
  echo 'HTTP/1.1 200 OK'
  echo 'Content-Type: text/html'
  echo
  echo '<html>'
  echo '<body>'
  echo '<h1>Hi from bash!</h1>'
  echo '<p>'
  echo 'This is a server running on socat and bash.'
  echo 'It can perform an OAuth 2 authorization code grant flow.'
  echo '</p>'
  echo '<p>'
  echo 'Try it now by'
  echo '<a href="/sign-in">signing in</a>.'
  echo '</p>'
  echo '</body></html>'
}

function render_sign_in {
  # Redirect to sign in page
  authorize_url=$(get_authorize_url)
  debug "Redirecting to: $authorize_url"
  echo 'HTTP/1.1 302 Found'
  echo "Location: $authorize_url"
}

function render_sign_in_callback {
  # Get token
  authorization_code="$1"
  post="$(get_token_post_args "$authorization_code")"
  response=$(curl -s -X POST -d "$post" "$OAUTH_TOKEN_ENDPOINT")

  # Handle error
  error=$(echo "$response" | jq -r ".error_description")
  if [ "$error" != "null" ]; then
    render_error_page "$error"
    debug "\nAn error occurred: \n$error\n\n"
    return
  fi

  # Print tokens
  access_token=$(echo "$response" | jq -r ".access_token")
  refresh_token=$(echo "$response" | jq -r ".refresh_token")
  render_token_page "$access_token" "$refresh_token"
  debug "The obtained tokens are displayed in a web browser."
}

# Command is first argument or default "runServer"
main "${1-runServer}"



================================================
FILE: .github/workflows/push.yml
================================================
name: GitHub Actions
on: [ push ]
concurrency: ci # used shared OneDrive
env:
  APP_IMAGE: wr-onedrive

  # Developer portal login
  KBC_DEVELOPERPORTAL_VENDOR: "keboola"
  KBC_DEVELOPERPORTAL_APP: "keboola.wr-onedrive"
  KBC_DEVELOPERPORTAL_USERNAME: "keboola+wr_onedrive_gh"
  KBC_DEVELOPERPORTAL_PASSWORD: ${{ secrets.KBC_DEVELOPERPORTAL_PASSWORD }}

  # DockerHub login
  DOCKERHUB_USER: "keboolabot"
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}

  # OAuth for tests
  OAUTH_APP_NAME: "wr-onedrive-dev-test"
  OAUTH_APP_ID: ${{ secrets.OAUTH_APP_ID }}
  OAUTH_APP_SECRET: ${{ secrets.OAUTH_APP_SECRET }}
  OAUTH_ACCESS_TOKEN: ${{ secrets.OAUTH_ACCESS_TOKEN }}
  OAUTH_REFRESH_TOKEN: ${{ secrets.OAUTH_REFRESH_TOKEN }}
  TEST_SHAREPOINT_SITE: "Excel Sheets"

  # Test KBC project
  KBC_STORAGE_TOKEN: ""
  KBC_TEST_PROJECT_URL: ""
  KBC_TEST_PROJECT_CONFIGS: "" # space separated list
jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      app_image_tag: ${{ steps.tag.outputs.app_image_tag }}
      is_semantic_tag: ${{ steps.tag.outputs.is_semantic_tag }}
    steps:
      -
        name: Check out the repo
        uses: actions/checkout@v3
      -
        name: Print Docker version
        run: docker -v
      -
        name: Docker login
        if: env.DOCKERHUB_TOKEN
        run: docker login --username "$DOCKERHUB_USER" --password "$DOCKERHUB_TOKEN"
      -
        name: Build image
        run: docker build -t $APP_IMAGE .
      -
        name: Set image tag
        id: tag
        run: |
          TAG="${GITHUB_REF##*/}"
          IS_SEMANTIC_TAG=$(echo "$TAG" | grep -q '^v\?[0-9]\+\.[0-9]\+\.[0-9]\+$' && echo true || echo false)
          echo "Tag = '$TAG', is semantic tag = '$IS_SEMANTIC_TAG'"
          echo "is_semantic_tag=$IS_SEMANTIC_TAG" >> $GITHUB_OUTPUT
          echo "app_image_tag=$TAG" >> $GITHUB_OUTPUT
      -
        name: Push image to ECR
        uses: keboola/action-push-to-ecr@master
        with:
          vendor: ${{ env.KBC_DEVELOPERPORTAL_VENDOR }}
          app_id: ${{ env.KBC_DEVELOPERPORTAL_APP }}
          username: ${{ env.KBC_DEVELOPERPORTAL_USERNAME }}
          password: ${{ env.KBC_DEVELOPERPORTAL_PASSWORD }}
          tag: ${{ steps.tag.outputs.app_image_tag }}
          push_latest: ${{ steps.tag.outputs.is_semantic_tag }}
          source_image: ${{ env.APP_IMAGE}}

  tests:
    needs: build
    runs-on: ubuntu-latest
    # strategy:
    #   fail-fast: false
    #   matrix: ...
    steps:
      -
        name: Check out the repo
        uses: actions/checkout@v3
      -
        name: Pull image from ECR
        uses: keboola/action-pull-from-ecr@master
        with:
          vendor: ${{ env.KBC_DEVELOPERPORTAL_VENDOR }}
          app_id: ${{ env.KBC_DEVELOPERPORTAL_APP }}
          username: ${{ env.KBC_DEVELOPERPORTAL_USERNAME }}
          password: ${{ env.KBC_DEVELOPERPORTAL_PASSWORD }}
          tag: ${{ needs.build.outputs.app_image_tag }}
          target_image: ${{ env.APP_IMAGE}}
          tag_as_latest: true
      -
        name: Run tests
        run: |
          docker run \
          -e OAUTH_APP_NAME \
          -e OAUTH_APP_ID \
          -e OAUTH_APP_SECRET \
          -e OAUTH_ACCESS_TOKEN \
          -e OAUTH_REFRESH_TOKEN \
          -e TEST_SHAREPOINT_SITE \
          ${{env.APP_IMAGE}} composer ci

  tests-in-kbc:
    needs: build
    runs-on: ubuntu-latest
    steps:
      -
        name: Run KBC test jobs
        if: env.KBC_STORAGE_TOKEN && env.KBC_TEST_PROJECT_CONFIGS
        uses: keboola/action-run-configs-parallel@master
        with:
          token: ${{ env.KBC_STORAGE_TOKEN }}
          componentId: ${{ env.KBC_DEVELOPERPORTAL_APP }}
          tag: ${{ needs.build.outputs.app_image_tag }}
          configs: ${{ env.KBC_TEST_PROJECT_CONFIGS }}

  deploy:
    needs:
      - build
      - tests
      - tests-in-kbc
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') && needs.build.outputs.is_semantic_tag == 'true'
    steps:
      -
        name: Set tag in the Deloper Portal
        uses: keboola/action-set-tag-developer-portal@master
        with:
          vendor: ${{ env.KBC_DEVELOPERPORTAL_VENDOR }}
          app_id: ${{ env.KBC_DEVELOPERPORTAL_APP }}
          username: ${{ env.KBC_DEVELOPERPORTAL_USERNAME }}
          password: ${{ env.KBC_DEVELOPERPORTAL_PASSWORD }}
          tag: ${{ needs.build.outputs.app_image_tag }}


