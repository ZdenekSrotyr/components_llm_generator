Directory structure:
└── kds_consulting_team-datadirtest/
    ├── datadirtest/
    │   ├── datadirtest.py
    │   ├── __main__.py
    │   └── __init__.py
    ├── bitbucket-pipelines.yml
    ├── setup.py
    ├── tests/
    │   ├── test_datadirtest.py
    │   ├── resources_passing/
    │   │   ├── script.py
    │   │   ├── passing_scripts/
    │   │   │   ├── expected/
    │   │   │   │   └── data/
    │   │   │   │       └── out/
    │   │   │   │           ├── tables/
    │   │   │   │           │   └── table.csv
    │   │   │   │           └── files/
    │   │   │   │               └── .gitkeep
    │   │   │   └── source/
    │   │   │       ├── set_up.py
    │   │   │       ├── tear_down.py
    │   │   │       ├── post_run.py
    │   │   │       └── data/
    │   │   │           ├── config.json
    │   │   │           ├── in/
    │   │   │           │   └── files/
    │   │   │           │       └── .gitkeep
    │   │   │           └── out/
    │   │   │               └── files/
    │   │   │                   └── .gitkeep
    │   │   └── passing_scripts2/
    │   │       ├── expected/
    │   │       │   └── data/
    │   │       │       └── out/
    │   │       │           ├── tables/
    │   │       │           │   └── table.csv
    │   │       │           └── files/
    │   │       │               └── .gitkeep
    │   │       └── source/
    │   │           ├── set_up.py
    │   │           ├── tear_down.py
    │   │           ├── post_run.py
    │   │           └── data/
    │   │               ├── config.json
    │   │               ├── in/
    │   │               │   └── files/
    │   │               │       └── .gitkeep
    │   │               └── out/
    │   │                   └── files/
    │   │                       └── .gitkeep
    │   ├── chained_tests/
    │   │   ├── script.py
    │   │   └── chained_test/
    │   │       ├── set_up.py
    │   │       ├── tear_down.py
    │   │       ├── 02_test/
    │   │       │   ├── expected/
    │   │       │   │   └── data/
    │   │       │   │       └── out/
    │   │       │   │           ├── tables/
    │   │       │   │           │   └── table.csv
    │   │       │   │           └── files/
    │   │       │   │               └── .gitkeep
    │   │       │   └── source/
    │   │       │       ├── set_up.py
    │   │       │       ├── tear_down.py
    │   │       │       └── data/
    │   │       │           ├── config.json
    │   │       │           ├── in/
    │   │       │           │   └── files/
    │   │       │           │       └── .gitkeep
    │   │       │           └── out/
    │   │       │               └── files/
    │   │       │                   └── .gitkeep
    │   │       └── 01_test/
    │   │           ├── expected/
    │   │           │   └── data/
    │   │           │       └── out/
    │   │           │           ├── tables/
    │   │           │           │   └── table.csv
    │   │           │           └── files/
    │   │           │               └── .gitkeep
    │   │           └── source/
    │   │               ├── set_up.py
    │   │               ├── tear_down.py
    │   │               └── data/
    │   │                   ├── config.json
    │   │                   ├── in/
    │   │                   │   └── files/
    │   │                   │       └── .gitkeep
    │   │                   └── out/
    │   │                       └── files/
    │   │                           └── .gitkeep
    │   ├── chained_tests_artifacts/
    │   │   ├── script.py
    │   │   └── chained_test/
    │   │       ├── set_up.py
    │   │       ├── tear_down.py
    │   │       ├── 02_test/
    │   │       │   ├── expected/
    │   │       │   │   └── data/
    │   │       │   │       └── out/
    │   │       │   │           ├── tables/
    │   │       │   │           │   └── .gitkeep
    │   │       │   │           └── files/
    │   │       │   │               └── .gitkeep
    │   │       │   └── source/
    │   │       │       ├── set_up.py
    │   │       │       ├── tear_down.py
    │   │       │       └── data/
    │   │       │           ├── config.json
    │   │       │           ├── in/
    │   │       │           │   ├── tables/
    │   │       │           │   │   └── .gitkeep
    │   │       │           │   └── files/
    │   │       │           │       └── .gitkeep
    │   │       │           └── out/
    │   │       │               ├── tables/
    │   │       │               │   └── .gitkeep
    │   │       │               └── files/
    │   │       │                   └── .gitkeep
    │   │       └── 01_test/
    │   │           ├── expected/
    │   │           │   ├── data/
    │   │           │   │   └── out/
    │   │           │   │       ├── tables/
    │   │           │   │       │   └── .gitkeep
    │   │           │   │       └── files/
    │   │           │   │           └── .gitkeep
    │   │           │   └── artifacts/
    │   │           │       └── out/
    │   │           │           └── current/
    │   │           │               └── test.txt
    │   │           └── source/
    │   │               ├── set_up.py
    │   │               ├── tear_down.py
    │   │               └── data/
    │   │                   ├── config.json
    │   │                   ├── in/
    │   │                   │   └── files/
    │   │                   │       └── .gitkeep
    │   │                   └── out/
    │   │                       └── files/
    │   │                           └── .gitkeep
    │   ├── __init__.py
    │   ├── resources_passing_env_variables/
    │   │   ├── script.py
    │   │   └── passing_scripts/
    │   │       ├── expected/
    │   │       │   └── data/
    │   │       │       └── out/
    │   │       │           ├── tables/
    │   │       │           │   └── table.csv
    │   │       │           └── files/
    │   │       │               └── .gitkeep
    │   │       └── source/
    │   │           ├── set_up.py
    │   │           ├── tear_down.py
    │   │           └── data/
    │   │               ├── config.json
    │   │               ├── in/
    │   │               │   └── files/
    │   │               │       └── .gitkeep
    │   │               └── out/
    │   │                   └── files/
    │   │                       └── .gitkeep
    │   └── resources/
    │       ├── foldered_diff/
    │       │   ├── expected/
    │       │   │   └── data/
    │       │   │       └── out/
    │       │   │           ├── tables/
    │       │   │           │   └── .gitkeep
    │       │   │           └── files/
    │       │   │               ├── 7zipfiles/
    │       │   │               │   ├── DS_Store
    │       │   │               │   ├── contacts.csv
    │       │   │               │   └── contacts 2.csv
    │       │   │               └── files/
    │       │   │                   ├── contacts.csv
    │       │   │                   └── contacts 2.csv
    │       │   └── source/
    │       │       └── data/
    │       │           ├── config.json
    │       │           ├── in/
    │       │           │   └── files/
    │       │           │       ├── files.zip
    │       │           │       └── 7zipfiles.7z
    │       │           └── out/
    │       │               └── files/
    │       │                   ├── 7zipfiles/
    │       │                   │   ├── DS_Store
    │       │                   │   ├── contacts.csv
    │       │                   │   └── contacts 2.csv
    │       │                   └── files/
    │       │                       ├── contacts.csv
    │       │                       └── contacts 2.csv
    │       └── script.py
    ├── docs/
    │   └── html/
    │       └── datadirtest/
    │           ├── datadirtest.html
    │           └── index.html
    └── README.md

================================================
File: /datadirtest/datadirtest.py
================================================
import difflib
import filecmp
import importlib.util
import json
import logging
import os
import re
import shutil
import sys
import tempfile
import unittest
from importlib.abc import Loader
from os import path
from pathlib import Path
from runpy import run_path
from typing import List, Optional, Type, Literal


class TestDataDir(unittest.TestCase):
    """
    A test class that runs a component script to get a real output of a component and compares the output to the
    specified expected output of that component and its configuration
    """

    def __init__(
        self,
        data_dir: str,
        component_script: str,
        method_name: str = "compare_source_and_expected",
        context_parameters: Optional[dict] = None,
        last_state_override: dict = None,
        artefacts_path: str = None,
        artifact_current_destination: Literal["custom", "runs"] = "runs",
        save_output: bool = False,
    ):
        """
        Args:
            method_name (str): name of the testing method to be run
            data_dir (str): file_path to directory which holds the component config, source, and expected directories
            component_script (str): file_path to component script that should be run
            context_parameters (dict): Optional context parameters injected from the DirTester runner.
            last_state_override (dict): Optional component state override
            artefacts_path (str): Optional path to the artifacts that should be copied to the component data folder
            artifact_current_destination (str): Optional artifact's destination. Accepts 'custom' or 'runs' Default runs
            save_output (bool): If True, saves the output to output/--PATH-TO-THE-TEST-- directory
        """
        super(TestDataDir, self).__init__(methodName=method_name)
        self.component_script = component_script
        self.orig_dir = data_dir
        self.data_dir = self._create_temporary_copy()
        self._apply_env_variables()

        self.expected_path = path.join(data_dir, "expected")
        self.context_parameters = context_parameters
        self._input_state_override = last_state_override
        self.result_state = {}
        self._input_artifacts_override = artefacts_path
        self._artifact_current_destination = artifact_current_destination
        self.out_artifacts_path = None
        self._save_output = save_output

    def _apply_env_variables(self):
        # convert to string minified
        pattern = r"({{env.(.+)}})"
        cfg_string = open(self.source_config_path, "r").read()
        matches = re.findall(pattern, cfg_string)
        new_string = cfg_string
        for m in matches:
            replace_value = os.getenv(m[1])
            if not replace_value:
                raise ValueError(f"Environment variable {m[1]}  defined in config is missing")
            new_string = new_string.replace(m[0], replace_value)

        # replace with new version
        new_cfg = json.loads(new_string)
        with open(self.source_config_path, "w+") as outp:
            json.dump(new_cfg, outp)

    def setUp(self):
        self._override_input_state(self._input_state_override)
        self._override_input_artifacts()
        self._run_set_up_script()

    def run_post_run_script(self):
        post_script = os.path.join(self.orig_dir, "source", "post_run.py")
        self._run_script(post_script)

    def _run_set_up_script(self):
        start_script_path = os.path.join(self.orig_dir, "source", "set_up.py")
        self._run_script(start_script_path)

    def _run_script(self, custom_script_path: str):
        start_script_path = custom_script_path
        if os.path.exists(start_script_path):
            script = self._load_module_at_path(start_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    f"The {script_path} file was found but it does not implement the run(context) method. "
                    f"Please add the implementation"
                )

    def tearDown(self) -> None:
        self._collect_result_state()
        self._move_artifacts_to_tmp()
        self._run_tear_down_script()
        shutil.rmtree(self.data_dir)

    def _collect_result_state(self):
        result_state = {}
        state_file = os.path.join(self.source_data_dir, "out", "state.json")
        if os.path.exists(state_file):
            result_state = json.load(open(state_file, "r"))
        self.result_state = result_state

    def _move_artifacts_to_tmp(self) -> None:
        out_artifacts_path = os.path.join(self.source_data_dir, "artifacts", "out")
        if os.path.exists(out_artifacts_path) and os.listdir(out_artifacts_path):
            temp_dir = tempfile.mktemp(prefix="artifacts_")
            shutil.copytree(out_artifacts_path, temp_dir)
            self.out_artifacts_path = temp_dir

    @staticmethod
    def _load_module_at_path(run_script_path):
        spec = importlib.util.spec_from_file_location("custom_scripts", run_script_path)
        script = importlib.util.module_from_spec(spec)
        assert isinstance(spec.loader, Loader)
        spec.loader.exec_module(script)
        return script

    def _run_tear_down_script(self):
        end_script_path = os.path.join(self.orig_dir, "source", "tear_down.py")
        self._run_script(end_script_path)

    def _override_input_state(self, input_state: dict):
        """
        Overrides the input state with provided one. Run in setUp
        Args:
            input_state:

        Returns:

        """
        input_state = input_state or {}
        state_path = os.path.join(self.data_dir, "source", "data", "in", "state.json")
        Path(state_path).parent.mkdir(parents=True, exist_ok=True)
        with open(state_path, "w+") as inp:
            json.dump(input_state, inp)

    def _override_input_artifacts(self):
        """
        Copies the artifacts from the provided temp path to the artifacts/in folder
        Args:

        Returns:

        """
        if in_artifacts_path := self._input_artifacts_override:
            new_artifacts_path = os.path.join(self.data_dir, "source", "data", "artifacts", "in")
            if os.path.exists(new_artifacts_path):
                shutil.rmtree(new_artifacts_path)
            shutil.copytree(in_artifacts_path, new_artifacts_path)

            if self._artifact_current_destination == "runs":
                shutil.move(new_artifacts_path + "/current", new_artifacts_path + "/runs/jobId-1122334455")

            elif self._artifact_current_destination == "custom":
                shutil.move(new_artifacts_path + "/current", new_artifacts_path + "/custom/jobId-1122334455")

    def id(self):
        return path.basename(self.orig_dir)

    def shortDescription(self) -> Optional[str]:
        return path.basename(self.orig_dir)

    def _create_temporary_copy(self):
        temp_dir = tempfile.mkdtemp(prefix=Path(self.orig_dir).name, dir="/tmp")
        dst_path = os.path.join(temp_dir, "test_data")
        if os.path.exists(dst_path):
            shutil.rmtree(dst_path)
        if not os.path.exists(self.orig_dir):
            raise ValueError(f"{self.orig_dir} does not exist. ")
        shutil.copytree(self.orig_dir, dst_path)
        return dst_path

    def run_component(self):
        """
        Runs a component script with a specified configuration
        """
        os.environ["KBC_DATADIR"] = self.source_data_dir
        run_path(self.component_script, run_name="__main__")

    def compare_source_and_expected(self):
        """
        Executes and compares source and expected directories based on the nested directory structure and files
        within them

        """
        logging.info(f"Running {self.component_script} with configuration from {self.data_dir}")
        self.run_component()
        self.run_post_run_script()

        files_expected_path, tables_expected_path = self.get_data_paths(self.data_dir, "expected")
        files_real_path, tables_real_path = self.get_data_paths(self.data_dir, "source")

        if path.exists(files_expected_path) or path.exists(files_real_path):
            self.assert_directory_structure_match(files_expected_path, files_real_path)
            self.assert_directory_files_contents_match(files_expected_path, files_real_path)
        if path.exists(tables_expected_path) or path.exists(tables_real_path):
            self.assert_directory_structure_match(tables_expected_path, tables_real_path)
            self.assert_directory_files_contents_match(tables_expected_path, tables_real_path)

        if self._save_output:
            self._save_test_output()

        logging.info("Tests passed successfully ")

    @staticmethod
    def get_data_paths(data_dir: str, dir_type: str):
        """
        Uses the Keboola data structure to return paths to files and tables

        Args:
            data_dir: file_path of directory to get file and table paths from
            dir_type: type of directory source or expected

        Returns:
            paths to files and tables
        """
        files_expected_path = path.join(data_dir, dir_type, "data", "out", "files")
        tables_expected_path = path.join(data_dir, dir_type, "data", "out", "tables")
        return files_expected_path, tables_expected_path

    @staticmethod
    def get_all_files_in_dir(dir_path: str):
        """
        Gets all non-hidden files from a directory and its subdirectory

        Args:
            dir_path: file_path of directory to fetch files from

        Returns:
            list of files in the directory
        """
        files = []
        for sub_dir, dir_names, file_names in os.walk(dir_path):
            for filename in [f for f in file_names if not f.startswith(".")]:
                files.append(os.path.join(sub_dir, filename))
        return files

    def assert_directory_structure_match(self, expected_path: str, real_path: str):
        """
        Tests whether directory structures of two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            expected_path: Path holding the directory of expected files
            real_path: Path holding the directory of real/source files
        """
        compared_dir = filecmp.dircmp(expected_path, real_path)

        left = [file for file in compared_dir.left_only if not file.startswith(".")]
        right = [file for file in compared_dir.right_only if not file.startswith(".")]

        self.assertEqual(left, [], f" Files : {left} exists only in expected output and not in actual output")
        self.assertEqual(right, [], f" Files : {right} exists only in actual output and not in expected output")

    def assert_directory_files_contents_match(self, files_expected_path: str, files_real_path: str):
        """
        Tests whether files in two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            files_expected_path:  Path holding expected files
            files_real_path: Path holding real/source files
        """
        file_paths = self.get_all_files_in_dir(files_expected_path)
        common_files = [file.replace(files_expected_path, "").strip("/").strip("\\") for file in file_paths]
        equal, mismatch, errors = filecmp.cmpfiles(files_expected_path, files_real_path, common_files, shallow=False)
        if mismatch:
            differences, diff_a, diff_b = self._print_file_differences(mismatch, files_expected_path, files_real_path)
            self.assertEqual(diff_a, diff_b, f"Different lines: \n {differences}")
        self.assertEqual(errors, [], f"Files: {errors} could not be compared")

    def _print_file_differences(self, mismatched_files: List[str], expected_folder: str, real_folder: str):
        differences = ""
        diff_a = []
        diff_b = []
        for mis_file in mismatched_files:
            source_path = os.path.join(real_folder, mis_file)
            expected_path = os.path.join(expected_folder, mis_file)

            with open(source_path, "r") as f1, open(expected_path, "r") as f2:
                if source_path.endswith(".manifest"):
                    diff = difflib.unified_diff(
                        json.dumps(json.loads(f1.read())).splitlines(),
                        json.dumps(json.loads(f2.read())).splitlines(),
                        fromfile=source_path,
                        tofile=expected_path,
                    )

                else:
                    diff = difflib.unified_diff(
                        f1.readlines(), f2.readlines(), fromfile=source_path, tofile=expected_path
                    )

                for line in diff:
                    if line.startswith("-") and not line.startswith("---"):
                        line_number = len(diff_a) + 1
                        diff_a.append(f"L#{line_number}|{line[1:]}")
                        differences += f"L# {line_number} | {line[1:]}\n"
                    elif line.startswith("+") and not line.startswith("+++"):
                        line_number = len(diff_b) + 1
                        diff_b.append(f"L#{line_number}|{line[1:]}")
                        differences += f"L# {line_number} | {line[1:]}\n"

            differences += "\n" + "==" * 30
        return differences, diff_a, diff_b

    @property
    def source_data_dir(self) -> str:
        return path.join(self.data_dir, "source", "data")

    @property
    def source_config_path(self) -> str:
        return path.join(self.source_data_dir, "config.json")

    def _save_test_output(self):
        """
        Saves the test output to results/--NAME-OF-THE-TEST--/data directory
        """
        results_dir = path.join("output", self.orig_dir, "data")
        source_data = path.join(self.data_dir, "source", "data")

        if path.exists(source_data):
            if path.exists(results_dir):
                shutil.rmtree(results_dir)
            shutil.copytree(source_data, results_dir)


class TestChainedDatadirTest(unittest.TestCase):
    """
    A test class that runs a chain of Datadir Tests that pass each other a statefile.
    """

    def __init__(
        self,
        data_dir: str,
        component_script: str,
        method_name: str = "compare_source_and_expected",
        context_parameters: Optional[dict] = None,
        test_data_dir_class: Type[TestDataDir] = TestDataDir,
        artifact_current_destination: Literal["custom", "runs"] = "runs",
        save_output: bool = False,
    ):
        """
        Args:
            method_name (str): name of the testing method to be run
            data_dir (str): file_path to directory which holds the chained tests
            component_script (str): file_path to component script that should be run
            context_parameters (dict): Optional context parameters injected from the DirTester runner.
            artifact_current_destination (str): Optional artifact's destination. Accepts 'custom' or 'runs' Default runs
            save_output (bool): If True, saves the output of each test to results/--NAME-OF-THE-TEST--/data directory
        """
        super(TestChainedDatadirTest, self).__init__()

        self._component_script = component_script
        self._context_parameters = context_parameters
        self.__test_class = test_data_dir_class
        self._chained_tests_directory = data_dir
        self._chained_tests_method = method_name
        self._artifact_current_destination = artifact_current_destination
        self._save_output = save_output

    def runTest(self):
        """
        This runs the chain of tests
        Returns:

        """
        last_state = None
        last_artifacts_path = None
        test_runner = unittest.TextTestRunner(verbosity=3, stream=sys.stdout)
        for test_dir in self._get_testing_dirs(self._chained_tests_directory):
            test = self._build_test(test_dir, last_state, last_artifacts_path)
            result = test_runner.run(test)
            if not result.wasSuccessful():
                self.fail(
                    f"Chained test {self.shortDescription()}-{test.shortDescription()} "
                    f"failed:\n {result.errors + result.failures}"
                )
            last_state = test.result_state
            last_artifacts_path = test.out_artifacts_path or None

    def setUp(self):
        self._run_set_up_script()

    def _run_set_up_script(self):
        start_script_path = os.path.join(self._chained_tests_directory, "set_up.py")
        if os.path.exists(start_script_path):
            script = self._load_module_at_path(start_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    "The set_up.py file was found but it does not implement the run(context) method. Please add the "
                    "implementation"
                )

    def tearDown(self) -> None:
        self._run_tear_down_script()

    def _build_test(self, testing_dir, state_override: dict = None, artefacts_path: str = None) -> TestDataDir:
        return self.__test_class(
            method_name=self._chained_tests_method,
            data_dir=testing_dir,
            component_script=self._component_script,
            context_parameters=self._context_parameters,
            last_state_override=state_override,
            artefacts_path=artefacts_path,
            artifact_current_destination=self._artifact_current_destination,
            save_output=self._save_output,
        )

    @staticmethod
    def _get_testing_dirs(data_dir: str) -> List:
        """
        Gets directories within a directory that do not start with an underscore, sorted alphabetically.

        Args:
            data_dir: directory which holds directories

        Returns:
            list of paths inside directory
        """
        return sorted(
            [
                os.path.join(data_dir, o)
                for o in os.listdir(data_dir)
                if os.path.isdir(os.path.join(data_dir, o)) and not o.startswith("_")
            ]
        )

    @staticmethod
    def _load_module_at_path(run_script_path):
        spec = importlib.util.spec_from_file_location("custom_scripts", run_script_path)
        script = importlib.util.module_from_spec(spec)
        assert isinstance(spec.loader, Loader)
        spec.loader.exec_module(script)
        return script

    def _run_tear_down_script(self):
        end_script_path = os.path.join(self._chained_tests_directory, "tear_down.py")
        if os.path.exists(end_script_path):
            script = self._load_module_at_path(end_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    "The tear_down.py file was found but it does not implement the run(context) method. Please add the "
                    "implementation"
                )

    def id(self):
        return path.basename(self._chained_tests_directory)

    def shortDescription(self) -> Optional[str]:
        return path.basename(self._chained_tests_directory)


class DataDirTester:
    """
    Object that executes functional tests of the Keboola Connection components.

    The `DataDirTester` looks for the `component.py` script and executes it against the specified source folders,
    the `component.py` should expect the data folder path in the environment variable `KBC_DATADIR`.

    Each test is specified by a folder containing following folder structure:

    - `source` - contains data folder that would be on the input of the component
    - `expected` - contains data folder that is result of the execution against the `source` folder.
    Include only folder that contain some files, e.g. `expected/files/out/file.json`
    """

    def __init__(
        self,
        data_dir: str = Path("./tests/functional").absolute().as_posix(),
        component_script: str = Path("./src/component.py").absolute().as_posix(),
        test_data_dir_class: Type[TestDataDir] = TestDataDir,
        context_parameters: Optional[dict] = None,
        artifact_current_destination: Literal["custom", "runs"] = "runs",
        save_output: bool = False,
        selected_tests: Optional[List[str]] = None,
    ):
        """

        Args:
            data_dir (str): file_path to directory that holds functional test directories. By default this is
            ./functional
            component_script (str): file_path to the component script. By default this is ../src/component.py
            context_parameters (dict): dictionary with optional parameters that will be passed to each Test instance.
            Usefull when overriding the TestDataDirClass to add custom functionality
            test_data_dir_class (Type[TestDataDir]): Class extending datadirtest.TestDataDir class with additional
            functionality. It will be used for each test in the suit.
            save_output (bool): If True, saves the output of each test to results/--NAME-OF-THE-TEST--/data directory
            selected_tests (List[str]): Optional list of test names to run. If not provided, all tests will be run.
        """
        self._data_dir = data_dir
        self._component_script = component_script
        self._context_parameters = context_parameters or {}
        self.__test_class = test_data_dir_class
        self._artifact_current_destination = artifact_current_destination
        self._save_output = save_output or os.environ.get("DIRTEST_SAVE_OUTPUT")
        self._selected_tests = selected_tests or os.environ.get("DIRTEST_SELECTED_TESTS", "").split(",")

    def run(self):
        """
        Runs functional tests specified in the provided folder based on the source/expected datadirs.
        """
        testing_dirs = self._get_testing_dirs(self._data_dir)
        if self._selected_tests and self._selected_tests != [""]:
            testing_dirs = [d for d in testing_dirs if path.basename(d) in self._selected_tests]
            if not testing_dirs:
                raise ValueError(
                    f"None of the specified test names {self._selected_tests} were found in {self._data_dir}"
                )

        dir_test_suite = self._build_dir_test_suite(testing_dirs)
        test_runner = unittest.TextTestRunner(verbosity=3)
        result = test_runner.run(dir_test_suite)
        if not result.wasSuccessful():
            raise AssertionError(f"Functional test suite failed. {result.errors + result.failures}")

    @staticmethod
    def _get_testing_dirs(data_dir: str) -> List:
        """
        Gets directories within a directory that do not start with an underscore

        Args:
            data_dir: directory which holds directories

        Returns:
            list of paths inside directory
        """
        return [
            os.path.join(data_dir, o)
            for o in os.listdir(data_dir)
            if os.path.isdir(os.path.join(data_dir, o)) and not o.startswith("_")
        ]

    def _build_dir_test_suite(self, testing_dirs):
        """
        Creates a test suite for a directory, each test is added using addTest to pass through parameters

        Args:
            testing_dirs: directories that holds data for the test

        Returns:
            Unittest Suite containing all functional tests

        """
        suite = unittest.TestSuite()
        for testing_dir in testing_dirs:
            if self._is_chained_test(testing_dir):
                test = TestChainedDatadirTest(
                    data_dir=testing_dir,
                    component_script=self._component_script,
                    context_parameters=self._context_parameters,
                    test_data_dir_class=self.__test_class,
                    artifact_current_destination=self._artifact_current_destination,
                    save_output=self._save_output,
                )
            else:
                test = self.__test_class(
                    method_name="compare_source_and_expected",
                    data_dir=testing_dir,
                    component_script=self._component_script,
                    context_parameters=self._context_parameters,
                    save_output=self._save_output,
                )

            suite.addTest(test)
        return suite

    def _is_chained_test(self, directory_path: str):
        directories = [
            o
            for o in os.listdir(directory_path)
            if os.path.isdir(os.path.join(directory_path, o)) and not o.startswith("_")
        ]
        if {"source", "expected"}.issubset(directories):
            return False
        elif len(directories) > 0:
            return True
        else:
            raise ValueError(
                f"The functional folder {directory_path} is invalid. It needs to either contain "
                f'"source" and "expected" folders or contain directories of chained tests'
            )


if __name__ == "__main__":
    data_dir_path = sys.argv[1]
    data_dir_tester = DataDirTester(data_dir_path)

    if len(sys.argv) == 3:
        script_path = sys.argv[2]
        data_dir_tester = DataDirTester(data_dir_path, component_script=script_path)

    data_dir_tester.run()


================================================
File: /datadirtest/__main__.py
================================================
"""Main entry point"""

import sys

from .datadirtest import DataDirTester

if __name__ == "__main__":
    data_dir_path = sys.argv[1]
    data_dir_tester = DataDirTester(data_dir_path)

    if len(sys.argv) == 3:
        script_path = sys.argv[2]
        data_dir_tester = DataDirTester(data_dir_path, component_script=script_path)

    data_dir_tester.run()


================================================
File: /datadirtest/__init__.py
================================================
from .datadirtest import DataDirTester, TestDataDir

__all__ = ['datadirtest']


================================================
File: /bitbucket-pipelines.yml
================================================
image: python:3.8.2
options:
  docker: false

pipelines:
  default:
    - step:
        script:
          - python -m unittest discover tests
          # push test image to ecr - uncomment for testing before deployment
#          - echo 'Pushing test image to repo. [tag=test]'
#          - export REPOSITORY=`docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP`
#          - docker tag $APP_IMAGE:latest $REPOSITORY:test
#          - eval $(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)
#          - docker push $REPOSITORY:test


================================================
File: /setup.py
================================================
from distutils.core import setup
import setuptools

setup(
    name='datadirtest',
    version='1.8.3',
    setup_requires=['setuptools_scm'],
    install_requires=['pathlib'],
    url='https://bitbucket.org/kds_consulting_team/datadirtest',
    download_url='https://bitbucket.org/kds_consulting_team/datadirtest',
    packages=setuptools.find_packages(),
    test_suite='tests',
    license="MIT"
)


================================================
File: /tests/test_datadirtest.py
================================================
import os
import sys
import textwrap
import unittest
from contextlib import contextmanager
from io import StringIO
from typing import Optional

from datadirtest import DataDirTester, TestDataDir


@contextmanager
def captured_output():
    new_out, new_err = StringIO(), StringIO()
    old_out, old_err = sys.stdout, sys.stderr
    try:
        sys.stdout, sys.stderr = new_out, new_err
        yield sys.stdout, sys.stderr
    finally:
        sys.stdout, sys.stderr = old_out, old_err


class TestComponent(unittest.TestCase):

    def setUp(self) -> None:
        self.test_datadirs = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                          'resources')

        self.test_datadirs_passing = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                                  'resources_passing')
        self.test_datadirs_passing_env = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                                      'resources_passing_env_variables')

        self.test_datadirs_chained = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                                  'chained_tests')

        self.test_datadirs_chained_artifacts = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                                  'chained_tests_artifacts')

        self.mock_datadirtest = TestDataDir(os.path.join(self.test_datadirs_passing, 'passing_scripts'), '')

    def test_nested_different_content_fails(self):
        expected = os.path.join(self.test_datadirs, 'foldered_diff', 'expected')
        source = os.path.join(self.test_datadirs, 'foldered_diff', 'source')
        with self.assertRaises(AssertionError):
            self.mock_datadirtest.assert_directory_files_contents_match(expected, source)

    def test_error_in_suite(self):
        tester = DataDirTester(self.test_datadirs, os.path.join(self.test_datadirs, 'script.py'))

        with self.assertRaises(AssertionError):
            tester.run()

    def test_passing_with_scripts(self):
        tester = DataDirTester(self.test_datadirs_passing, os.path.join(self.test_datadirs_passing, 'script.py'))
        with captured_output() as (out, err):
            tester.run()
        output = out.getvalue().strip()
        self.assertEqual(output, 'setUp\nfile created\npostRun\ntearDown\nsetUp\nfile created\npostRun\ntearDown'"")

    def test_passing_with_env(self):
        tester = DataDirTester(self.test_datadirs_passing_env,
                               os.path.join(self.test_datadirs_passing_env, 'script.py'))
        os.environ['bool2_col'] = 'bool_bool2'
        os.environ['time_col'] = 'time_submitted'
        with captured_output() as (out, err):
            tester.run()
        output = out.getvalue().strip()
        self.assertEqual(output, 'setUp\nfile created\ntearDown')

    def test_chained_tests(self):
        tester = DataDirTester(self.test_datadirs_chained, os.path.join(self.test_datadirs_chained, 'script.py'))
        with captured_output() as (out, err):
            tester.run()

    def test_context_parameters(self):
        class CustomDatadirTest(TestDataDir):

            def __init__(self, data_dir: str, component_script: str, method_name: str = 'compare_source_and_expected',
                         context_parameters: Optional[dict] = None, save_output: bool = False):
                super().__init__(data_dir, component_script, 'test_method', context_parameters, save_output=save_output)

            def test_method(self):
                print(self.context_parameters['custom_parameter'])

        injected_value = 'injected_parameter'
        tester = DataDirTester(self.test_datadirs, os.path.join(self.test_datadirs, 'script.py'),
                               test_data_dir_class=CustomDatadirTest,
                               context_parameters={'custom_parameter': injected_value})

        with captured_output() as (out, err):
            tester.run()

        output = out.getvalue().strip()
        self.assertEqual(output, injected_value)

    def test_chained_tests_with_artifacts(self):

        tester = DataDirTester(self.test_datadirs_chained_artifacts,
                                     os.path.join(self.test_datadirs_chained_artifacts, 'script.py'))

        with captured_output() as (out, err):
            tester.run()

        output = out.getvalue().strip()
        self.assertIn(textwrap.dedent("""
            Found artefact in the previous run: artefact.txt
            Found artefact in the shared artifacts: artefact-shared.txt"""), output)

    def test_chained_tests_with_artifacts_custom(self):
        tester = DataDirTester(self.test_datadirs_chained_artifacts,
                               os.path.join(self.test_datadirs_chained_artifacts, 'script.py'),
                               artifact_current_destination='custom')

        with captured_output() as (out, err):
            tester.run()

        output = out.getvalue().strip()
        self.assertIn(textwrap.dedent("""
            Found artefact in the shared artifacts: artefact-shared.txt
            Found custom artifact: artefact.txt"""), output)

if __name__ == "__main__":
    # import sys;sys.argv = ['', 'Test.testName']
    unittest.main()


================================================
File: /tests/resources_passing/script.py
================================================
import os
from pathlib import Path

if __name__ == "__main__":
    data_dir = Path(os.environ["KBC_DATADIR"])

    out_file = Path(f'{os.environ["KBC_DATADIR"]}/out/tables/table.csv')
    out_file.parent.mkdir(parents=True, exist_ok=True)

    open(out_file, 'a').close()
    print('file created')


================================================
File: /tests/resources_passing/passing_scripts/source/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('setUp')


================================================
File: /tests/resources_passing/passing_scripts/source/tear_down.py
================================================
from datadirtest import TestDataDir

def run(context: TestDataDir):
    print('tearDown')


================================================
File: /tests/resources_passing/passing_scripts/source/post_run.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('postRun')


================================================
File: /tests/resources_passing/passing_scripts/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"bool_bool2",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"time_submitted",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/resources_passing/passing_scripts2/source/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('setUp')


================================================
File: /tests/resources_passing/passing_scripts2/source/tear_down.py
================================================
from datadirtest import TestDataDir

def run(context: TestDataDir):
    print('tearDown')


================================================
File: /tests/resources_passing/passing_scripts2/source/post_run.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('postRun')


================================================
File: /tests/resources_passing/passing_scripts2/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"bool_bool2",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"time_submitted",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/chained_tests/script.py
================================================
import json
import os
from pathlib import Path

if __name__ == "__main__":
    data_dir = Path(os.environ["KBC_DATADIR"])

    in_state_path = Path(f'{os.environ["KBC_DATADIR"]}/in/state.json')
    last_value = 'state'
    if os.path.exists(in_state_path):
        with open(in_state_path, 'r') as inp:
            last_state = json.load(inp)
            last_value = last_state.get('last_value') + '02' if last_state.get('last_value') else last_value

    out_file = Path(f'{os.environ["KBC_DATADIR"]}/out/tables/table.csv')
    out_file.parent.mkdir(parents=True, exist_ok=True)

    with open(out_file, 'w+') as outp:
        outp.write(last_value)

    out_state = Path(f'{os.environ["KBC_DATADIR"]}/out/state.json')
    with open(out_state, 'w+') as state_out:
        json.dump({"last_value": last_value}, state_out)

    print('file created')


================================================
File: /tests/chained_tests/chained_test/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('Chained root setUp')


================================================
File: /tests/chained_tests/chained_test/tear_down.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('Chained root tearDown')


================================================
File: /tests/chained_tests/chained_test/02_test/expected/data/out/tables/table.csv
================================================
state02

================================================
File: /tests/chained_tests/chained_test/02_test/source/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('setUp2')


================================================
File: /tests/chained_tests/chained_test/02_test/source/tear_down.py
================================================
from datadirtest import TestDataDir

def run(context: TestDataDir):
    print('tearDown2')


================================================
File: /tests/chained_tests/chained_test/02_test/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"bool_bool2",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"time_submitted",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/chained_tests/chained_test/01_test/expected/data/out/tables/table.csv
================================================
state

================================================
File: /tests/chained_tests/chained_test/01_test/source/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('setUp1')


================================================
File: /tests/chained_tests/chained_test/01_test/source/tear_down.py
================================================
from datadirtest import TestDataDir

def run(context: TestDataDir):
    print('tearDown1')


================================================
File: /tests/chained_tests/chained_test/01_test/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"bool_bool2",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"time_submitted",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/chained_tests_artifacts/script.py
================================================
import json
import os
from pathlib import Path
import logging

if __name__ == "__main__":
    data_dir = Path(os.environ["KBC_DATADIR"])
    Path.mkdir(data_dir / 'out' / 'tables', parents=True, exist_ok=True)


    print('file created')

    try:
        with os.scandir(Path.joinpath(data_dir, 'artifacts/in/runs/')) as runs:
            for run in runs:
                for file in os.listdir(run):
                    print(f"Found artefact in the previous run: {file}")
    except FileNotFoundError:
        logging.error("No previous run artefacts found")

    try:
        for file in os.listdir(Path.joinpath(data_dir, 'artifacts/in/shared/')):
            print(f"Found artefact in the shared artifacts: {file}")

    except FileNotFoundError:
        logging.error("No shared artefacts found")

    try:
        with os.scandir(Path.joinpath(data_dir, 'artifacts/in/custom/')) as runs:
            for run in runs:
                for file in os.listdir(run):
                    print(f"Found custom artifact: {file}")

    except FileNotFoundError:
        logging.error("No custom artefacts found")

    current_artifact_out_path = Path.joinpath(data_dir, 'artifacts/out/current/artefact.txt')
    current_artifact_out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(current_artifact_out_path, 'w') as f:
        f.write('test')

    shared_artifact_out_path = Path.joinpath(data_dir, 'artifacts/out/shared/artefact-shared.txt')
    shared_artifact_out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(shared_artifact_out_path, 'w') as f:
        f.write('test')
    pass

================================================
File: /tests/chained_tests_artifacts/chained_test/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('Chained root setUp')


================================================
File: /tests/chained_tests_artifacts/chained_test/tear_down.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('Chained root tearDown')


================================================
File: /tests/chained_tests_artifacts/chained_test/02_test/source/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('setUp2')


================================================
File: /tests/chained_tests_artifacts/chained_test/02_test/source/tear_down.py
================================================
from datadirtest import TestDataDir

def run(context: TestDataDir):
    print('tearDown2')


================================================
File: /tests/chained_tests_artifacts/chained_test/02_test/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"bool_bool2",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"time_submitted",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/chained_tests_artifacts/chained_test/01_test/expected/artifacts/out/current/test.txt
================================================
test

================================================
File: /tests/chained_tests_artifacts/chained_test/01_test/source/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('setUp1')


================================================
File: /tests/chained_tests_artifacts/chained_test/01_test/source/tear_down.py
================================================
from datadirtest import TestDataDir

def run(context: TestDataDir):
    print('tearDown1')


================================================
File: /tests/chained_tests_artifacts/chained_test/01_test/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"bool_bool2",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"time_submitted",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/resources_passing_env_variables/script.py
================================================
import os
from pathlib import Path

if __name__ == "__main__":
    data_dir = Path(os.environ["KBC_DATADIR"])

    out_file = Path(f'{os.environ["KBC_DATADIR"]}/out/tables/table.csv')
    out_file.parent.mkdir(parents=True, exist_ok=True)

    open(out_file, 'a').close()
    print('file created')


================================================
File: /tests/resources_passing_env_variables/passing_scripts/source/set_up.py
================================================
from datadirtest import TestDataDir


def run(context: TestDataDir):
    print('setUp')


================================================
File: /tests/resources_passing_env_variables/passing_scripts/source/tear_down.py
================================================
from datadirtest import TestDataDir

def run(context: TestDataDir):
    print('tearDown')


================================================
File: /tests/resources_passing_env_variables/passing_scripts/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"{{env.bool2_col}}",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"{{env.time_col}}",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/resources/foldered_diff/expected/data/out/files/7zipfiles/contacts.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboola

================================================
File: /tests/resources/foldered_diff/expected/data/out/files/7zipfiles/contacts 2.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboola

================================================
File: /tests/resources/foldered_diff/expected/data/out/files/files/contacts.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboola

================================================
File: /tests/resources/foldered_diff/expected/data/out/files/files/contacts 2.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboola

================================================
File: /tests/resources/foldered_diff/source/data/config.json
================================================
{
  "parameters": {
      "delimiter" : "_"
      ,"column_types":[
          {"column":"bool_bool2",
           "type":"number"},
           {"column":"bool_bool1",
            "type":"bool"},
          {"column":"id",
           "type":"string"},
          {"column":"field.id",
           "type":"string"},
          {"column":"ansconcat",
           "type":"string"},
          {"column":"time_submitted",
           "type":"string"}
      ],
    "extract_to_folder" : true
  },
  "image_parameters": {}
}

================================================
File: /tests/resources/foldered_diff/source/data/out/files/7zipfiles/contacts.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboola

================================================
File: /tests/resources/foldered_diff/source/data/out/files/7zipfiles/contacts 2.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboola

================================================
File: /tests/resources/foldered_diff/source/data/out/files/files/contacts.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboolaa

================================================
File: /tests/resources/foldered_diff/source/data/out/files/files/contacts 2.csv
================================================
first_name;last_name;Email;company
Adam;Smith;smith@keboola.com;Keboola
David;Dmith;dmith@keboola.com;Deboola
Leos;Lmith;lmith@keboola.com;Leboola

================================================
File: /tests/resources/script.py
================================================
if __name__ == "__main__":
    print("running test")

================================================
File: /docs/html/datadirtest/datadirtest.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>datadirtest.datadirtest API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>datadirtest.datadirtest</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import filecmp
import importlib.util
import logging
import os
import shutil
import sys
import tempfile
import unittest
from importlib.abc import Loader
from os import path
from pathlib import Path
from runpy import run_path
from typing import List, Optional, Type


class TestDataDir(unittest.TestCase):
    &#34;&#34;&#34;
    A test class that runs a component script to get a real output of a component and compares the output to the
    specified expected output of that component and its configuration
    &#34;&#34;&#34;

    def __init__(self, data_dir: str, component_script: str, method_name: str = &#39;compare_source_and_expected&#39;,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;
        Args:
            method_name (str): name of the testing method to be run
            data_dir (str): file_path to directory which holds the component config, source, and expected directories
            component_script (str): file_path to component script that should be run
            context_parameters (dict): Optional context parameters injected from the DirTester runner.
        &#34;&#34;&#34;
        super(TestDataDir, self).__init__(methodName=method_name)
        self.component_script = component_script
        self.orig_dir = data_dir
        self.expected_path = path.join(data_dir, &#39;expected&#39;)
        self.context_parameters = context_parameters

    def setUp(self):
        self.data_dir = self._create_temporary_copy()
        self._run_set_up_script()

    def _run_set_up_script(self):
        start_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;set_up.py&#39;)
        if os.path.exists(start_script_path):
            script = self._load_module_at_path(start_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The set_up.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def tearDown(self) -&gt; None:
        self._run_tear_down_script()
        shutil.rmtree(self.data_dir)

    @staticmethod
    def _load_module_at_path(run_script_path):
        spec = importlib.util.spec_from_file_location(&#34;custom_scripts&#34;, run_script_path)
        script = importlib.util.module_from_spec(spec)
        assert isinstance(spec.loader, Loader)
        spec.loader.exec_module(script)
        return script

    def _run_tear_down_script(self):
        end_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;tear_down.py&#39;)
        if os.path.exists(end_script_path):
            script = self._load_module_at_path(end_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The tear_down.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def id(self):
        return path.basename(self.orig_dir)

    def shortDescription(self) -&gt; Optional[str]:
        return path.basename(self.orig_dir)

    def _create_temporary_copy(self):
        temp_dir = tempfile.gettempdir()
        dst_path = path.join(temp_dir, &#39;test_data&#39;)
        if path.exists(dst_path):
            shutil.rmtree(dst_path)

        shutil.copytree(self.orig_dir, dst_path)
        return dst_path

    def run_component(self):
        &#34;&#34;&#34;
        Runs a component script with a specified configuration
        &#34;&#34;&#34;
        source_dir = path.join(self.data_dir, &#34;source&#34;, &#34;data&#34;)
        os.environ[&#34;KBC_DATADIR&#34;] = source_dir
        run_path(self.component_script, run_name=&#39;__main__&#39;)

    def compare_source_and_expected(self):
        &#34;&#34;&#34;
        Executes and compares source and expected directories based on the nested directory structure and files
        within them

        &#34;&#34;&#34;
        logging.info(f&#34;Running {self.component_script} with configuration from {self.data_dir}&#34;)
        self.run_component()

        files_expected_path, tables_expected_path = self.get_data_paths(self.data_dir, &#39;expected&#39;)
        files_real_path, tables_real_path = self.get_data_paths(self.data_dir, &#39;source&#39;)

        if path.exists(files_expected_path) or path.exists(files_real_path):
            self.assert_directory_structure_match(files_expected_path, files_real_path)
            self.assert_directory_files_contents_match(files_expected_path, files_real_path)
        if path.exists(tables_expected_path) or path.exists(tables_real_path):
            self.assert_directory_structure_match(tables_expected_path, tables_real_path)
            self.assert_directory_files_contents_match(tables_expected_path, tables_real_path)
        logging.info(&#34;Tests passed successfully &#34;)

    @staticmethod
    def get_data_paths(data_dir: str, dir_type: str):
        &#34;&#34;&#34;
        Uses the Keboola data structure to return paths to files and tables

        Args:
            data_dir: file_path of directory to get file and table paths from
            dir_type: type of directory source or expected

        Returns:
            paths to files and tables
        &#34;&#34;&#34;
        files_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;files&#39;)
        tables_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;tables&#39;)
        return files_expected_path, tables_expected_path

    @staticmethod
    def get_all_files_in_dir(dir_path: str):
        &#34;&#34;&#34;
        Gets all non-hidden files from a directory and its subdirectory

        Args:
            dir_path: file_path of directory to fetch files from

        Returns:
            list of files in the directory
        &#34;&#34;&#34;
        files = []
        for sub_dir, dir_names, file_names in os.walk(dir_path):
            for filename in [f for f in file_names if not f.startswith(&#34;.&#34;)]:
                files.append(os.path.join(sub_dir, filename))
        return files

    def assert_directory_structure_match(self, expected_path: str, real_path: str):
        &#34;&#34;&#34;
        Tests whether directory structures of two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            expected_path: Path holding the directory of expected files
            real_path: Path holding the directory of real/source files
        &#34;&#34;&#34;
        compared_dir = filecmp.dircmp(expected_path, real_path)

        left = [file for file in compared_dir.left_only if not file.startswith(&#39;.&#39;)]
        right = [file for file in compared_dir.right_only if not file.startswith(&#39;.&#39;)]

        self.assertEqual(left, [], f&#34; Files : {left} exists only in expected output and not in actual output&#34;)
        self.assertEqual(right, [], f&#34; Files : {right} exists only in actual output and not in expected output&#34;)

    def assert_directory_files_contents_match(self, files_expected_path: str, files_real_path: str):
        &#34;&#34;&#34;
        Tests whether files in two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            files_expected_path:  Path holding expected files
            files_real_path: Path holding real/source files
        &#34;&#34;&#34;
        file_paths = self.get_all_files_in_dir(files_expected_path)
        common_files = [file.replace(files_expected_path, &#34;&#34;).strip(&#34;/&#34;).strip(&#39;\\&#39;) for file in file_paths]
        equal, mismatch, errors = filecmp.cmpfiles(files_expected_path, files_real_path, common_files, shallow=False)
        self.assertEqual(mismatch, [], f&#34; Files : {mismatch} do not match&#34;)
        self.assertEqual(errors, [], f&#34; Files : {errors} could not be compared&#34;)


class DataDirTester:
    &#34;&#34;&#34;
        Object that executes functional tests of the Keboola Connection components.

        The `DataDirTester` looks for the `component.py` script and executes it against the specified source folders,
        the `component.py` should expect the data folder path in the environment variable `KBC_DATADIR`.

        Each test is specified by a folder containing following folder structure:

        - `source` - contains data folder that would be on the input of the component
        - `expected` - contains data folder that is result of the execution against the `source` folder.
        Include only folder that contain some files, e.g. `expected/files/out/file.json`
    &#34;&#34;&#34;

    def __init__(self, data_dir: str = Path(&#39;./tests/functional&#39;).absolute().as_posix(),
                 component_script: str = Path(&#39;./src/component.py&#39;).absolute().as_posix(),
                 test_data_dir_class: Type[TestDataDir] = TestDataDir,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;

        Args:
            data_dir (str): file_path to directory that holds functional test directories. By default this is
            ./functional
            component_script (str): file_path to the component script. By default this is ../src/component.py
            context_parameters (dict): dictionary with optional parameters that will be passed to each Test instance.
            Usefull when overriding the TestDataDirClass to add custom functionality
            test_data_dir_class (Type[TestDataDir]): Class extending datadirtest.TestDataDir class with additional
            functionality. It will be used for each test in the suit.


        &#34;&#34;&#34;
        self._data_dir = data_dir
        self._component_script = component_script
        self._context_parameters = context_parameters or {}
        self.__test_class = test_data_dir_class

    def run(self):
        &#34;&#34;&#34;
            Runs functional tests specified in the provided folder based on the source/expected datadirs.
        &#34;&#34;&#34;
        testing_dirs = self._get_testing_dirs(self._data_dir)
        dir_test_suite = self._build_dir_test_suite(testing_dirs)
        test_runner = unittest.TextTestRunner(verbosity=3)
        result = test_runner.run(dir_test_suite)
        if not result.wasSuccessful():
            raise AssertionError(f&#39;Functional test suite failed. {result.errors}&#39;)

    @staticmethod
    def _get_testing_dirs(data_dir: str) -&gt; List:
        &#34;&#34;&#34;
        Gets directories within a directory that do not start with an underscore

        Args:
            data_dir: directory which holds directories

        Returns:
            list of paths inside directory
        &#34;&#34;&#34;
        return [os.path.join(data_dir, o) for o in os.listdir(data_dir) if
                os.path.isdir(os.path.join(data_dir, o)) and not o.startswith(&#39;_&#39;)]

    def _build_dir_test_suite(self, testing_dirs):
        &#34;&#34;&#34;
        Creates a test suite for a directory, each test is added using addTest to pass through parameters

        Args:
            testing_dirs: directories that holds data for the test

        Returns:
            Unittest Suite containing all functional tests

        &#34;&#34;&#34;
        suite = unittest.TestSuite()
        for testing_dir in testing_dirs:
            suite.addTest(self.__test_class(method_name=&#39;compare_source_and_expected&#39;,
                                            data_dir=testing_dir,
                                            component_script=self._component_script,
                                            context_parameters=self._context_parameters))
        return suite


if __name__ == &#34;__main__&#34;:
    data_dir_path = sys.argv[1]
    data_dir_tester = DataDirTester(data_dir_path)

    if len(sys.argv) == 3:
        script_path = sys.argv[2]
        data_dir_tester = DataDirTester(data_dir_path, component_script=script_path)

    data_dir_tester.run()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="datadirtest.datadirtest.DataDirTester"><code class="flex name class">
<span>class <span class="ident">DataDirTester</span></span>
<span>(</span><span>data_dir: str = 'C:/Users/esner/Documents/Prace/KBC/datadirtest/tests/functional', component_script: str = 'C:/Users/esner/Documents/Prace/KBC/datadirtest/src/component.py', test_data_dir_class: Type[<a title="datadirtest.datadirtest.TestDataDir" href="#datadirtest.datadirtest.TestDataDir">TestDataDir</a>] = datadirtest.datadirtest.TestDataDir, context_parameters: Union[dict, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object that executes functional tests of the Keboola Connection components.</p>
<p>The <code><a title="datadirtest.datadirtest.DataDirTester" href="#datadirtest.datadirtest.DataDirTester">DataDirTester</a></code> looks for the <code>component.py</code> script and executes it against the specified source folders,
the <code>component.py</code> should expect the data folder path in the environment variable <code>KBC_DATADIR</code>.</p>
<p>Each test is specified by a folder containing following folder structure:</p>
<ul>
<li><code>source</code> - contains data folder that would be on the input of the component</li>
<li><code>expected</code> - contains data folder that is result of the execution against the <code>source</code> folder.
Include only folder that contain some files, e.g. <code>expected/files/out/file.json</code></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to directory that holds functional test directories. By default this is</dd>
<dt>./functional</dt>
<dt><strong><code>component_script</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to the component script. By default this is ../src/component.py</dd>
<dt><strong><code>context_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with optional parameters that will be passed to each Test instance.</dd>
<dt>Usefull when overriding the TestDataDirClass to add custom functionality</dt>
<dt><strong><code>test_data_dir_class</code></strong> :&ensp;<code>Type[<a title="datadirtest.datadirtest.TestDataDir" href="#datadirtest.datadirtest.TestDataDir">TestDataDir</a>]</code></dt>
<dd>Class extending datadirtest.TestDataDir class with additional</dd>
</dl>
<p>functionality. It will be used for each test in the suit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataDirTester:
    &#34;&#34;&#34;
        Object that executes functional tests of the Keboola Connection components.

        The `DataDirTester` looks for the `component.py` script and executes it against the specified source folders,
        the `component.py` should expect the data folder path in the environment variable `KBC_DATADIR`.

        Each test is specified by a folder containing following folder structure:

        - `source` - contains data folder that would be on the input of the component
        - `expected` - contains data folder that is result of the execution against the `source` folder.
        Include only folder that contain some files, e.g. `expected/files/out/file.json`
    &#34;&#34;&#34;

    def __init__(self, data_dir: str = Path(&#39;./tests/functional&#39;).absolute().as_posix(),
                 component_script: str = Path(&#39;./src/component.py&#39;).absolute().as_posix(),
                 test_data_dir_class: Type[TestDataDir] = TestDataDir,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;

        Args:
            data_dir (str): file_path to directory that holds functional test directories. By default this is
            ./functional
            component_script (str): file_path to the component script. By default this is ../src/component.py
            context_parameters (dict): dictionary with optional parameters that will be passed to each Test instance.
            Usefull when overriding the TestDataDirClass to add custom functionality
            test_data_dir_class (Type[TestDataDir]): Class extending datadirtest.TestDataDir class with additional
            functionality. It will be used for each test in the suit.


        &#34;&#34;&#34;
        self._data_dir = data_dir
        self._component_script = component_script
        self._context_parameters = context_parameters or {}
        self.__test_class = test_data_dir_class

    def run(self):
        &#34;&#34;&#34;
            Runs functional tests specified in the provided folder based on the source/expected datadirs.
        &#34;&#34;&#34;
        testing_dirs = self._get_testing_dirs(self._data_dir)
        dir_test_suite = self._build_dir_test_suite(testing_dirs)
        test_runner = unittest.TextTestRunner(verbosity=3)
        result = test_runner.run(dir_test_suite)
        if not result.wasSuccessful():
            raise AssertionError(f&#39;Functional test suite failed. {result.errors}&#39;)

    @staticmethod
    def _get_testing_dirs(data_dir: str) -&gt; List:
        &#34;&#34;&#34;
        Gets directories within a directory that do not start with an underscore

        Args:
            data_dir: directory which holds directories

        Returns:
            list of paths inside directory
        &#34;&#34;&#34;
        return [os.path.join(data_dir, o) for o in os.listdir(data_dir) if
                os.path.isdir(os.path.join(data_dir, o)) and not o.startswith(&#39;_&#39;)]

    def _build_dir_test_suite(self, testing_dirs):
        &#34;&#34;&#34;
        Creates a test suite for a directory, each test is added using addTest to pass through parameters

        Args:
            testing_dirs: directories that holds data for the test

        Returns:
            Unittest Suite containing all functional tests

        &#34;&#34;&#34;
        suite = unittest.TestSuite()
        for testing_dir in testing_dirs:
            suite.addTest(self.__test_class(method_name=&#39;compare_source_and_expected&#39;,
                                            data_dir=testing_dir,
                                            component_script=self._component_script,
                                            context_parameters=self._context_parameters))
        return suite</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="datadirtest.datadirtest.DataDirTester.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs functional tests specified in the provided folder based on the source/expected datadirs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
        Runs functional tests specified in the provided folder based on the source/expected datadirs.
    &#34;&#34;&#34;
    testing_dirs = self._get_testing_dirs(self._data_dir)
    dir_test_suite = self._build_dir_test_suite(testing_dirs)
    test_runner = unittest.TextTestRunner(verbosity=3)
    result = test_runner.run(dir_test_suite)
    if not result.wasSuccessful():
        raise AssertionError(f&#39;Functional test suite failed. {result.errors}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir"><code class="flex name class">
<span>class <span class="ident">TestDataDir</span></span>
<span>(</span><span>data_dir: str, component_script: str, method_name: str = 'compare_source_and_expected', context_parameters: Union[dict, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A test class that runs a component script to get a real output of a component and compares the output to the
specified expected output of that component and its configuration</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the testing method to be run</dd>
<dt><strong><code>data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to directory which holds the component config, source, and expected directories</dd>
<dt><strong><code>component_script</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to component script that should be run</dd>
<dt><strong><code>context_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Optional context parameters injected from the DirTester runner.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestDataDir(unittest.TestCase):
    &#34;&#34;&#34;
    A test class that runs a component script to get a real output of a component and compares the output to the
    specified expected output of that component and its configuration
    &#34;&#34;&#34;

    def __init__(self, data_dir: str, component_script: str, method_name: str = &#39;compare_source_and_expected&#39;,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;
        Args:
            method_name (str): name of the testing method to be run
            data_dir (str): file_path to directory which holds the component config, source, and expected directories
            component_script (str): file_path to component script that should be run
            context_parameters (dict): Optional context parameters injected from the DirTester runner.
        &#34;&#34;&#34;
        super(TestDataDir, self).__init__(methodName=method_name)
        self.component_script = component_script
        self.orig_dir = data_dir
        self.expected_path = path.join(data_dir, &#39;expected&#39;)
        self.context_parameters = context_parameters

    def setUp(self):
        self.data_dir = self._create_temporary_copy()
        self._run_set_up_script()

    def _run_set_up_script(self):
        start_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;set_up.py&#39;)
        if os.path.exists(start_script_path):
            script = self._load_module_at_path(start_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The set_up.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def tearDown(self) -&gt; None:
        self._run_tear_down_script()
        shutil.rmtree(self.data_dir)

    @staticmethod
    def _load_module_at_path(run_script_path):
        spec = importlib.util.spec_from_file_location(&#34;custom_scripts&#34;, run_script_path)
        script = importlib.util.module_from_spec(spec)
        assert isinstance(spec.loader, Loader)
        spec.loader.exec_module(script)
        return script

    def _run_tear_down_script(self):
        end_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;tear_down.py&#39;)
        if os.path.exists(end_script_path):
            script = self._load_module_at_path(end_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The tear_down.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def id(self):
        return path.basename(self.orig_dir)

    def shortDescription(self) -&gt; Optional[str]:
        return path.basename(self.orig_dir)

    def _create_temporary_copy(self):
        temp_dir = tempfile.gettempdir()
        dst_path = path.join(temp_dir, &#39;test_data&#39;)
        if path.exists(dst_path):
            shutil.rmtree(dst_path)

        shutil.copytree(self.orig_dir, dst_path)
        return dst_path

    def run_component(self):
        &#34;&#34;&#34;
        Runs a component script with a specified configuration
        &#34;&#34;&#34;
        source_dir = path.join(self.data_dir, &#34;source&#34;, &#34;data&#34;)
        os.environ[&#34;KBC_DATADIR&#34;] = source_dir
        run_path(self.component_script, run_name=&#39;__main__&#39;)

    def compare_source_and_expected(self):
        &#34;&#34;&#34;
        Executes and compares source and expected directories based on the nested directory structure and files
        within them

        &#34;&#34;&#34;
        logging.info(f&#34;Running {self.component_script} with configuration from {self.data_dir}&#34;)
        self.run_component()

        files_expected_path, tables_expected_path = self.get_data_paths(self.data_dir, &#39;expected&#39;)
        files_real_path, tables_real_path = self.get_data_paths(self.data_dir, &#39;source&#39;)

        if path.exists(files_expected_path) or path.exists(files_real_path):
            self.assert_directory_structure_match(files_expected_path, files_real_path)
            self.assert_directory_files_contents_match(files_expected_path, files_real_path)
        if path.exists(tables_expected_path) or path.exists(tables_real_path):
            self.assert_directory_structure_match(tables_expected_path, tables_real_path)
            self.assert_directory_files_contents_match(tables_expected_path, tables_real_path)
        logging.info(&#34;Tests passed successfully &#34;)

    @staticmethod
    def get_data_paths(data_dir: str, dir_type: str):
        &#34;&#34;&#34;
        Uses the Keboola data structure to return paths to files and tables

        Args:
            data_dir: file_path of directory to get file and table paths from
            dir_type: type of directory source or expected

        Returns:
            paths to files and tables
        &#34;&#34;&#34;
        files_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;files&#39;)
        tables_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;tables&#39;)
        return files_expected_path, tables_expected_path

    @staticmethod
    def get_all_files_in_dir(dir_path: str):
        &#34;&#34;&#34;
        Gets all non-hidden files from a directory and its subdirectory

        Args:
            dir_path: file_path of directory to fetch files from

        Returns:
            list of files in the directory
        &#34;&#34;&#34;
        files = []
        for sub_dir, dir_names, file_names in os.walk(dir_path):
            for filename in [f for f in file_names if not f.startswith(&#34;.&#34;)]:
                files.append(os.path.join(sub_dir, filename))
        return files

    def assert_directory_structure_match(self, expected_path: str, real_path: str):
        &#34;&#34;&#34;
        Tests whether directory structures of two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            expected_path: Path holding the directory of expected files
            real_path: Path holding the directory of real/source files
        &#34;&#34;&#34;
        compared_dir = filecmp.dircmp(expected_path, real_path)

        left = [file for file in compared_dir.left_only if not file.startswith(&#39;.&#39;)]
        right = [file for file in compared_dir.right_only if not file.startswith(&#39;.&#39;)]

        self.assertEqual(left, [], f&#34; Files : {left} exists only in expected output and not in actual output&#34;)
        self.assertEqual(right, [], f&#34; Files : {right} exists only in actual output and not in expected output&#34;)

    def assert_directory_files_contents_match(self, files_expected_path: str, files_real_path: str):
        &#34;&#34;&#34;
        Tests whether files in two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            files_expected_path:  Path holding expected files
            files_real_path: Path holding real/source files
        &#34;&#34;&#34;
        file_paths = self.get_all_files_in_dir(files_expected_path)
        common_files = [file.replace(files_expected_path, &#34;&#34;).strip(&#34;/&#34;).strip(&#39;\\&#39;) for file in file_paths]
        equal, mismatch, errors = filecmp.cmpfiles(files_expected_path, files_real_path, common_files, shallow=False)
        self.assertEqual(mismatch, [], f&#34; Files : {mismatch} do not match&#34;)
        self.assertEqual(errors, [], f&#34; Files : {errors} could not be compared&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="datadirtest.datadirtest.TestDataDir.get_all_files_in_dir"><code class="name flex">
<span>def <span class="ident">get_all_files_in_dir</span></span>(<span>dir_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all non-hidden files from a directory and its subdirectory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir_path</code></strong></dt>
<dd>file_path of directory to fetch files from</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of files in the directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_all_files_in_dir(dir_path: str):
    &#34;&#34;&#34;
    Gets all non-hidden files from a directory and its subdirectory

    Args:
        dir_path: file_path of directory to fetch files from

    Returns:
        list of files in the directory
    &#34;&#34;&#34;
    files = []
    for sub_dir, dir_names, file_names in os.walk(dir_path):
        for filename in [f for f in file_names if not f.startswith(&#34;.&#34;)]:
            files.append(os.path.join(sub_dir, filename))
    return files</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.get_data_paths"><code class="name flex">
<span>def <span class="ident">get_data_paths</span></span>(<span>data_dir: str, dir_type: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the Keboola data structure to return paths to files and tables</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_dir</code></strong></dt>
<dd>file_path of directory to get file and table paths from</dd>
<dt><strong><code>dir_type</code></strong></dt>
<dd>type of directory source or expected</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>paths to files and tables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_data_paths(data_dir: str, dir_type: str):
    &#34;&#34;&#34;
    Uses the Keboola data structure to return paths to files and tables

    Args:
        data_dir: file_path of directory to get file and table paths from
        dir_type: type of directory source or expected

    Returns:
        paths to files and tables
    &#34;&#34;&#34;
    files_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;files&#39;)
    tables_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;tables&#39;)
    return files_expected_path, tables_expected_path</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="datadirtest.datadirtest.TestDataDir.assert_directory_files_contents_match"><code class="name flex">
<span>def <span class="ident">assert_directory_files_contents_match</span></span>(<span>self, files_expected_path: str, files_real_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether files in two directories are the same.
If not the error message prints out which files differ in each directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>files_expected_path</code></strong></dt>
<dd>Path holding expected files</dd>
<dt><strong><code>files_real_path</code></strong></dt>
<dd>Path holding real/source files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_directory_files_contents_match(self, files_expected_path: str, files_real_path: str):
    &#34;&#34;&#34;
    Tests whether files in two directories are the same.
    If not the error message prints out which files differ in each directory

    Args:
        files_expected_path:  Path holding expected files
        files_real_path: Path holding real/source files
    &#34;&#34;&#34;
    file_paths = self.get_all_files_in_dir(files_expected_path)
    common_files = [file.replace(files_expected_path, &#34;&#34;).strip(&#34;/&#34;).strip(&#39;\\&#39;) for file in file_paths]
    equal, mismatch, errors = filecmp.cmpfiles(files_expected_path, files_real_path, common_files, shallow=False)
    self.assertEqual(mismatch, [], f&#34; Files : {mismatch} do not match&#34;)
    self.assertEqual(errors, [], f&#34; Files : {errors} could not be compared&#34;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.assert_directory_structure_match"><code class="name flex">
<span>def <span class="ident">assert_directory_structure_match</span></span>(<span>self, expected_path: str, real_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether directory structures of two directories are the same.
If not the error message prints out which files differ in each directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expected_path</code></strong></dt>
<dd>Path holding the directory of expected files</dd>
<dt><strong><code>real_path</code></strong></dt>
<dd>Path holding the directory of real/source files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_directory_structure_match(self, expected_path: str, real_path: str):
    &#34;&#34;&#34;
    Tests whether directory structures of two directories are the same.
    If not the error message prints out which files differ in each directory

    Args:
        expected_path: Path holding the directory of expected files
        real_path: Path holding the directory of real/source files
    &#34;&#34;&#34;
    compared_dir = filecmp.dircmp(expected_path, real_path)

    left = [file for file in compared_dir.left_only if not file.startswith(&#39;.&#39;)]
    right = [file for file in compared_dir.right_only if not file.startswith(&#39;.&#39;)]

    self.assertEqual(left, [], f&#34; Files : {left} exists only in expected output and not in actual output&#34;)
    self.assertEqual(right, [], f&#34; Files : {right} exists only in actual output and not in expected output&#34;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.compare_source_and_expected"><code class="name flex">
<span>def <span class="ident">compare_source_and_expected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes and compares source and expected directories based on the nested directory structure and files
within them</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_source_and_expected(self):
    &#34;&#34;&#34;
    Executes and compares source and expected directories based on the nested directory structure and files
    within them

    &#34;&#34;&#34;
    logging.info(f&#34;Running {self.component_script} with configuration from {self.data_dir}&#34;)
    self.run_component()

    files_expected_path, tables_expected_path = self.get_data_paths(self.data_dir, &#39;expected&#39;)
    files_real_path, tables_real_path = self.get_data_paths(self.data_dir, &#39;source&#39;)

    if path.exists(files_expected_path) or path.exists(files_real_path):
        self.assert_directory_structure_match(files_expected_path, files_real_path)
        self.assert_directory_files_contents_match(files_expected_path, files_real_path)
    if path.exists(tables_expected_path) or path.exists(tables_real_path):
        self.assert_directory_structure_match(tables_expected_path, tables_real_path)
        self.assert_directory_files_contents_match(tables_expected_path, tables_real_path)
    logging.info(&#34;Tests passed successfully &#34;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id(self):
    return path.basename(self.orig_dir)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.run_component"><code class="name flex">
<span>def <span class="ident">run_component</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a component script with a specified configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_component(self):
    &#34;&#34;&#34;
    Runs a component script with a specified configuration
    &#34;&#34;&#34;
    source_dir = path.join(self.data_dir, &#34;source&#34;, &#34;data&#34;)
    os.environ[&#34;KBC_DATADIR&#34;] = source_dir
    run_path(self.component_script, run_name=&#39;__main__&#39;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
    self.data_dir = self._create_temporary_copy()
    self._run_set_up_script()</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.shortDescription"><code class="name flex">
<span>def <span class="ident">shortDescription</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a one-line description of the test, or None if no
description has been provided.</p>
<p>The default implementation of this method returns the first line of
the specified test method's docstring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortDescription(self) -&gt; Optional[str]:
    return path.basename(self.orig_dir)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self) -&gt; None:
    self._run_tear_down_script()
    shutil.rmtree(self.data_dir)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="datadirtest" href="index.html">datadirtest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="datadirtest.datadirtest.DataDirTester" href="#datadirtest.datadirtest.DataDirTester">DataDirTester</a></code></h4>
<ul class="">
<li><code><a title="datadirtest.datadirtest.DataDirTester.run" href="#datadirtest.datadirtest.DataDirTester.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="datadirtest.datadirtest.TestDataDir" href="#datadirtest.datadirtest.TestDataDir">TestDataDir</a></code></h4>
<ul class="">
<li><code><a title="datadirtest.datadirtest.TestDataDir.assert_directory_files_contents_match" href="#datadirtest.datadirtest.TestDataDir.assert_directory_files_contents_match">assert_directory_files_contents_match</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.assert_directory_structure_match" href="#datadirtest.datadirtest.TestDataDir.assert_directory_structure_match">assert_directory_structure_match</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.compare_source_and_expected" href="#datadirtest.datadirtest.TestDataDir.compare_source_and_expected">compare_source_and_expected</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.get_all_files_in_dir" href="#datadirtest.datadirtest.TestDataDir.get_all_files_in_dir">get_all_files_in_dir</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.get_data_paths" href="#datadirtest.datadirtest.TestDataDir.get_data_paths">get_data_paths</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.id" href="#datadirtest.datadirtest.TestDataDir.id">id</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.run_component" href="#datadirtest.datadirtest.TestDataDir.run_component">run_component</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.setUp" href="#datadirtest.datadirtest.TestDataDir.setUp">setUp</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.shortDescription" href="#datadirtest.datadirtest.TestDataDir.shortDescription">shortDescription</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.tearDown" href="#datadirtest.datadirtest.TestDataDir.tearDown">tearDown</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: /docs/html/datadirtest/index.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>datadirtest API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>datadirtest</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .datadirtest import DataDirTester, TestDataDir

__all__ = [&#39;datadirtest&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="datadirtest.datadirtest" href="datadirtest.html">datadirtest.datadirtest</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="datadirtest.datadirtest" href="datadirtest.html">datadirtest.datadirtest</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: /README.md
================================================
# Data Dir Test #

This library enables functional testing for Keboola components and processors by comparing expected and 
real output directories.

[**API Docs**](https://htmlpreview.github.io/?https://bitbucket.org/kds_consulting_team/datadirtest/raw/master/docs/html/datadirtest/datadirtest.html)

### Introduction ###
By defining a direc

## Quickstart ##

### Installation ###

Add to requirements 
```
https://bitbucket.org/kds_consulting_team/datadirtest/get/VERSION_NUMBER.zip#egg=datadirtest
```

Or install via PIP
```
pip install https://bitbucket.org/kds_consulting_team/datadirtest/get/VERSION_NUMBER.zip#egg=datadirtest
```

### Use of the library ###

In the tests folder create a directory structure mimicking the directory structure in production:

```
/path/to/project/tests
└─functional
    └─test-name
      ├─expected-code
      ├─expected
      │ └─data
      │   └─out
      │     ├─files
      │     └─tables
      ├─source
      │ └─data
      │   ├─ config.json
      │   ├─ set_up.py
      │   ├─ tear_down.py
      │   └─in
      │     ├─files
      │     ├─tables            
```

- `source` - contains data folder that would be on the input of the component
    - it may contain `set_up.py` and `tear_down.py` scripts that are executed before and after each test respectively.
- `expected` - contains data folder that is result of the execution against the `source` folder. 
Include only folder that contain some files, e.g. `expected/files/out/file.json` 

The `DataDirTester` looks for the `component.py` script and executes it against the specified source folders, 
the `component.py` should expect the data folder path in the environment variable `KBC_DATADIR`.

By default it looks for the script at this path:
```
/path/to/project
└─src
    └─component.py
```

Then create file `test_functional.py` in the `/path/to/project/tests` folder and input the following:

```
import unittest

from datadirtest import DataDirTester


class TestComponent(unittest.TestCase):

    def test_functional(self):
        functional_tests = DataDirTester()
        functional_tests.run()


if __name__ == "__main__":
    unittest.main()
```

### Parameters for Debugging
The `DataDirTester` class accepts the following parameters:
- `save_output` (default: `False`): If `True`, the resulting data folders are saved in the `output` folder.
- `selected_tests` (list of `str`): If set, only the tests with the specified names are executed.

Both parameters can also be passed via environment variables: `DIRTEST_SAVE_OUTPUT` and `DIRTEST_SELECTED_TESTS` (comma-separated names).
Then run your tests as usual e.g. via `python -m unittest discover` from the root folder.



**Alternatively** run as:

```
python -m datadirtest /path/to/project/tests/functional [optionally path/to/project/script.py]
```

### Environment Variables

It is possible to use environment variables placeholders inside the test `config.json`. 
To do so use following syntax: `{{env.VARIABLE_NAME}}`. The environment variable `VARIABLE_NAME` will be expected and it's value will replace the placeholder. 
If the EVN variable is not present, the test will fail.

**Example**
```json
{
  "parameters": {
    "#api_key": "{{env.API_KEY}}",
    "since": "1 day ago"
  }
}
```

In the following example the `#api_key` value will be replaced by `API_KEY` ENV variable value.


## Advanced usage

In some cases you want to modify the DataDirTest behaviour for instance to prepare the environment for each test, 
or execute some script prior the actual test run.

To achieve this you may extend the `datadirtest.TestDataDir` class. This class is a Test container for each of the 
test data folders and are being triggered as a part of a test suite via `DataDirTester.run()` method.

The `DataDirTester` class takes two additional arguments that allow to specify both the class extending the `DataDirTester` 
with additional functionality and also a context (parameters) that are passed to each `DataDirTester` class instance.

- `test_data_dir_class: Type[TestDataDir]` - a class with additional functionality to execute datadir tests. E.g. `MyCustomDataTest(TestDataDir)`
- `context_parameters` - a dictionary with arbitrary context parameters that are then available in each `TestDataDir` instance 
via `TestDataDir.context_parameters` 

** Example:**

The below code instantiates a pseudo SqlClient and runs the same sequence of queries before each DataDirtest execution.



```python
import unittest

from datadirtest import DataDirTester, TestDataDir

class CustomDatadirTest(TestDataDir):
    def setUp(self):
        sql_client = self.context_parameters['sql_client']
        sql_client.run_query('DROP TABLE IF EXISTS T;')
        sql_client.run_query('CREATE TABLE T AS SELECT 1 AS COLUMN;')


class TestComponent(unittest.TestCase):

    def test_functional(self):
        sql_client = SqlClient("username", "password", "localhost")
        
        functional_tests = DataDirTester(test_data_dir_class=CustomDatadirTest,
                                         context_parameters={'sql_client': sql_client})
        functional_tests.run()


if __name__ == "__main__":
    unittest.main()
```

### Using set_up, post_run and tear_down scripts

You may specify custom scripts that are executed before or after the test execution. Place them into the `source` folder:

```
      ├─source
      │ └─data
      │   ├─ config.json
      │   ├─ set_up.py
      │   ├─ post_run.py
      │   ├─ tear_down.py
      │   └─in
      │     ├─files
      │     ├─tables            
```

**Usage**

Each script (`set_up.py`, `post_run.py` and `tear_down.py`) **must implement** a `run(context: TestDataDir)` method. The `context` parameter then includes the parent
TestDataDir instance with access to `context_parameters` if needed. Both script files are optional. If file is found but there is no `run()` method defined,
the execution fails.

The `set_up.py` and `tear_down.py` are executed before and after the DataDirTest itself. The `post_run.py` is useful to run a script right after the component script, before the resulting data is modified. See the diagram below:

![datadir diagram](docs/datadir_test.png)

For instance, the `set_up.py` may contain following code:

```python
from datadirtest import TestDataDir


def run(context: TestDataDir):
    # get value from the context parameters injected via DataDirTester constructor
    sql_client = context.context_parameters['sql_client']
    sql_client.run_query('DROP TABLE IF EXISTS T;')
    sql_client.run_query('CREATE TABLE T AS SELECT 1 AS COLUMN;')
    print("Running before script")
```

It will run the above script specific for the current test (folder) before the actual test execution



### Chained tests

Chained tests are useful in scenarios when it is necessary to run several tests in a sequence and pass the component state between them.


You can chain tests by including them in additional folder that contains normal tests. 
The folder can also contain the `set_up` and `tear_down` scripts that will be executed before and after the group of chained tests. 
They also share all the other parameters like context.

e.g.: 

```
/path/to/project/tests
└─functional
    ├─my-chained-test
    │ ├─ set_up.py
    │ ├─ tear_down.py
    │ ├─01-first-test
    │ │  ├─expected
    │ │  │ └─data
    │ │  ├─source
    │ │  │ └─data  
    │ └─02-second-test
    │    ├─expected
    │    └─source 
    └─another-normal-test
```

#### The chain test execution

The tests are executed in **alphabetical order** so it's recommended to prefix your tests with numbers, e.g. `01_`,`02_`, ..

The execution flow of the example `my-chained-test` looks like this:

1. run root `set_up.py`
2. run `01-first-test`
3. pass `01-first-test` result `out/state.json` to `02-second-test/source/data/in/state.json`
   - If `02-second-test/source/data/in/state.json` alredy exists it is overridden!
4. run `02-second-test`
5. run `tear_down_py`

Note that the tests in the `functional` folder are executed in random order.

