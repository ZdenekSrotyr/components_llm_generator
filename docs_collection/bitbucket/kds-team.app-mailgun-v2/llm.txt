Directory structure:
└── kds_consulting_team-kds-team.app-mailgun-v2/
    ├── README.md
    ├── bitbucket-pipelines.yml
    ├── change_log.md
    ├── deploy.sh
    ├── docker-compose.yml
    ├── Dockerfile
    ├── flake8.cfg
    ├── LICENSE.md
    ├── requirements.txt
    ├── component_config/
    │   ├── component_long_description.md
    │   ├── component_short_description.md
    │   ├── configSchema.json
    │   ├── configuration_description.md
    │   ├── stack_parameters.json
    │   └── sample-config/
    │       ├── config.json
    │       └── in/
    │           ├── files/
    │           │   ├── 445515655_questionnaire.html
    │           │   ├── 445515655_questionnaire.html.manifest
    │           │   ├── 452610617_questionnaire.html
    │           │   └── 452610617_questionnaire.html.manifest
    │           └── tables/
    │               ├── _tableattachment_list_questionnaire.csv
    │               ├── _tableattachment_list_questionnaire.csv.manifest
    │               ├── mailing_list_questionnaire.csv
    │               └── mailing_list_questionnaire.csv.manifest
    ├── scripts/
    │   ├── build_n_test.sh
    │   └── update_dev_portal_properties.sh
    ├── src/
    │   ├── component.py
    │   └── mailgun/
    │       ├── client.py
    │       └── result.py
    └── tests/
        ├── __init__.py
        └── test_component.py

================================================
FILE: README.md
================================================
# Mailgun

Mailgun is an email automation service. It offers a complete cloud-based email service for sending, receiving and tracking email sent through your websites and applications. This component allows to connect Mailgun with Keboola platform, for sending automation.

To successfully operate the component, following parameters are required:

- a private API key for Mailgun,
- a Mailgun domain.

If you're unsure on where to find the API key, follow the steps mentioned in the [documentation](https://help.mailgun.com/hc/en-us/articles/203380100-Where-Can-I-Find-My-API-Key-and-SMTP-Credentials-) on how to obtain the API key. When it comes to Mailgun domains, upon registering each user is provisioned a sandbox domain. The sandbox domain can only send email to [**authorized recipients**](https://help.mailgun.com/hc/en-us/articles/217531258-Authorized-Recipients). The limit is 5 authorized recipients per sandbox domain. It is therefore highly recommended to [register your own domain with Mailgun](https://help.mailgun.com/hc/en-us/articles/202256730-How-do-I-pick-a-domain-name-for-my-Mailgun-account-) to not be limited by sandbox restrictions.

##### Pricing

Note that Mailgun is a paid service and is subject to [Mailgun's Terms Of Service](https://www.mailgun.com/terms/). By default, each domain can send up to 10 000 emails per month for free. For more information about pricing, please visit [Mailgun's pricing explorer](https://www.mailgun.com/pricing).

**Table of contents**

[TOC]

## Changes from previous version

With a new version of Mailgun component, there were some changes, which make this version non-backwards compatible and hence some effort is required to migrate. Major changes include:

1. A region can be specified in the configuration (see [Parameters](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-parameters))
2. Changed column names for input table and support of more Mailgun features (see [Mailing list](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-mailing-list))
3. Sending tabular attachments straight from Keboola storage (see [Table input mapping](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-table-input-mapping))
4. Improved specification of attachments and templates and automatic selection of latest available file (see [Path specification to template or file attachment](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-path-specification-to-template-or-file-attachment))
5. Subject, plain-text or html template are now customized using `{{COLUMN_NAME}}` tags, instead of `%(COLUMN_NAME)s` as before (see [Email customization](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-email-customization))

## Configuration

The configuration of the component is done via a set of parameters, an input table and optional files. This, and all of the functionalities of the component, will be covered in this section. The documentation will extensively use the provided [sample configuration](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/component_config/sample-config/) to showcase the behavior of the application and how to cover special cases.

### Parameters

The component takes a total of 5 parameters. Four of the parameters can be configured in the UI of Keboola, one is only configurable via API as its configuration is rather excess.

The four required parameters are:

- API Key 
    - **type:** required
    - **configuration name:** `#apiToken`
    - **description:** An API key used to authenticate all requests against Mailgun API. If invalid value is provided, the application fails. More information on how to obtain the API key can be found in the [documentation](https://help.mailgun.com/hc/en-us/articles/203380100-Where-Can-I-Find-My-API-Key-and-SMTP-Credentials-).
- Domain
    - **type:** required
    - **configuration name:** `domainName`
    - **description:** The name of the domain, which will be used for delivering emails. You can find a list of all your domain in the *Control Panel* under the *Domains* tab. For sandbox domains, the domain is in form `sandbox[uniqueId].mailgun.org`, e.g. `sandbox15d3020e03ca4f8db4895fca549a8b3a.mailgun.org`. If the provided domain is not associated with the API key, or the domain is not found, the application will fail.
- Region
    - **type:** required
    - **configuration name**: `domainRegion`
    - **default:** US
    - **description**: The region where the Mailgun account or domain is located. Available values are US (sending via [https://api.mailgun.net/](https://api.mailgun.net/)) or EU (sending via [https://api.eu.mailgun.net/](https://api.eu.mailgun.net/)). If incorrect region is specified, the application will fail due to domain not existing in the region.
- Sender Name
    - **type:** required
    - **configuration name:** `fromName`
    - **description:** The name which will be displayed as a sender of the messages from Mailgun. Can be left blank, in which case only the sender's email will be used as sender's identification.

An optional parameter, configurable only via API is:

- Sender Email
    - **type:** optional
    - **configuration name:** `fromEmail`
    - **description:** The local part of the email address used to send messages.
    - **default:** `postmaster`

### Mailing list

Mailing list is the input table of emails, with other specified parameters, to which the messages will be sent. Mailing list can be configured in the table input mapping section, or must be stored in `/data/in/tables/` folder, and must not contain `_tableattachment_` in the destination name, as that is reserved for tabular attachments. 

A combination of 3 columns is required and other columns could be used to specify the parameters of each message as well as customize the template.

The three mandatory columns are:

- `email`
    - **description:** A single email address or a comma-separated list of email addresses, to which a message will be sent. The column is mandatory, thus if the column is not provided, the application will fail.
    - **example:** `testy.mctesface@domain.com`; `sterling.archer@fx.com, mallory.archer@fx.com`
- `subject`
    - **description:** A mandatory column defining the subject of the message.
    - **example:** `Testing email`; `New job announcement`
- `html_file` or `text`
    - **description:** Column `html_file` defines the file name of the html template, which shall be used as the message body (see section **Customization and attachments**). Column `text` defines the plain text body of the message. Either of the columns or both can be provided. If both columns have a valid value, by default Mailgun API prioritizes the html content over plain text content. Both of the columns can be customized with additional parameters (more on that in section **Customization and attachments**).
    - **example:**
        - `template.html`; `questionnaire.html`
        - `A very warm welcome!`; `This is a sample message.`

In addition to three (four) mandatory columns, a set of optional columns can be provided to alter the behavior of the message. All of these columns have a blank default value. These columns are:

- `delivery_time`
    - **description:** A timestamp in **RFC 2822** format, i.e. format `Fri, 25 Oct 2019 19:00:00 +0200`. If undefined or left blank, the message will be delivered instantly. The email delivery can't be scheduled more than three days in advance by design of the API.
    - **Mailgun mapping:** `o:deliverytime`
    - **example:** `Fri, 25 Oct 2019 19:00:00 +0200`; `Fri, 25 Oct 2019 17:00:00 GMT`
    - **hints:**
        - in Snowflake, the RFC 2282 format can be achieved using format `DY, DD MON YYYY HH24:MI:SS TZHTZM`
        - in Python, the RFC 2282 format can be achieved using format `%a, %d %b %Y %H:%M:%S %z`
- `cc`
    - **description:** A single email address or a comma-separated list of email addresses, to which a copy of the email will be delivered.
    - **Mailgun mapping:** `cc`
    - **example:** same as `email`
- `bcc`
    - **description:** A single email address or a comma-separated list of email addresses, to which a blind copy of the email will be delivered.
    - **Mailgun mapping:** `bcc`
    - **example:** same as `email`
- `tags`
    - **description:** A single tag or a comma-separated list of tags, which will be attached to the image. Tags are very useful for tracking specific emails or campaigns. Up to 3 tags can be applied to a single message; if more than 3 are provided, only the first three in the list will be applied, by design of the API.
    - **Mailgun mapping:** `o:tag`
    - **example:** `abc`; `abc, 123, 567`
- `attachments`
    - **description:** A single file name or a comma-separated list of filenames, which will attached to a message. See section **Sending attachments** for more information on how to correctly specify attachments.
    - **Mailgun mapping:** `attachments`
    - **example:** `__tableattachment__data.csv`; `graph.png, 123456789_data.json`
- `custom_fields`
    - **description:** All other custom fields and headers which should be added to a message. Must be a valid JSON object. If the object passed is not a valid object, email sending is not halted. See [documentation](https://documentation.mailgun.com/en/latest/api-sending.html#sending) for all available options.
    - **example:** `{"h:Reply-To": "reply_email@keboola.com"}`

Besides all of the columns mentioned above, it is possible to specify additional columns which will be used to customize either the html template, or the plain text body of the message. In fact, any of the columns can be used for message body customization. More about customization is covered in **Customizing messages**.

### File input mapping

Non-tabular files, such as html files, images, json, etc. can be used as attachments, or in case of html files as templates. In Keboola, all of these files must be properly mapped in *File input mapping* section, specifying the correct tags.

![](docs/file-input-mapping.png)

All of the files are automatically stored in `/data/in/files/` folder.

### Table input mapping

All tabular files from Keboola storage can be specified directly from Keboola's UI in the table input mapping section and must have a prefix `_tableattachment_`, otherwise they will be used as a mailing list; table without `_tableattachment_` prefix is not recognized as an attachment.

![](docs/table-input-mapping.png)

All of the tables are automatically stored in `/data/in/tables/` folder.

## Customization and attachments

The Mailgun component is able to handle some forms of customizations for each email. Along with sending attachments from file and table storage, the component is able to send a customized html template for each email. **All templates must be stored in file storage (see section *File Input Mapping*) and attachments can be stored either in file storage, or if applicable in standard table storage.**

In this section, a customization of templates as well as specifying attachments will be discussed. But firstly, let's start with how the component chooses files based on specification.

### Path specification to template or file attachment

In the previous version of Mailgun, a template or file attachment (further referred to as a file) had to be specified by it's full name only. Mailgun component could not perform any kind of search for patterns in names (glob search). This, of course, poised a problem when sending files from Keboola storage, since each filename is preceeded by its identificator, which is unknown to the user prior to uploading the file. For files, which are static and only uploaded once (e.g. templates), this might not be a problem. However, for files which are generated each day and then sent via Mailgun, this poised a problem. Often, a structure of files, similar to the one below, was created in Keboola file storage and users needed an extra transformation to determine the latest file's name.

```
445515655_report.pdf    321312312_template.html
446461182_report.pdf    760989809_template.html
446461232_report.pdf    944598324_template.html
451982978_report.pdf    131242341_logo.jpeg
478942334_report.pdf    542342123_graph.png
563242313_report.pdf    857923432_graph.png
589321233_report.pdf    878080998_graph.png
591233212_report.pdf    975763234_graph.png
623421321_report.pdf    653423674_report.pdf
```

With a new version of Mailgun, users are offered a much improved experience of file specification. Files (both html templates and files used for attachments) can be specified using a "simple" file name, without the identificator and Mailgun application will automatically choose the latest file based on available metadata.

For example, a following table with template and attachments can be specified.

| html_file               | attachments|
|-------------------------|------------|
| template.html           | report.pdf |
| 321312312_template.html | logo.jpeg  |

In the first row, the component first matches all files using glob, with a pattern of `*template.html`, which would in this case result in 3 files. Afterwards, the latest file is determined by using metadata (manifests) resulting in final file `944598324_template.html`, which will be used as a template. In case of attachments, identicall process is performed.

If you need to match a specific file precisely, you can do so by specifying its full name as is the case in the second row. Template `321312312_template.html` is one of the files present in the "environment" and is therefore used directly.

### Email customization

Each email body can be specified either by a plain text (using column `text`) or by an html template (using column `html_file`). Mailgun component allows further customizations of the body (both plain text and html) and subject using special word tags. These word tags take a form of `{{COLUMN_NAME}}`, where `COLUMN_NAME` is a name of the column, with which value the tag should be replaced. 

As an example, imagine, that a following input table is provided:

| email                | subject                          | text                                                                             | name  | order_id |
|----------------------|----------------------------------|----------------------------------------------------------------------------------|-------|----------|
| testy@mctestface.com | Your order summary #{{order_id}} | Hello {{name}},   Summary of your order: Order ID: {{order_id}} Email: {{email}} | Testy | 12345678 |

The component would read the contents of the plain text specified, and iterate over each column and replace the column tag `{{}}`, with its column value. In this case, an email would be sent with a following form:

```
To: testy@mctestface.com
Subject: Your order summary #12345678

Body:
Hello Testy,

Summary of your order:
Order ID: 12345678
Email: testy@mctestface.com
```

Note, that any of the attributes in the mailing list table can be used to fill subject, plain-text body, or html-template body. In case, a tag specified in the body of the email is not present in the input table, it will not be replaced. As an example, let's have a following html file `greetings.html`:

```html
<p>
    <strong>
        Hello {{name}},<br>
    </strong>
</p>
<p>
    Here's your order {{order_id}} of product {{product}}, it will arrive soon.
</p>
```

and following input table:

| email                | subject                          | html_file      | name  | order_id |
|----------------------|----------------------------------|----------------|-------|----------|
| testy@mctestface.com | Your order summary #{{order_id}} | greetings.html | Testy | 12345678 |

Together, they will generate an email with the following form:

```
To: testy@mctestface.com
Subject: Your order summary #12345678

Body:
Hello Testy,

Here's your order 12345678 of product {{product}}, it will arrive soon.
```

### Sending attachments

Mailgun component allows to send attachments both, from storage and file storage. Note, that total size of email **must no exceed 25MB**, otherwise it will not be accepted by the API and will be returned. Component performs a strict check for size prior to sending and all over-size emails are recorded in results table.

As discussed in previous sections, tabular attachments must have a suffix `_tableattachment_` and must be specified by their full name in the mailing list table. If multiple attachments are specified, their names must be separated by a comma. A combination of both tabular and file attachments is allowed, as long as they do not exceed 25MB.

Examples of attachments specification include:

```
_tableattachment_table1.csv, graph.png, report.pdf
131242341_logo.jpeg, _tableattachment_orders.csv
```

## Output

Mailgun component is configured in such a way, that any error in sending a message does not result in failure of the component. Instead, two tables are outputted; one with successfully sent messages and the second one with errors. Both are loaded into storage incrementally.

The `messages` table contains following columns:

- `id`
    - **description:** A unique identificator of a sent message, generated by Mailgun.
    - **example:** `20200201132125.1.74AAB19741F2684B@sandbox15d3020e03ca4f8db4895fca549a8b3a.mailgun.org`
- `timestamp`
    - **description:** A UNIX timestamp in miliseconds of the event, when message was accepted by Mailgun.
    - **example:** `1580563285000`
- `specification`
    - **description:** A JSON representation of the email, that was sent. Contains mainly information from the input table.
    - **example:** `{"email":"testy@mctestface.com"}`
- `html_file_used`
    - **description:** A path to file, which was used as a template for the email message.
    - **example:** `/data/in/files/544794840_demo_mail.html`
- `attachments_sent`
    - **description:** A list of files, that were sent as an attachment.
    - **example:** `["/data/in/files/544793857_chart.png", "/data/in/tables/_tableattachment_table1.csv"]`

The `errors` table contains following columns:

- `request_id`
    - **description:** A unique identification of the email attempt.
- `timestamp`
    - **description:** A UNIX timestamp in miliseconds of the event, when message was accepted by Mailgun.
    - **example:** `1580563285000`
- `specification`
    - **description:** A JSON representation of the email, that was sent. Contains mainly information from the input table.
    - **example:** `{"email":"testy@mctestface.com"}`
- `error`
    - **description:** Type of error.
    - **possible values:**
        - `TEMPLATE_NOT_FOUND_ERROR` - Specified template was not found.
        - `INVALID_TEMPLATE_ERROR` - Template was found, but it's not an .html file
        - `ATTACHMENT_NOT_FOUND_ERROR` - Specified attachment was not found in files or tables.
        - `EMAIL_TOO_LARGE_ERROR` - Email exceeds allowed 25MB.
        - `SEND_ERROR` - Email was sent to Mailgun, but the API returned an error.
- `error_message`
    - **description:** An error message accompanying `error` with further details.

## Development
 
This example contains runnable container with simple unittest. For local testing it is useful to include `data` folder in the root
and use docker-compose commands to run the container or execute tests. 

If required, change local data folder (the `CUSTOM_FOLDER` placeholder) path to your custom path:
```yaml
    volumes:
      - ./:/code
      - ./CUSTOM_FOLDER:/data
```

Clone this repository, init the workspace and run the component with following command:

```
git clone https://bitbucket.org:kds_consulting_team/kds-team.ex-ms-sharepoint.git my-new-component
cd my-new-component
docker-compose build
docker-compose run --rm dev
```

Run the test suite and lint check using this command:

```
docker-compose run --rm test
```


================================================
FILE: bitbucket-pipelines.yml
================================================
options:
  docker: true

pipelines:
  default:
    - step:
        caches:
          - docker
        script:
          - export APP_IMAGE=keboola-component
          - export TAG=${BITBUCKET_BRANCH//\//-}
          - docker build . --tag=$APP_IMAGE
          - docker images
          - docker -v
          - docker run $APP_IMAGE flake8 /code/ --config=/code/flake8.cfg
          - echo "Running unit-tests..."
          - docker run $APP_IMAGE python -m unittest discover
          # push test image to ecr - uncomment for testing before deployment
          - echo "Pushing test image to repo. [tag=${TAG}]"
          - export REPOSITORY=`docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP`
          - docker tag $APP_IMAGE:latest $REPOSITORY:$TAG
          - eval $(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)
          - docker push $REPOSITORY:$TAG


  branches:
    master:
      - step:
          caches:
            - docker
          script:
            - export APP_IMAGE=keboola-component
            - export TAG=${BITBUCKET_BRANCH//\//-}
            - docker build . --tag=$APP_IMAGE
            - docker images
            - docker -v
            - docker run $APP_IMAGE flake8 /code/ --config=/code/flake8.cfg
            - echo "Running unit-tests..."
            - docker run $APP_IMAGE python -m unittest discover
            # push test image to ecr - uncomment for testing before deployment
            - echo "Pushing test image to repo. [tag=${TAG}]"
            - export REPOSITORY=`docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP`
            - docker tag $APP_IMAGE:latest $REPOSITORY:$TAG
            - eval $(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)
            - docker push $REPOSITORY:$TAG
            - chmod +x ./scripts/update_dev_portal_properties.sh
            - ./scripts/update_dev_portal_properties.sh
  tags:
    '*':
      - step:
          deployment: production
          script:
            - export APP_IMAGE=keboola-component
            - docker build . --tag=$APP_IMAGE
            - docker images
            - docker run $APP_IMAGE flake8 /code/ --config=/code/flake8.cfg
            - echo "Running unit-tests..."
            - docker run $APP_IMAGE python -m unittest discover
            - echo "Preparing KBC test image"
            - docker pull quay.io/keboola/developer-portal-cli-v2:latest
            # push test image to ECR - uncomment when initialised
            # - export REPOSITORY=`docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP`
            # - docker tag $APP_IMAGE:latest $REPOSITORY:test
            # - eval $(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)
            # - docker push $REPOSITORY:test
            # - docker run --rm -e KBC_STORAGE_TOKEN quay.io/keboola/syrup-cli:latest run-job $KBC_DEVELOPERPORTAL_APP $BASE_KBC_CONFIG test
            # - docker run --rm -e KBC_STORAGE_TOKEN quay.io/keboola/syrup-cli:latest run-job $KBC_DEVELOPERPORTAL_APP $KBC_CONFIG_1 test
            - chmod +x ./scripts/update_dev_portal_properties.sh
            - chmod +x ./deploy.sh
            - ./scripts/update_dev_portal_properties.sh
            - ./deploy.sh


================================================
FILE: change_log.md
================================================
**0.1.0**
Added configuration description
Added long and short descriptions
Tweaked documentation
Added example configuration

**0.0.4**
Added check for emails larger than 25MB.
Added documentation.
Added check for invalid html template.
Errors loading incrementally to storage.

**0.0.2**
Configuration Schema added

**0.0.1**
First working version of the application
Allows users to send any file from storage or file storage


================================================
FILE: deploy.sh
================================================
#!/bin/sh
set -e

env

# compatibility with travis and bitbucket
if [ ! -z ${BITBUCKET_TAG} ]
then
	echo "assigning bitbucket tag"
	export TAG="$BITBUCKET_TAG"
elif [ ! -z ${TRAVIS_TAG} ]
then
	echo "assigning travis tag"
	export TAG="$TRAVIS_TAG"
elif [ ! -z ${GITHUB_TAG} ]
then
	echo "assigning github tag"
	export TAG="$GITHUB_TAG"
else
	echo No Tag is set!
	exit 1
fi

echo "Tag is '${TAG}'"

#check if deployment is triggered only in master
if [ ${BITBUCKET_BRANCH} != "master" ]; then
               echo Deploy on tagged commit can be only executed in master!
               exit 1
fi

# Obtain the component repository and log in
echo "Obtain the component repository and log in"
docker pull quay.io/keboola/developer-portal-cli-v2:latest
export REPOSITORY=`docker run --rm  \
    -e KBC_DEVELOPERPORTAL_USERNAME \
    -e KBC_DEVELOPERPORTAL_PASSWORD \
    quay.io/keboola/developer-portal-cli-v2:latest \
    ecr:get-repository ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP}`

echo "Set credentials"
eval $(docker run --rm \
    -e KBC_DEVELOPERPORTAL_USERNAME \
    -e KBC_DEVELOPERPORTAL_PASSWORD \
    quay.io/keboola/developer-portal-cli-v2:latest \
    ecr:get-login ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP})

# Push to the repository
echo "Push to the repository"
docker tag ${APP_IMAGE}:latest ${REPOSITORY}:${TAG}
docker tag ${APP_IMAGE}:latest ${REPOSITORY}:latest
docker push ${REPOSITORY}:${TAG}
docker push ${REPOSITORY}:latest

# Update the tag in Keboola Developer Portal -> Deploy to KBC
if echo ${TAG} | grep -c '^v\?[0-9]\+\.[0-9]\+\.[0-9]\+$'
then
    docker run --rm \
        -e KBC_DEVELOPERPORTAL_USERNAME \
        -e KBC_DEVELOPERPORTAL_PASSWORD \
        quay.io/keboola/developer-portal-cli-v2:latest \
        update-app-repository ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} ${TAG} ecr ${REPOSITORY}
else
    echo "Skipping deployment to KBC, tag ${TAG} is not allowed."
fi



================================================
FILE: docker-compose.yml
================================================
version: "2"
services:
  # for development purposes
  dev:
    build: .
    volumes:
        - ./:/code
        - ./data:/data
    environment:
      - KBC_DATADIR=./data
  test:
    # Use to run flake8 and unittests checks
    build: .
    volumes:
      - ./:/code
      - ./data:/data
    environment:
      - KBC_DATADIR=./data
    command:
      - /bin/sh
      - /code/scripts/build_n_test.sh


================================================
FILE: Dockerfile
================================================
FROM python:3.8.9-slim
ENV PYTHONIOENCODING utf-8

COPY . /code/

# install gcc to be able to build packages - e.g. required by regex, dateparser, also required for pandas
RUN apt-get update && apt-get install -y build-essential
RUN pip install flake8
RUN pip install -r /code/requirements.txt
WORKDIR /code/


CMD ["python3", "-u", "/code/src/component.py"]



================================================
FILE: flake8.cfg
================================================
[flake8]
exclude =
    .git,
    __pycache__,
    tests
max-line-length = 120

# F812: list comprehension redefines ...
# H101: Use TODO(NAME)
# H202: assertRaises Exception too broad
# H233: Python 3.x incompatible use of print operator
# H301: one import per line
# H306: imports not in alphabetical order (time, os)
# H401: docstring should not start with a space
# H403: multi line docstrings should end on a new line
# H404: multi line docstring should start without a leading new line
# H405: multi line docstring summary not separated with an empty line
# H501: Do not use self.__dict__ for string formatting



================================================
FILE: LICENSE.md
================================================
The MIT License (MIT)

Copyright (c) 2020 Keboola DS, http://keboola.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files, to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


================================================
FILE: requirements.txt
================================================
https://bitbucket.org/kds_consulting_team/keboola-python-util-lib/get/0.2.7.zip#egg=kbc
keboola.component==1.4.4
keboola.http_client==1.0.0
requests==2.31.0


================================================
FILE: component_config/component_long_description.md
================================================
# Mailgun

Mailgun is an email automation service. It offers a complete cloud-based email service for sending, receiving and tracking email sent through your websites and applications. This component allows to connect Mailgun with Keboola platform, for sending automation.

To successfully operate the component, following parameters are required:

- a private API key for Mailgun,
- a Mailgun domain.

If you're unsure on where to find the API key, follow the steps mentioned in the [documentation](https://help.mailgun.com/hc/en-us/articles/203380100-Where-Can-I-Find-My-API-Key-and-SMTP-Credentials-) on how to obtain the API key. When it comes to Mailgun domains, upon registering each user is provisioned a sandbox domain. The sandbox domain can only send email to [**authorized recipients**](https://help.mailgun.com/hc/en-us/articles/217531258-Authorized-Recipients). The limit is 5 authorized recipients per sandbox domain. It is therefore highly recommended to [register your own domain with Mailgun](https://help.mailgun.com/hc/en-us/articles/202256730-How-do-I-pick-a-domain-name-for-my-Mailgun-account-) to not be limited by sandbox restrictions.

##### Pricing

Note that Mailgun is a paid service and is subject to [Mailgun's Terms Of Service](https://www.mailgun.com/terms/). By default, each domain can send up to 10 000 emails per month for free. For more information about pricing, please visit [Mailgun's pricing explorer](https://www.mailgun.com/pricing).

## Changes from previous version

With a new version of Mailgun component, there were some changes, which make this version non-backwards compatible and hence some effort is required to migrate. Major changes include:

1. A region can be specified in the configuration (see [Parameters](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-parameters))
2. Changed column names for input table and support of more Mailgun features (see [Mailing list](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-mailing-list))
3. Sending tabular attachments straight from Keboola storage (see [Table input mapping](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-table-input-mapping))
4. Improved specification of attachments and templates and automatic selection of latest available file (see [Path specification to template or file attachment](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-path-specification-to-template-or-file-attachment))
5. Subject, plain-text or html template are now customized using `{{COLUMN_NAME}}` tags, instead of `%(COLUMN_NAME)s` as before (see [Email customization](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-email-customization))


================================================
FILE: component_config/component_short_description.md
================================================
Mailgun is an email automation service. It offers a complete cloud-based email service for sending, receiving and tracking email sent through your websites and applications.


================================================
FILE: component_config/configSchema.json
================================================
{
    "title": "Parameters",
    "type": "object",
    "required": [
        "#apiToken",
        "domainName",
        "domainRegion",
        "fromName"
    ],
    "properties": {
        "#apiToken": {
            "type": "string",
            "format": "password",
            "title": "API Key",
            "description": "API key for authentication purposes. See <a target='_blank' href='https://help.mailgun.com/hc/en-us/articles/203380100-Where-Can-I-Find-My-API-Key-and-SMTP-Credentials-'>Mailgun documentation</a> for more information.",
            "propertyOrder": 100,
            "minLength": 1
        },
        "domainName": {
            "type": "string",
            "title": "Domain",
            "description": "Mailgun domain; either sandbox or production version. E.g. johndoe@<b>mydomain.com</b> </br>If sandbox domain is used, please make sure, that all recipients are registered as <a target='_blank' href='https://help.mailgun.com/hc/en-us/articles/217531258-Authorized-Recipients'>authorized recipients</a>.",
            "propertyOrder": 200,
            "minLength": 1
        },
        "domainRegion": {
            "type": "string",
            "enum": [
                "US",
                "EU"
            ],
            "title": "Region",
            "description": "Region, where the domain is located.",
            "default": "US",
            "uniqueItems": true,
            "propertyOrder": 300
        },
        "fromName": {
            "type": "string",
            "title": "Sender Name",
            "description": "Name to be displayed as email signature of the sender. E.g. '<b>John Doe</b>'",
            "propertyOrder": 400
        },
        "fromEmail": {
            "type": "string",
            "title": "Sender's Local Part of Address",
            "description": "Local part of sender's email. Allows customization of the first part of sending email address. E.g. <b>johndoe</b> @mydomain.com",
            "propertyOrder": 500
        },
        "validation_button": {
            "type": "button",
            "format": "test-connection",
            "propertyOrder": 350,
            "options": {
                "async": {
                    "label": "TEST CONNECTION",
                    "action": "test_api_key"
                }
            }
        }
    }
}


================================================
FILE: component_config/configuration_description.md
================================================
### Changes from previous version

With a new version of Mailgun component, there were some changes, which make this version non-backwards compatible and hence some effort is required to migrate. Major changes include:

1. A region can be specified in the configuration (see [Parameters](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-parameters))
2. Changed column names for input table and support of more Mailgun features (see [Mailing list](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-mailing-list))
3. Sending tabular attachments straight from Keboola storage (see [Table input mapping](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-table-input-mapping))
4. Improved specification of attachments and templates and automatic selection of latest available file (see [Path specification to template or file attachment](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-path-specification-to-template-or-file-attachment))
5. Subject, plain-text or html template are now customized using `{{COLUMN_NAME}}` tags, instead of `%(COLUMN_NAME)s` as before (see [Email customization](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/README.md#markdown-header-email-customization))

### Configuration

The configuration of the component is done via a set of parameters, an input table and optional files. This, and all of the functionalities of the component, will be covered in this section. The documentation will extensively use the provided [sample configuration](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/src/master/component_config/sample-config/) to showcase the behavior of the application and how to cover special cases.

#### Parameters

The component takes a total of 5 parameters. Four of the parameters can be configured in the UI of Keboola, one is only configurable via API as its configuration is rather excess.

The four required parameters are:

- API Key 
    - **type:** required
    - **configuration name:** `#apiToken`
    - **description:** An API key used to authenticate all requests against Mailgun API. If invalid value is provided, the application fails. More information on how to obtain the API key can be found in the [documentation](https://help.mailgun.com/hc/en-us/articles/203380100-Where-Can-I-Find-My-API-Key-and-SMTP-Credentials-).
- Domain
    - **type:** required
    - **configuration name:** `domainName`
    - **description:** The name of the domain, which will be used for delivering emails. You can find a list of all your domain in the *Control Panel* under the *Domains* tab. For sandbox domains, the domain is in form `sandbox[uniqueId].mailgun.org`, e.g. `sandbox15d3020e03ca4f8db4895fca549a8b3a.mailgun.org`. If the provided domain is not associated with the API key, or the domain is not found, the application will fail.
- Region
    - **type:** required
    - **configuration name**: `domainRegion`
    - **default:** US
    - **description**: The region where the Mailgun account or domain is located. Available values are US (sending via [https://api.mailgun.net/](https://api.mailgun.net/)) or EU (sending via [https://api.eu.mailgun.net/](https://api.eu.mailgun.net/)). If incorrect region is specified, the application will fail due to domain not existing in the region.
- Sender Name
    - **type:** required
    - **configuration name:** `fromName`
    - **description:** The name which will be displayed as a sender of the messages from Mailgun. Can be left blank, in which case only the sender's email will be used as sender's identification.

An optional parameter, configurable only via API is:

- Sender Email
    - **type:** optional
    - **configuration name:** `fromEmail`
    - **description:** The local part of the email address used to send messages. [fromEmail]@[domainName]
    - **default:** `postmaster`

#### Mailing list

Mailing list is the input table of emails, with other specified parameters, to which the messages will be sent. Mailing list can be configured in the table input mapping section, or must be stored in `/data/in/tables/` folder, and must not contain `_tableattachment_` in the destination name, as that is reserved for tabular attachments. 

A combination of 3 columns is required and other columns could be used to specify the parameters of each message as well as customize the template.

The three mandatory columns are:

- `email`
    - **description:** A single email address or a comma-separated list of email addresses, to which a message will be sent. The column is mandatory, thus if the column is not provided, the application will fail.
    - **example:** `testy.mctesface@domain.com`; `sterling.archer@fx.com, mallory.archer@fx.com`
- `subject`
    - **description:** A mandatory column defining the subject of the message.
    - **example:** `Testing email`; `New job announcement`
- `html_file` or `text`
    - **description:** Column `html_file` defines the file name of the html template, which shall be used as the message body (see section **Customization and attachments**). Column `text` defines the plain text body of the message. Either of the columns or both can be provided. If both columns have a valid value, by default Mailgun API prioritizes the html content over plain text content. Both of the columns can be customized with additional parameters (more on that in section **Customization and attachments**).
    - **example:**
        - `template.html`; `questionnaire.html`
        - `A very warm welcome!`; `This is a sample message.`

In addition to three (four) mandatory columns, a set of optional columns can be provided to alter the behavior of the message. All of these columns have a blank default value. These columns are:

- `delivery_time`
    - **description:** A timestamp in **RFC 2822** format, i.e. format `Fri, 25 Oct 2019 19:00:00 +0200`. If undefined or left blank, the message will be delivered instantly. The email delivery can't be scheduled more than three days in advance by design of the API.
    - **Mailgun mapping:** `o:deliverytime`
    - **example:** `Fri, 25 Oct 2019 19:00:00 +0200`; `Fri, 25 Oct 2019 17:00:00 GMT`
    - **hints:**
        - in Snowflake, the RFC 2282 format can be achieved using format `DY, DD MON YYYY HH24:MI:SS TZHTZM`
        - in Python, the RFC 2282 format can be achieved using format `%a, %d %b %Y %H:%M:%S %z`
- `cc`
    - **description:** A single email address or a comma-separated list of email addresses, to which a copy of the email will be delivered.
    - **Mailgun mapping:** `cc`
    - **example:** same as `email`
- `bcc`
    - **description:** A single email address or a comma-separated list of email addresses, to which a blind copy of the email will be delivered.
    - **Mailgun mapping:** `bcc`
    - **example:** same as `email`
- `tags`
    - **description:** A single tag or a comma-separated list of tags, which will be attached to the image. Tags are very useful for tracking specific emails or campaigns. Up to 3 tags can be applied to a single message; if more than 3 are provided, only the first three in the list will be applied, by design of the API.
    - **Mailgun mapping:** `o:tag`
    - **example:** `abc`; `abc, 123, 567`
- `attachments`
    - **description:** A single file name or a comma-separated list of filenames, which will attached to a message. See section **Sending attachments** for more information on how to correctly specify attachments.
    - **Mailgun mapping:** `attachments`
    - **example:** `__tableattachment__data.csv`; `graph.png, 123456789_data.json`
- `custom_fields`
    - **description:** All other custom fields and headers which should be added to a message. Must be a valid JSON object. If the object passed is not a valid object, email sending is not halted. See [documentation](https://documentation.mailgun.com/en/latest/api-sending.html#sending) for all available options.
    - **example:** `{"h:Reply-To": "reply_email@keboola.com"}`

Besides all of the columns mentioned above, it is possible to specify additional columns which will be used to customize either the html template, or the plain text body of the message. In fact, any of the columns can be used for message body customization. More about customization is covered in **Customizing messages**.

#### File input mapping

Non-tabular files, such as html files, images, json, etc. can be used as attachments, or in case of html files as templates. In Keboola, all of these files must be properly mapped in *File input mapping* section, specifying the correct tags.

![](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/raw/master/docs/file-input-mapping.png)

All of the files are automatically stored in `/data/in/files/` folder.

#### Table input mapping

All tabular files from Keboola storage can be specified directly from Keboola's UI in the table input mapping section and must have a prefix `_tableattachment_`, otherwise they will be used as a mailing list; table without `_tableattachment_` prefix is not recognized as an attachment.

![](https://bitbucket.org/kds_consulting_team/kds-team.app-mailgun-v2/raw/master/docs/table-input-mapping.png)

All of the tables are automatically stored in `/data/in/tables/` folder.

### Customization and attachments

The Mailgun component is able to handle some forms of customizations for each email. Along with sending attachments from file and table storage, the component is able to send a customized html template for each email. **All templates must be stored in file storage (see section *File Input Mapping*) and attachments can be stored either in file storage, or if applicable in standard table storage.**

In this section, a customization of templates as well as specifying attachments will be discussed. But firstly, let's start with how the component chooses files based on specification.

#### Path specification to template or file attachment

In the previous version of Mailgun, a template or file attachment (further referred to as a file) had to be specified by it's full name only. Mailgun component could not perform any kind of search for patterns in names (glob search). This, of course, poised a problem when sending files from Keboola storage, since each filename is preceeded by its identificator, which is unknown to the user prior to uploading the file. For files, which are static and only uploaded once (e.g. templates), this might not be a problem. However, for files which are generated each day and then sent via Mailgun, this poised a problem. Often, a structure of files, similar to the one below, was created in Keboola file storage and users needed an extra transformation to determine the latest file's name.

```
445515655_report.pdf    321312312_template.html
446461182_report.pdf    760989809_template.html
446461232_report.pdf    944598324_template.html
451982978_report.pdf    131242341_logo.jpeg
478942334_report.pdf    542342123_graph.png
563242313_report.pdf    857923432_graph.png
589321233_report.pdf    878080998_graph.png
591233212_report.pdf    975763234_graph.png
623421321_report.pdf    653423674_report.pdf
```

With a new version of Mailgun, users are offered a much improved experience of file specification. Files (both html templates and files used for attachments) can be specified using a "simple" file name, without the identificator and Mailgun application will automatically choose the latest file based on available metadata.

For example, a following table with template and attachments can be specified.

| html_file               | attachments|
|-------------------------|------------|
| template.html           | report.pdf |
| 321312312_template.html | logo.jpeg  |

In the first row, the component first matches all files using glob, with a pattern of `*template.html`, which would in this case result in 3 files. Afterwards, the latest file is determined by using metadata (manifests) resulting in final file `944598324_template.html`, which will be used as a template. In case of attachments, identicall process is performed.

If you need to match a specific file precisely, you can do so by specifying its full name as is the case in the second row. Template `321312312_template.html` is one of the files present in the "environment" and is therefore used directly.

#### Email customization

Each email body can be specified either by a plain text (using column `text`) or by an html template (using column `html_file`). Mailgun component allows further customizations of the body (both plain text and html) and subject using special word tags. These word tags take a form of `{{COLUMN_NAME}}`, where `COLUMN_NAME` is a name of the column, with which value the tag should be replaced. 

As an example, imagine, that a following input table is provided:

| email                | subject                          | text                                                                             | name  | order_id |
|----------------------|----------------------------------|----------------------------------------------------------------------------------|-------|----------|
| testy@mctestface.com | Your order summary #{{order_id}} | Hello {{name}},   Summary of your order: Order ID: {{order_id}} Email: {{email}} | Testy | 12345678 |

The component would read the contents of the plain text specified, and iterate over each column and replace the column tag `{{}}`, with its column value. In this case, an email would be sent with a following form:

```
To: testy@mctestface.com
Subject: Your order summary #12345678

Body:
Hello Testy,

Summary of your order:
Order ID: 12345678
Email: testy@mctestface.com
```

Note, that any of the attributes in the mailing list table can be used to fill subject, plain-text body, or html-template body. In case, a tag specified in the body of the email is not present in the input table, it will not be replaced. As an example, let's have a following html file `greetings.html`:

```html
<p>
    <strong>
        Hello {{name}},<br>
    </strong>
</p>
<p>
    Here's your order {{order_id}} of product {{product}}, it will arrive soon.
</p>
```

and following input table:

| email                | subject                          | html_file      | name  | order_id | product |
|----------------------|----------------------------------|----------------|-------|----------|---------|
| testy@mctestface.com | Your order summary #{{order_id}} | greetings.html | Testy | 12345678 |  12345  |

Together, they will generate an email with the following form:

```
To: testy@mctestface.com
Subject: Your order summary #12345678

Body:
Hello Testy,

Here's your order 12345678 of product {{product}}, it will arrive soon.
```

#### Sending attachments

Mailgun component allows to send attachments both, from storage and file storage. Note, that total size of email **must no exceed 25MB**, otherwise it will not be accepted by the API and will be returned. Component performs a strict check for size prior to sending and all over-size emails are recorded in results table.

As discussed in previous sections, tabular attachments must have a suffix `_tableattachment_` and must be specified by their full name in the mailing list table. If multiple attachments are specified, their names must be separated by a comma. A combination of both tabular and file attachments is allowed, as long as they do not exceed 25MB.

Examples of attachments specification include:

```
_tableattachment_table1.csv, graph.png, report.pdf
131242341_logo.jpeg, _tableattachment_orders.csv
```


================================================
FILE: component_config/stack_parameters.json
================================================
{}


================================================
FILE: component_config/sample-config/config.json
================================================
{
  "parameters": {
    "#apiToken": "<TOKEN>",
    "domainName": "<DOMAIN_URL>",
    "domainRegion": "US",
    "fromName": "Keboola Mailgun Integration",
    "fromEmail": "postmaster"
  },
  "image_parameters": {},
  "storage": {}
}


================================================
FILE: component_config/sample-config/in/files/445515655_questionnaire.html
================================================
<!DOCTYPE html>
<html>

<body>
    <p>Hello {{name}},</p>
</body>

</html>


================================================
FILE: component_config/sample-config/in/files/445515655_questionnaire.html.manifest
================================================
{
    "id": 445515655,
    "name": "questionnaire.html",
    "created": "2018-09-17T17:13:53+0200",
    "is_public": false,
    "is_encrypted": true,
    "is_sliced": false,
    "tags": [
        "app-mailgun"
    ],
    "max_age_days": 0,
    "size_bytes": 2393
}


================================================
FILE: component_config/sample-config/in/files/452610617_questionnaire.html
================================================
<!DOCTYPE html>
<html>

<body>
    <p>Hello {{name}},</p>

    <p>Please, find attached a questionnaire to recently provided services.</p>
</body>

</html>


================================================
FILE: component_config/sample-config/in/files/452610617_questionnaire.html.manifest
================================================
{
    "id": 452610617,
    "name": "questionnaire.html",
    "created": "2018-10-05T15:05:22+0200",
    "is_public": false,
    "is_encrypted": true,
    "is_sliced": false,
    "tags": [
        "app-mailgun"
    ],
    "max_age_days": 0,
    "size_bytes": 2482
}


================================================
FILE: component_config/sample-config/in/tables/_tableattachment_list_questionnaire.csv
================================================
"ID","name","email","html_file","subject","attachments","delivery"
AS:ldaglasdfas;'dl ;akvlad';ls ;kma ;sd ;kaf
fasljdaskda;'slflknsD ;LF'KASKD AJNFVLLSA;D,ALK


================================================
FILE: component_config/sample-config/in/tables/_tableattachment_list_questionnaire.csv.manifest
================================================
{
    "id": "out.c-main.mailing_list_questionnaire",
    "uri": "https:\/\/connection.keboola.com\/v2\/storage\/tables\/out.c-main.mailing_list_questionnaire",
    "name": "mailing_list_questionnaire",
    "primary_key": [],
    "created": "2019-02-12T18:17:55+0100",
    "last_change_date": "2019-10-19T17:45:16+0200",
    "last_import_date": "2019-07-10T10:20:30+0200",
    "columns": [
        "ID",
        "name",
        "email",
        "html_file",
        "subject",
        "attachments",
        "delivery"
    ],
    "metadata": [
        {
            "id": "113414602",
            "key": "KBC.createdBy.component.id",
            "value": "transformation",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414603",
            "key": "KBC.createdBy.configuration.id",
            "value": "441004885",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414604",
            "key": "KBC.createdBy.configurationRow.id",
            "value": "442488327",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414605",
            "key": "KBC.lastUpdatedBy.component.id",
            "value": "transformation",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414606",
            "key": "KBC.lastUpdatedBy.configuration.id",
            "value": "441004885",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414607",
            "key": "KBC.lastUpdatedBy.configurationRow.id",
            "value": "442488327",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        }
    ],
    "column_metadata": {
        "ID": [],
        "name": [],
        "email": [],
        "html_file": [],
        "subject": [],
        "attachments": [],
        "delivery": []
    }
}


================================================
FILE: component_config/sample-config/in/tables/mailing_list_questionnaire.csv
================================================
"ID","name","email","text","subject","attachments","html_file"
"1234","Testy McTestFace","testymctestface@gmail.com","","Hello {{name}}!","_tableattachment_list_questionnaire.csv, i.png","questionnaire.html"


================================================
FILE: component_config/sample-config/in/tables/mailing_list_questionnaire.csv.manifest
================================================
{
    "id": "out.c-main.mailing_list_questionnaire",
    "uri": "https:\/\/connection.keboola.com\/v2\/storage\/tables\/out.c-main.mailing_list_questionnaire",
    "name": "mailing_list_questionnaire",
    "primary_key": [],
    "created": "2019-02-12T18:17:55+0100",
    "last_change_date": "2019-10-19T17:45:16+0200",
    "last_import_date": "2019-07-10T10:20:30+0200",
    "columns": [
        "ID",
        "name",
        "email",
        "html_file",
        "subject",
        "attachments",
        "delivery"
    ],
    "metadata": [
        {
            "id": "113414602",
            "key": "KBC.createdBy.component.id",
            "value": "transformation",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414603",
            "key": "KBC.createdBy.configuration.id",
            "value": "441004885",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414604",
            "key": "KBC.createdBy.configurationRow.id",
            "value": "442488327",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414605",
            "key": "KBC.lastUpdatedBy.component.id",
            "value": "transformation",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414606",
            "key": "KBC.lastUpdatedBy.configuration.id",
            "value": "441004885",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        },
        {
            "id": "113414607",
            "key": "KBC.lastUpdatedBy.configurationRow.id",
            "value": "442488327",
            "provider": "system",
            "timestamp": "2019-02-12T18:18:07+0100"
        }
    ],
    "column_metadata": {
        "ID": [],
        "name": [],
        "email": [],
        "html_file": [],
        "subject": [],
        "attachments": [],
        "delivery": []
    }
}


================================================
FILE: scripts/build_n_test.sh
================================================
#!/bin/sh
set -e

flake8 --config=flake8.cfg
python -m unittest discover


================================================
FILE: scripts/update_dev_portal_properties.sh
================================================
#!/usr/bin/env bash

set -e
# Obtain the component repository and log in
docker pull quay.io/keboola/developer-portal-cli-v2:latest


# Update properties in Keboola Developer Portal
echo "Updating long description"
value=`cat component_config/component_long_description.md`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} longDescription --value="$value"
else
    echo "longDescription is empty!"
    exit 1
fi

echo "Updating config schema"
value=`cat component_config/configSchema.json`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} configurationSchema --value="$value"
else
    echo "configurationSchema is empty!"
fi


echo "Updating config description"

value=`cat component_config/configuration_description.md`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} configurationDescription --value="$value"
else
    echo "configurationDescription is empty!"
fi


echo "Updating short description"

value=`cat component_config/component_short_description.md`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} shortDescription --value="$value"
else
    echo "shortDescription is empty!"
    exit 1
fi


================================================
FILE: src/component.py
================================================
import csv
import datetime
import glob
import json
import logging
import os
import re
import sys
import time
import requests
from hashlib import md5

from mailgun.client import MailgunClient
from mailgun.result import MailgunWriter

from keboola.component.base import ComponentBase, sync_action
from keboola.component.exceptions import UserException

APP_VERSION = '0.1.5'
LOG_LEVEL = 'INFO'
MAX_MESSAGE_SIZE = 24.9 * 1024 ** 2

KEY_API_TOKEN = '#apiToken'
KEY_DOMAIN_NAME = 'domainName'
KEY_DOMAIN_REGION = 'domainRegion'
KEY_FROM_NAME = 'fromName'
KEY_FROM_EMAIL = 'fromEmail'

MANDATORY_PARAMETERS = [KEY_API_TOKEN, KEY_DOMAIN_NAME, KEY_DOMAIN_REGION]

MESSAGES_FIELDS = ['message_id', 'timestamp', 'specification',
                   'html_file_used', 'attachments_sent']
MESSAGES_PK = ['message_id']
ERRORS_FIELDS = ['request_id', 'timestamp', 'specification',
                 'error', 'error_message']
ERRORS_PK = ['request_id']

REQUIRED_COLUMNS_HTML = ['email', 'subject', 'html_file']
REQUIRED_COLUMNS_TEXT = ['email', 'subject', 'text']


class MailgunMessage:
    def __init__(self):
        pass


class Component(ComponentBase):

    def __init__(self):
        super().__init__()
        self.writer_errors = None
        self.var_files = None
        self.var_table_attachments = None
        self.var_mailing_lists = None

        logging.info(f"Running component version {APP_VERSION}.")
        self.validate_configuration_parameters(MANDATORY_PARAMETERS)

        self.param_token = self.configuration.parameters[KEY_API_TOKEN]
        self.param_domain = self.configuration.parameters[KEY_DOMAIN_NAME]
        self.param_region = self.configuration.parameters[KEY_DOMAIN_REGION]
        self.param_from_name = self.configuration.parameters.get(KEY_FROM_NAME)
        self.param_from_email = self.configuration.parameters.get(KEY_FROM_EMAIL, 'postmaster') \
            if self.configuration.parameters.get(KEY_FROM_EMAIL, 'postmaster') != '' else 'postmaster'

        self.check_parameters()

    def run(self):

        self.check_input_tables_and_files()

        client = MailgunClient(param_token=self.param_token, param_domain=self.param_domain,
                               param_from_name=self.param_from_name, param_region=self.param_region,
                               param_from_email=self.param_from_email)

        writer_messages = MailgunWriter(data_path=self.tables_out_path, table_name='messages',
                                        table_fields=MESSAGES_FIELDS, primary_keys=MESSAGES_PK, incremental=True)

        self.writer_errors = MailgunWriter(data_path=self.tables_out_path, table_name='errors',
                                           table_fields=ERRORS_FIELDS, primary_keys=ERRORS_PK, incremental=True)

        for table in self.var_mailing_lists:
            with open(table) as mailing_list:
                reader = csv.DictReader(mailing_list)

                for row in reader:
                    logging.info("Starting sending process for %s." % row.get('email'))
                    msg = self.compose_message(row)  # noqa
                    msg_size = self.get_message_size(msg)

                    if msg is None:
                        logging.warning("Process for %s exited with errors." % row.get('email'))
                        continue

                    elif msg_size > MAX_MESSAGE_SIZE:
                        msg_size_mb = msg_size / 1024 ** 2
                        logging.warning("Process for %s exited with errors." % row.get('email'))
                        _utc = self.get_utc_time()
                        _specification = json.dumps(row)
                        self.writer_errors.writerow({'timestamp': _utc,
                                                     'specification': _specification,
                                                     'error': 'EMAIL_TOO_LARGE_ERROR',
                                                     'error_message': "Email exceeded max. size of 25MB. " +
                                                                      f"Total email size: {msg_size_mb}MB.",
                                                     'request_id': md5('|'.join([_utc, _specification]).encode())
                                                    .hexdigest()})
                        continue

                    sc, js = client.send_message(msg)

                    if sc == 200:
                        to_write = {}

                        to_write['message_id'] = js['id'].replace('<', '').replace('>', '')
                        to_write['timestamp'] = int(datetime.datetime.strptime(to_write['message_id'].split('.')[0],
                                                                               '%Y%m%d%H%M%S').timestamp() * 1000)
                        to_write['specification'] = json.dumps(row)
                        to_write['html_file_used'] = msg.html_file
                        to_write['attachments_sent'] = json.dumps(msg.attachments)

                        writer_messages.writerow(to_write)

                    else:
                        logging.warning(f"There were some errors sending email to {row.get('email')}.")

                        _utc = self.get_utc_time()
                        _specification = json.dumps(row)
                        self.writer_errors.writerow({'timestamp': _utc,
                                                     'specification': _specification,
                                                     'error': 'SEND_ERROR',
                                                     'error_message': js['message'],
                                                     'request_id': md5('|'.join([_utc, _specification]).encode())
                                                    .hexdigest()})

    def check_parameters(self):

        if 'sandbox' in self.param_domain:
            logging.warning(' '.join(["Using sandbox domain. Please, make sure all of the recipients are registered as",
                                      "authorized recipients. For more information, please refer to",
                                      "https://help.mailgun.com/hc/en-us/articles/217531258-Authorized-Recipients."]))

        r = r"[^\w\.!#$%&'*+-/=?^_`{\|}~]|[.]{2,}"
        local_part_rgx = re.findall(r, self.param_from_email)

        if len(local_part_rgx) != 0:
            raise UserException(f"Unsupported characters in local part of email: {local_part_rgx}")

    def check_input_tables_and_files(self):

        glob_tables = os.path.join(self.tables_in_path, '*.csv')
        glob_files = os.path.join(self.files_in_path, '*')
        input_tables = glob.glob(glob_tables)
        input_files = [os.path.basename(path_name).strip() for path_name in glob.glob(glob_files)]

        if len(input_tables) == 0:
            raise UserException("No input tables specified.")

        self.var_mailing_lists = [path_name for path_name in input_tables
                                  if not os.path.basename(path_name).startswith('_tableattachment_')]
        self.var_table_attachments = [os.path.basename(path_name) for path_name in input_tables
                                      if os.path.basename(path_name).startswith('_tableattachment_')]
        self.var_files = [os.path.basename(path_name).strip() for path_name in input_files
                          if not os.path.basename(path_name).endswith('.manifest')]

        for table_path in self.var_mailing_lists:

            manifest_path = table_path + '.manifest'
            with open(manifest_path) as man_file:

                table_columns = json.load(man_file)['columns']

            set_diff_html = set(REQUIRED_COLUMNS_HTML) - set(table_columns)
            set_diff_text = set(REQUIRED_COLUMNS_TEXT) - set(table_columns)

            if set_diff_html != set() and set_diff_text != set():
                raise UserException(' '.join(["Missing mandatory columns",
                                              "in the mailing input table \"%s\"." % os.path.basename(table_path),
                                              "Required columns are ['email', 'subject'] and at least",
                                              "one of ['html_file', 'text']"]))

    @staticmethod
    def get_latest_file(list_of_file_paths):
        max_filename = ''
        max_timestamp = '0'

        for file_path in list_of_file_paths:
            manifest_path = file_path + '.manifest'
            with open(manifest_path) as man_file:
                creation_date = json.load(man_file)['created']

                if creation_date > max_timestamp:
                    max_timestamp = creation_date
                    max_filename = file_path

        return max_filename

    def get_html_template(self, html_file_name):

        if html_file_name.strip() in self.var_files:
            return os.path.join(self.files_in_path, html_file_name.strip())
        else:
            glob_html = os.path.join(self.files_in_path, '*') + html_file_name.strip()
            matched_html = glob.glob(glob_html)

            if len(matched_html) == 1:
                return matched_html[0]
            elif len(matched_html) == 0:
                return ''

            elif len(matched_html) > 1:
                return self.get_latest_file(matched_html)

    def get_attachment(self, attachment_name):
        if attachment_name in self.var_files:
            return os.path.join(self.files_in_path, attachment_name)
        else:
            glob_attachment = os.path.join(self.files_in_path, '*') + attachment_name
            matched_attachment = glob.glob(glob_attachment)

            if len(matched_attachment) == 1:
                return matched_attachment[0]

            elif len(matched_attachment) == 0:
                return ''

            elif len(matched_attachment) > 1:
                return self.get_latest_file(matched_attachment)

    @staticmethod
    def get_utc_time():
        return str(int(time.time() * 1000))

    def get_table_attachment(self, table_attachment_name):
        if table_attachment_name in self.var_table_attachments:
            return os.path.join(self.tables_in_path, table_attachment_name)
        return ''

    def compose_message(self, row_dict):

        msg = MailgunMessage()
        msg.email = row_dict['email'].strip()
        subject_string = row_dict['subject'].strip()
        text_string = row_dict.get('text', '').strip()

        for key in row_dict:
            text_string = text_string.replace(f'{{{{{key}}}}}', row_dict[key])
            subject_string = subject_string.replace(f'{{{{{key}}}}}', row_dict[key])

        msg.text = text_string
        msg.subject = subject_string

        if row_dict.get('delivery_time', '').strip() != '':
            msg.delivery_time = row_dict['delivery_time']
        else:
            msg.delivery_time = None

        if row_dict.get('tags', '').strip() != '':
            msg.tags = [t.strip()
                        for t in row_dict['tags'].split(',') if t.strip() != '']
        else:
            msg.tags = []

        if row_dict.get('bcc', '').strip() != '':
            msg.bcc = row_dict['bcc']
        else:
            msg.bcc = None

        if row_dict.get('cc', '').strip() != '':
            msg.cc = row_dict['cc']
        else:
            msg.cc = None

        if row_dict.get('html_file', '').strip() != '':

            html_file = row_dict['html_file']
            path_html = self.get_html_template(html_file)

            if path_html == '':

                _utc = self.get_utc_time()
                _specification = json.dumps(row_dict)

                logging.warning(f"Could not locate html template {html_file}.")
                self.writer_errors.writerow({'timestamp': _utc,
                                             'specification': _specification,
                                             'error': 'TEMPLATE_NOT_FOUND_ERROR',
                                             'error_message': f"Could not locate html file {html_file}.",
                                             'request_id': md5('|'.join([_utc, _specification]).encode())
                                            .hexdigest()})

                return None

            elif os.path.splitext(path_html)[1] != '.html':

                _utc = self.get_utc_time()
                _specification = json.dumps(row_dict)

                logging.warning(f"Invalid html template {html_file}.")
                self.writer_errors.writerow({'timestamp': _utc,
                                             'specification': _specification,
                                             'error': 'INVALID_TEMPLATE_ERROR',
                                             'error_message': f"Template {path_html}"
                                                              f" for {html_file} is not an html file.",
                                             'request_id': md5('|'.join([_utc, _specification]).encode())
                                            .hexdigest()})

                return None
            else:
                html_string = open(path_html).read()
                for key in row_dict:
                    html_string = html_string.replace(f'{{{{{key}}}}}', row_dict[key])

                msg.html = html_string
                msg.html_file = path_html
        else:
            msg.html_file = ''
            msg.html = ''

        if row_dict.get('attachments', '').strip() != '':
            attachments_string = row_dict['attachments'].strip()
            attachments_split = [
                att.strip() for att in attachments_string.split(',') if att.strip() != '']

            attachments_paths = []
            for att in attachments_split:
                if '_tableattachment_' in att:
                    attachments_paths += [self.get_table_attachment(att)]
                else:
                    attachments_paths += [self.get_attachment(att)]

            if '' in attachments_paths:
                idx = attachments_paths.index('')
                att_name = attachments_split[idx]
                logging.warning("Could not locate file %s." % att_name)

                _utc = self.get_utc_time()
                _specification = json.dumps(row_dict)
                self.writer_errors.writerow({'timestamp': _utc,
                                             'specification': _specification,
                                             'error': 'ATTACHMENT_NOT_FOUND_ERROR',
                                             'error_message': f'Could not locate attachment {att_name}.',
                                             'request_id': md5('|'.join([_utc, _specification]).encode())
                                            .hexdigest()})
                return None
            else:
                msg.attachments = attachments_paths
        else:
            msg.attachments = []

        if row_dict.get('custom_fields', '').strip() != '':
            _custom_fields = ''

            try:
                _custom_fields = json.loads(row_dict.get('custom_fields', ''))

                if isinstance(_custom_fields, dict) is False:
                    _custom_fields = {}
            except ValueError:
                _custom_fields = None
            finally:
                msg.custom_fields = _custom_fields

        else:
            msg.custom_fields = None
        return msg

    @staticmethod
    def get_message_size(msg_object):
        total_msg_size = 0

        if msg_object is None:
            return None

        for key, value in vars(msg_object).items():
            if key == 'attachments':
                for path in value:
                    total_msg_size += os.path.getsize(path)
            else:
                total_msg_size += sys.getsizeof(value)

            return total_msg_size

    @sync_action('testConnection')
    def test_api_key(self):
        region_urls = {
            'US': f'https://api.mailgun.net/v3/{self.param_domain}/events',
            'EU': f'https://api.eu.mailgun.net/v3/{self.param_domain}/events'
        }
        auth = requests.auth.HTTPBasicAuth('api', self.param_token)
        response = requests.get(region_urls[self.param_region], auth=auth)

        try:
            response.raise_for_status()
        except requests.exceptions.HTTPError:
            UserException("Validation failed. Please check the credentials.")


if __name__ == "__main__":
    try:
        comp = Component()
        comp.execute_action()
    except UserException as exc:
        logging.exception(exc)
        exit(1)
    except Exception as exc:
        logging.exception(exc)
        exit(2)



================================================
FILE: src/mailgun/client.py
================================================
import os
import logging
from keboola.http_client import HttpClient
from keboola.component.exceptions import UserException
from requests.exceptions import JSONDecodeError


REGION_URLS = {
    'US': 'https://api.mailgun.net/v3',
    'EU': 'https://api.eu.mailgun.net/v3'
}


class AuthenticationError(Exception):
    pass


class MailgunClientException(Exception):
    pass


class MailgunClient(HttpClient):

    def __init__(self, param_token, param_domain, param_from_name, param_region, param_from_email='postmaster'):
        if param_region not in REGION_URLS:
            raise MailgunClientException(f"Unknown region {param_region}. "
                                         f"Allowed values are: {list(REGION_URLS.keys())}.")

        base_url = os.path.join(REGION_URLS[param_region], param_domain)

        super().__init__(base_url, auth=('api', param_token))
        self._validate_authentication()

        if param_from_name is None:
            self.param_from_id = f'{param_from_email}@{param_domain}'
        else:
            self.param_from_id = ' '.join([param_from_name, f'<{param_from_email}@{param_domain}>'])

    def _validate_authentication(self):

        req_url = os.path.join(self.base_url, 'events')
        req_headers = {'accept': 'application/json'}
        req_params = {'limit': 1}

        validation_request = self.get_raw(req_url, headers=req_headers, params=req_params)
        _val_sc = validation_request.status_code

        try:
            _val_js = validation_request.json()
        except JSONDecodeError as e:
            raise AuthenticationError(f"Cannot authenticate. Details: "
                                      f"{validation_request.text} \n"
                                      f"{e}") from e

        if _val_sc == 200:
            logging.info("Authentication successful.")
        else:
            raise UserException("Authentication was not successful. Please check the credentials.\n"
                                "Response received: %s - %s." % (_val_sc, _val_js))

    def send_message(self, msg_object):

        req_body = {
            'from': self.param_from_id,
            'to': msg_object.email,
            'subject': msg_object.subject,
            'html': msg_object.html,
            'text': msg_object.text
        }

        if msg_object.delivery_time is not None:
            req_body['o:deliverytime'] = msg_object.delivery_time

        if msg_object.cc is not None:
            req_body['cc'] = msg_object.cc

        if msg_object.bcc is not None:
            req_body['bcc'] = msg_object.bcc

        if msg_object.tags:
            req_body['o:tag'] = msg_object.tags

        if msg_object.custom_fields is not None:
            req_body = {**msg_object.custom_fields, **req_body}

        logging.debug(f"Body: {req_body}")

        req_files = []
        for path in msg_object.attachments:
            req_files += [('attachment', (os.path.basename(path).replace('_tableattachment_', ''),
                                          open(path, 'rb').read()))]

        logging.debug(f"Attachments: {req_files}")

        req_url = os.path.join(self.base_url, 'messages')
        req_send_message = self.post_raw(req_url, files=req_files, data=req_body, is_absolute_path=True)
        message_sc, message_js = req_send_message.status_code, req_send_message.json()

        logging.debug("Message response:")
        logging.debug(message_js)

        return message_sc, message_js



================================================
FILE: src/mailgun/result.py
================================================
import csv
import json
import os


class MailgunWriter:

    def __init__(self, data_path, table_name, table_fields, primary_keys, incremental=True):

        self.writer = None
        self.var_table_path = None
        self.param_data_path = data_path
        self.param_table_name = table_name
        self.param_table_fields = table_fields
        self.param_pk = primary_keys
        self.param_incremental = incremental

        self.run()

    def run(self):
        self.create_writer()
        self.create_manifest()

    def create_manifest(self):

        _template = {'incremental': self.param_incremental,
                     'primary_key': self.param_pk}

        _man_path = self.var_table_path + '.manifest'

        with open(_man_path, 'w') as man_file:
            json.dump(_template, man_file)

    def create_writer(self):

        self.var_table_path = os.path.join(
            self.param_data_path, self.param_table_name) + '.csv'

        self.writer = csv.DictWriter(open(self.var_table_path, 'w'), fieldnames=self.param_table_fields,
                                     restval='', extrasaction='ignore', quotechar='\"',
                                     quoting=csv.QUOTE_ALL)

        self.writer.writeheader()

    def writerow(self, write_dict):
        self.writer.writerow(write_dict)



================================================
FILE: tests/__init__.py
================================================
[Empty file]


================================================
FILE: tests/test_component.py
================================================
[Empty file]

