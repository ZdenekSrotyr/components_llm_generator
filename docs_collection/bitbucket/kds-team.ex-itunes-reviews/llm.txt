Directory structure:
└── kds_consulting_team-kds-team.ex-itunes-reviews/
    ├── README.md
    ├── bitbucket-pipelines.yml
    ├── change_log.md
    ├── deploy.sh
    ├── docker-compose.yml
    ├── Dockerfile
    ├── flake8.cfg
    ├── LICENSE.md
    ├── requirements.txt
    ├── component_config/
    │   ├── component_long_description.md
    │   ├── component_short_description.md
    │   ├── configSchema.json
    │   ├── configuration_description.md
    │   ├── stack_parameters.json
    │   └── sample-config/
    │       ├── config.json
    │       └── in/
    │           ├── state.json
    │           └── tables/
    │               ├── test.csv
    │               └── test.csv.manifest
    ├── scripts/
    │   ├── build_n_run.ps1
    │   ├── build_n_test.sh
    │   ├── run.bat
    │   ├── run.sh
    │   ├── run_kbc_tests.ps1
    │   └── update_dev_portal_properties.sh
    ├── src/
    │   ├── component.py
    │   └── lib/
    │       ├── __init__.py
    │       ├── app.py
    │       └── client.py
    └── tests/
        ├── __init__.py
        └── test_component.py

================================================
FILE: README.md
================================================
# iTunes Reviews Extractor

The iTunes Reviews extractor allows users to download reviews for any iTunes object (applications, songs, albumns, books, etc.) in Apple's database. The extractor downloads reviews for specified countries and incrementally saves them in Keboola Storage.

## API limitations

The extractor is limited to make 20 calls per minute, which is the direct limitation of the iTunes API. Moreover, due to storage reason, only 500 latest reviews are stored in iTunes API, hence only the latest 500 reviews can be downloaded for each object. 

**Note:** If the list of object and/or countries is too big, the extractor might be running for a couple of hours before finishing due to above API limitations.

## Configuration

Configuration of the extractor is very simple; all that's needed is a list of id's of objects and countries for which the reviews will be downloaded. The sample configuration can be found in the [extractor's repository](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/).

### Input table

The input table must be a table of **1 column** containing the id of the object. The extractor will loop over the list to download reviews for each specified object. If the 1 column specification is not met, the extractor will fail. The sample of the input table can be found [here](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/in/tables/test.csv).

### Countries

If the option `All countries` is selected, for each object reviews from all available countries is downloaded. Otherwise, only reviews for specified countries will be downloaded. 
If the extractor is configured via API, valid country codes must be provided. To download for all countries, use `ALL` option. See the [iTunes pages](https://affiliate.itunes.apple.com/resources/documentation/linking-to-the-itunes-music-store/#CountryCodes) for the list of all available countries and their respective country codes.

### Backfill

By default, the extractor only downloads reviews for objects, that were updated since the last successful run. By specifying `backfill` option to `true`, the extractor will download the latest 500 reviews (if available) regardless of the last successful run.

### Output

The output is a table of reviews for each object. The table is laoded incrementally into storage and uses `review_id`, `updated` and `country_code` columns as primary keys. Note that it is possible to have reviews with same `review_id` and `country_code`, but different `updated`, due to possibility of editing certain reviews. The expected output table can be found [here](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/out/tables/reviews.csv).

## Development

To run application locally or further develop it, run the following commands

```
docker-compose build
docker-compose run dev
```

which will build and run the `dev` image of application.


================================================
FILE: bitbucket-pipelines.yml
================================================
options:
  docker: true

pipelines:
  default:
    - step:
        script:
          - export APP_IMAGE=$APP_IMAGE
          - docker build . --tag=$APP_IMAGE
          - docker images
          - docker -v
          - docker run $APP_IMAGE flake8 /code/ --config=/code/flake8.cfg
          - echo "Running unit-tests..."
          - docker run $APP_IMAGE python -m unittest discover
          # push test image to ecr - uncomment for testing before deployment
#          - echo 'Pushing test image to repo. [tag=test]'
#          - export REPOSITORY=`docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP`
#          - docker tag $APP_IMAGE:latest $REPOSITORY:test
#          - eval $(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)
#          - docker push $REPOSITORY:test

  branches:
    master:
      - step:
          script:
            - export APP_IMAGE=$APP_IMAGE
            - docker build . --tag=$APP_IMAGE
            - docker images
            - docker -v
            - docker run $APP_IMAGE flake8 /code/ --config=/code/flake8.cfg
            - echo "Running unit-tests..."
            - docker run $APP_IMAGE python -m unittest discover
            # push test image to ecr - uncomment for testing before deployment
#            - echo 'Pushing test image to repo. [tag=test]'
#            - export REPOSITORY=`docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP`
#            - docker tag $APP_IMAGE:latest $REPOSITORY:test
#            - eval $(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)
#            - docker push $REPOSITORY:test
            - ./scripts/update_dev_portal_properties.sh
  tags:
    '*':
      - step:
          deployment: production
          script:
            - export APP_IMAGE=$APP_IMAGE
            - docker build . --tag=$APP_IMAGE
            - docker images
            - docker run $APP_IMAGE flake8 /code/ --config=/code/flake8.cfg
            - echo "Running unit-tests..."
            - docker run $APP_IMAGE python -m unittest discover
            - echo "Preparing KBC test image"
            - docker pull quay.io/keboola/developer-portal-cli-v2:latest
            # push test image to ECR - uncomment when initialised
            - export REPOSITORY=`docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP`
            - docker tag $APP_IMAGE:latest $REPOSITORY:test
            - eval $(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)
            - docker push $REPOSITORY:test
            - docker run --rm -e KBC_STORAGE_TOKEN quay.io/keboola/syrup-cli:latest run-job $KBC_DEVELOPERPORTAL_APP 503519629 test
            # - docker run --rm -e KBC_STORAGE_TOKEN quay.io/keboola/syrup-cli:latest run-job $KBC_DEVELOPERPORTAL_APP $KBC_CONFIG_1 test
            - ./scripts/update_dev_portal_properties.sh
            - ./deploy.sh


================================================
FILE: change_log.md
================================================
**0.1.0**
Added documentation and proper configuration description.
Cosmetic changes to code.
Ready for publication.

**0.0.3**
Added configuration schema

**0.0.2**
Added check for empty input and logging gelf.

**0.0.1**
Initial version of the component.


================================================
FILE: deploy.sh
================================================
#!/bin/sh
set -e

#check if deployment is triggered only in master
if [ $BITBUCKET_BRANCH != "master" ]; then
               echo Deploy on tagged commit can be only executed in master!
               exit 1
fi

# Obtain the component repository and log in
docker pull quay.io/keboola/developer-portal-cli-v2:latest
export REPOSITORY=`docker run --rm  \
    -e KBC_DEVELOPERPORTAL_USERNAME \
    -e KBC_DEVELOPERPORTAL_PASSWORD \
    quay.io/keboola/developer-portal-cli-v2:latest \
    ecr:get-repository ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP}`

eval $(docker run --rm \
    -e KBC_DEVELOPERPORTAL_USERNAME \
    -e KBC_DEVELOPERPORTAL_PASSWORD \
    quay.io/keboola/developer-portal-cli-v2:latest \
    ecr:get-login ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP})

# Push to the repository
docker tag ${APP_IMAGE}:latest ${REPOSITORY}:${BITBUCKET_TAG}
docker tag ${APP_IMAGE}:latest ${REPOSITORY}:latest
docker push ${REPOSITORY}:${BITBUCKET_TAG}
docker push ${REPOSITORY}:latest

# Update the tag in Keboola Developer Portal -> Deploy to KBC
if echo ${BITBUCKET_TAG} | grep -c '^v\?[0-9]\+\.[0-9]\+\.[0-9]\+$'
then
    docker run --rm \
        -e KBC_DEVELOPERPORTAL_USERNAME \
        -e KBC_DEVELOPERPORTAL_PASSWORD \
        quay.io/keboola/developer-portal-cli-v2:latest \
        update-app-repository ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} ${BITBUCKET_TAG} ecr ${REPOSITORY}
else
    echo "Skipping deployment to KBC, tag ${BITBUCKET_TAG} is not allowed."
fi



================================================
FILE: docker-compose.yml
================================================
version: "0.0.1"
services:
  # for development purposes
  dev:
    build: .
    volumes:
        - ./:/code
        - ./data:/data
    environment:
      - KBC_DATADIR=./data
    command: 
      - /bin/sh
      - /code/scripts/run.sh
  test:
    # Use to run flake8 and unittests checks
    build: .
    volumes:
      - ./:/code
      - ./data:/data
    environment:
      - KBC_DATADIR=./data
    command:
      - /bin/sh
      - /code/scripts/build_n_test.sh


================================================
FILE: Dockerfile
================================================
FROM quay.io/keboola/docker-custom-python:latest

COPY . /code/
# COPY /data/ /data/

RUN pip install --ignore-installed -r /code/requirements.txt

# CODE FOLDERS
WORKDIR /code/

# RUN THE MAIN PYTHON SCRIPT
CMD ["python", "-u", "/code/src/component.py"]


================================================
FILE: flake8.cfg
================================================
[flake8]
exclude =
    .git,
    __pycache__,
    tests
max-line-length = 120

# F812: list comprehension redefines ...
# H101: Use TODO(NAME)
# H202: assertRaises Exception too broad
# H233: Python 3.x incompatible use of print operator
# H301: one import per line
# H306: imports not in alphabetical order (time, os)
# H401: docstring should not start with a space
# H403: multi line docstrings should end on a new line
# H404: multi line docstring should start without a leading new line
# H405: multi line docstring summary not separated with an empty line
# H501: Do not use self.__dict__ for string formatting



================================================
FILE: LICENSE.md
================================================
The MIT License (MIT)

Copyright (c) 2018 Keboola DS, http://keboola.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files, to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


================================================
FILE: requirements.txt
================================================
logging_gelf
lxml
https://github.com/keboola/python-docker-application/zipball/master#egg=keboola
https://bitbucket.org/kds_consulting_team/keboola-python-util-lib/get/0.2.0.zip#egg=kbc



================================================
FILE: component_config/component_long_description.md
================================================
# iTunes Reviews Extractor

The iTunes Reviews extractor allows users to download reviews for any iTunes object (applications, songs, albumns, books, etc.) in Apple's database. The extractor downloads reviews for specified countries and incrementally saves them in Keboola Storage.

## API limitations

The extractor is limited to make 20 calls per minute, which is the direct limitation of the iTunes API. Moreover, due to storage reason, only 500 latest reviews are stored in iTunes API, hence only the latest 500 reviews can be downloaded for each object. 

**Note:** If the list of object and/or countries is too big, the extractor might be running for a couple of hours before finishing due to above API limitations.

## Configuration

Configuration of the extractor is very simple; all that's needed is a list of id's of objects and countries for which the reviews will be downloaded. The sample configuration can be found in the [extractor's repository](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/).

### Input table

The input table must be a table of **1 column** containing the id of the object. The extractor will loop over the list to download reviews for each specified object. If the 1 column specification is not met, the extractor will fail. The sample of the input table can be found [here](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/in/tables/test.csv).

### Countries

If the option `All countries` is selected, for each object reviews from all available countries is downloaded. Otherwise, only reviews for specified countries will be downloaded. 
If the extractor is configured via API, valid country codes must be provided. To download for all countries, use `ALL` option. See the [iTunes pages](https://affiliate.itunes.apple.com/resources/documentation/linking-to-the-itunes-music-store/#CountryCodes) for the list of all available countries and their respective country codes.

### Backfill

By default, the extractor only downloads reviews for objects, that were updated since the last successful run. By specifying `backfill` option to `true`, the extractor will download the latest 500 reviews (if available) regardless of the last successful run.

### Output

The output is a table of reviews for each object. The table is laoded incrementally into storage and uses `review_id`, `updated` and `country_code` columns as primary keys. Note that it is possible to have reviews with same `review_id` and `country_code`, but different `updated`, due to possibility of editing certain reviews. The expected output table can be found [here](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/out/tables/reviews.csv).

## Development

To run application locally or further develop it, run the following commands

```
docker-compose build
docker-compose run dev
```

which will build and run the `dev` image of application.


================================================
FILE: component_config/component_short_description.md
================================================
Download reviews for any object in iTunes database.


================================================
FILE: component_config/configSchema.json
================================================
{
    "title": "Parameters",
    "type": "object",
    "required": [
        "country_code",
        "backfill_mode"
    ],
    "properties": {
        "backfill_mode": {
            "type": "boolean",
            "title": "Backfill",
            "default": false,
            "description": "If checked, the extractor will ignore previously saved state and download all reviews.",
            "propertyOrder": 200
        },
        "country_code": {
            "type": "array",
            "title": "Countries",
            "items":{
                "type":"string",
                "enum": [
                    "ALL",
                    "DZ",
                    "AO",
                    "AI",
                    "AG",
                    "AR",
                    "AM",
                    "AU",
                    "AT",
                    "AZ",
                    "BH",
                    "BD",
                    "BB",
                    "BY",
                    "BE",
                    "BZ",
                    "BM",
                    "BO",
                    "BW",
                    "BR",
                    "VG",
                    "BN",
                    "BG",
                    "CA",
                    "KY",
                    "CL",
                    "CN",
                    "CO",
                    "CR",
                    "CI",
                    "HR",
                    "CY",
                    "CZ",
                    "DK",
                    "DM",
                    "DO",
                    "EC",
                    "EG",
                    "SV",
                    "EE",
                    "FI",
                    "FR",
                    "DE",
                    "GH",
                    "GR",
                    "GD",
                    "GT",
                    "GY",
                    "HN",
                    "HK",
                    "HU",
                    "IS",
                    "IN",
                    "ID",
                    "IE",
                    "IL",
                    "IT",
                    "JM",
                    "JP",
                    "JO",
                    "KZ",
                    "KE",
                    "KR",
                    "KW",
                    "LV",
                    "LB",
                    "LI",
                    "LT",
                    "LU",
                    "MO",
                    "MK",
                    "MG",
                    "MY",
                    "MV",
                    "ML",
                    "MT",
                    "MU",
                    "MX",
                    "MD",
                    "MS",
                    "NP",
                    "NL",
                    "NZ",
                    "NI",
                    "NE",
                    "NG",
                    "NO",
                    "OM",
                    "PK",
                    "PA",
                    "PY",
                    "PE",
                    "PH",
                    "PL",
                    "PT",
                    "QA",
                    "RO",
                    "RU",
                    "SA",
                    "SN",
                    "RS",
                    "SG",
                    "SK",
                    "SI",
                    "ZA",
                    "ES",
                    "LK",
                    "KN",
                    "LC",
                    "VC",
                    "SR",
                    "SE",
                    "CH",
                    "TW",
                    "TZ",
                    "TH",
                    "BS",
                    "TT",
                    "TN",
                    "TR",
                    "TC",
                    "UG",
                    "GB",
                    "UA",
                    "AE",
                    "UY",
                    "US",
                    "UZ",
                    "VE",
                    "VN",
                    "YE"
                ],
                "options":{
                    "enum_titles":[
                        "All countries",
                        "Algeria",
                        "Angola",
                        "Anguilla",
                        "Antigua & Barbuda",
                        "Argentina",
                        "Armenia",
                        "Australia",
                        "Austria",
                        "Azerbaijan",
                        "Bahrain",
                        "Bangladesh",
                        "Barbados",
                        "Belarus",
                        "Belgium",
                        "Belize",
                        "Bermuda",
                        "Bolivia",
                        "Botswana",
                        "Brazil",
                        "British Virgin Islands",
                        "Brunei",
                        "Bulgaria",
                        "Canada",
                        "Cayman Islands",
                        "Chile",
                        "China",
                        "Colombia",
                        "Costa Rica",
                        "Cote D’Ivoire",
                        "Croatia",
                        "Cyprus",
                        "Czech Republic",
                        "Denmark",
                        "Dominica",
                        "Dominican Rep.",
                        "Ecuador",
                        "Egypt",
                        "El Salvador",
                        "Estonia",
                        "Finland",
                        "France",
                        "Germany",
                        "Ghana",
                        "Greece",
                        "Grenada",
                        "Guatemala",
                        "Guyana",
                        "Honduras",
                        "Hong Kong",
                        "Hungary",
                        "Iceland",
                        "India",
                        "Indonesia",
                        "Ireland",
                        "Israel",
                        "Italy",
                        "Jamaica",
                        "Japan",
                        "Jordan",
                        "Kazakstan",
                        "Kenya",
                        "Korea, Republic Of",
                        "Kuwait",
                        "Latvia",
                        "Lebanon",
                        "Liechtenstein",
                        "Lithuania",
                        "Luxembourg",
                        "Macau",
                        "Macedonia",
                        "Madagascar",
                        "Malaysia",
                        "Maldives",
                        "Mali",
                        "Malta",
                        "Mauritius",
                        "Mexico",
                        "Moldova, Republic Of",
                        "Montserrat",
                        "Nepal",
                        "Netherlands",
                        "New Zealand",
                        "Nicaragua",
                        "Niger",
                        "Nigeria",
                        "Norway",
                        "Oman",
                        "Pakistan",
                        "Panama",
                        "Paraguay",
                        "Peru",
                        "Philippines",
                        "Poland",
                        "Portugal",
                        "Qatar",
                        "Romania",
                        "Russia",
                        "Saudi Arabia",
                        "Senegal",
                        "Serbia",
                        "Singapore",
                        "Slovakia",
                        "Slovenia",
                        "South Africa",
                        "Spain",
                        "Sri Lanka",
                        "St. Kitts & Nevis",
                        "St. Lucia",
                        "St. Vincent & The Grenadines",
                        "Suriname",
                        "Sweden",
                        "Switzerland",
                        "Taiwan",
                        "Tanzania",
                        "Thailand",
                        "The Bahamas",
                        "Trinidad & Tobago",
                        "Tunisia",
                        "Turkey",
                        "Turks & Caicos",
                        "Uganda",
                        "UK",
                        "Ukraine",
                        "United Arab Emirates",
                        "Uruguay",
                        "USA",
                        "Uzbekistan",
                        "Venezuela",
                        "Vietnam",
                        "Yemen"
                    ]
                } 
            },
            "uniqueItems": true,
            "propertyOrder": 100,
            "format":"select"
        }
    }
}


================================================
FILE: component_config/configuration_description.md
================================================
## Configuration

Configuration of the extractor is very simple; all that's needed is a list of id's of objects and countries for which the reviews will be downloaded. The sample configuration can be found in the [extractor's repository](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/).

### Input table

The input table must be a table of **1 column** containing the id of the object. The extractor will loop over the list to download reviews for each specified object. If the 1 column specification is not met, the extractor will fail. The sample of the input table can be found [here](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/in/tables/test.csv).

### Countries

If the option `All countries` is selected, for each object reviews from all available countries is downloaded. Otherwise, only reviews for specified countries will be downloaded. 
If the extractor is configured via API, valid country codes must be provided. To download for all countries, use `ALL` option. See the [iTunes pages](https://affiliate.itunes.apple.com/resources/documentation/linking-to-the-itunes-music-store/#CountryCodes) for the list of all available countries and their respective country codes.

### Backfill

By default, the extractor only downloads reviews for objects, that were updated since the last successful run. By specifying `backfill` option to `true`, the extractor will download the latest 500 reviews (if available) regardless of the last successful run.

### Output

The output is a table of reviews for each object. The table is laoded incrementally into storage and uses `review_id`, `updated` and `country_code` columns as primary keys. Note that it is possible to have reviews with same `review_id` and `country_code`, but different `updated`, due to possibility of editing certain reviews. The expected output table can be found [here](https://bitbucket.org/kds_consulting_team/kds-team.ex-itunes-reviews/src/master/component_config/sample-config/out/tables/reviews.csv).


================================================
FILE: component_config/stack_parameters.json
================================================
{}


================================================
FILE: component_config/sample-config/config.json
================================================
{
  "storage": {
    "input": {
      "files": [],
      "tables": [
        {
          "source": "in.c-test.test",
          "destination": "test.csv"
        }
      ]
    },
    "output": {
      "files": [],
      "tables": []
    }
  },
  "parameters": {
    "country_code":["CA", "US", "GB"],
    "backfill_mode": false
  },
  "image_parameters": {}
}



================================================
FILE: component_config/sample-config/in/state.json
================================================
{
    "861957320":{
        "CA":"2019-01-01T00:00:00-07:00",
        "GB":"2020-01-01T00:00:00-07:00"
    },
    "12345678":{
        "CA":null
    },
    "1411625594":{
        "CA":"2020-01-01T00:00:00-07:00"
    }
}


================================================
FILE: component_config/sample-config/in/tables/test.csv
================================================
"app_id"
"1411625594"



================================================
FILE: component_config/sample-config/in/tables/test.csv.manifest
================================================
{
    "id": "in.c-test.test",
    "uri": "https:\/\/connection.keboola.com\/v2\/storage\/tables\/in.c-test.test",
    "name": "test",
    "primary_key": [],
    "indexed_columns": [],
    "created": "2018-03-02T15:36:50+0100",
    "last_change_date": "2018-03-02T15:36:54+0100",
    "last_import_date": "2018-03-02T15:36:54+0100",
    "rows_count": 0,
    "data_size_bytes": 0,
    "is_alias": false,
    "attributes": [],
    "columns": [
        "app_id"
    ],
    "metadata": [],
    "column_metadata": {
       "app_id": []
    }
}


================================================
FILE: scripts/build_n_run.ps1
================================================
echo Building component...
$COMP_TAG = Read-Host -Prompt 'Input Docker tag name:'
docker build -rm -t $COMP_TAG ../

echo Running component...
Write-host "Would you like to use default data folder? (../data)" -ForegroundColor Yellow 
    $Readhost = Read-Host " ( y / n ) " 
    Switch ($ReadHost) 
     { 
       Y {Write-host "Yes use: " (join-path (Split-Path -Path (Get-Location).Path) "data"); $DATA_PATH = (join-path (Split-Path -Path (Get-Location).Path) "data") } 
       N {Write-Host "No, I'll specify myself"; $DATA_PATH = Read-Host -Prompt 'Input data folder path:'} 
       Default {Write-Host "Default, run app"; docker run -v $DATA_PATH`:/data -e KBC_DATADIR=/data $COMP_TAG} 
     } 

Write-host "Would you like to execute the container to Bash, skipping the execution?" -ForegroundColor Yellow 
    $Readhost = Read-Host " ( y / n ) " 
    Switch ($ReadHost) 
     { 
       Y {Write-host "Yes, get me to the bash"; docker run -ti -v $DATA_PATH`:/data --entrypoint=//bin//bash $COMP_TAG} 
       N {Write-Host "No, execute the app normally"; 
		    echo $DATA_PATH
			docker run -v $DATA_PATH`:/data -e KBC_DATADIR=/data $COMP_TAG
	   } 
       Default {Write-Host "Default, run app"; docker run -v $DATA_PATH`:/data -e KBC_DATADIR=/data $COMP_TAG} 
     } 





================================================
FILE: scripts/build_n_test.sh
================================================
#!/bin/sh
set -e

flake8 --config=flake8.cfg
python -m unittest discover


================================================
FILE: scripts/run.bat
================================================
@echo off

echo Running component...
docker run -v %cd%:/data -e KBC_DATADIR=/data comp-tag


================================================
FILE: scripts/run.sh
================================================
#!/bin/sh
set -e

python /code/src/component.py


================================================
FILE: scripts/run_kbc_tests.ps1
================================================
echo "Preparing KBC test image"
# set env vars
$KBC_DEVELOPERPORTAL_USERNAME  = Read-Host -Prompt 'Input your service account user name'
$KBC_DEVELOPERPORTAL_PASSWORD  = Read-Host -Prompt 'Input your service account pass'
$KBC_DEVELOPERPORTAL_VENDOR = 'esnerda'
$KBC_DEVELOPERPORTAL_APP = 'esnerda.ex-gusto-export'
$BASE_KBC_CONFIG = '455568423'
$KBC_STORAGE_TOKEN = Read-Host -Prompt 'Input your storage token'


#build app
$APP_IMAGE='keboola-comp-test'
docker build ..\ --tag=$APP_IMAGE
docker images
docker -v
#docker run $APP_IMAGE flake8 --config=./deployment/flake8.cfg
echo "Running unit-tests..."
docker run $APP_IMAGE python -m unittest discover

docker pull quay.io/keboola/developer-portal-cli-v2:latest
$REPOSITORY= docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME=$KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD=$KBC_DEVELOPERPORTAL_PASSWORD quay.io/keboola/developer-portal-cli-v2:latest ecr:get-repository $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP

docker tag $APP_IMAGE`:latest $REPOSITORY`:test

echo 'running login'
$(docker run --rm -e KBC_DEVELOPERPORTAL_USERNAME=$KBC_DEVELOPERPORTAL_USERNAME -e KBC_DEVELOPERPORTAL_PASSWORD=$KBC_DEVELOPERPORTAL_PASSWORD -e KBC_DEVELOPERPORTAL_URL quay.io/keboola/developer-portal-cli-v2:latest ecr:get-login $KBC_DEVELOPERPORTAL_VENDOR $KBC_DEVELOPERPORTAL_APP)

echo 'pushing test image'
docker push $REPOSITORY`:test

echo 'running test config in KBC'
docker run --rm -e KBC_STORAGE_TOKEN=$KBC_STORAGE_TOKEN quay.io/keboola/syrup-cli:latest run-job $KBC_DEVELOPERPORTAL_APP $BASE_KBC_CONFIG test



================================================
FILE: scripts/update_dev_portal_properties.sh
================================================
#!/usr/bin/env bash

set -e
# Obtain the component repository and log in
docker pull quay.io/keboola/developer-portal-cli-v2:latest


# Update properties in Keboola Developer Portal
echo "Updating long description"
value=`cat component_config/component_long_description.md`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} longDescription --value="$value"
else
    echo "longDescription is empty!"
    exit 1
fi

echo "Updating config schema"
value=`cat component_config/configSchema.json`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} configurationSchema --value="$value"
else
    echo "configurationSchema is empty!"
fi


echo "Updating config description"

value=`cat component_config/configuration_description.md`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} configurationDescription --value="$value"
else
    echo "configurationDescription is empty!"
fi


echo "Updating short description"

value=`cat component_config/component_short_description.md`
echo "$value"
if [ ! -z "$value" ]
then
    docker run --rm \
            -e KBC_DEVELOPERPORTAL_USERNAME \
            -e KBC_DEVELOPERPORTAL_PASSWORD \
            quay.io/keboola/developer-portal-cli-v2:latest \
            update-app-property ${KBC_DEVELOPERPORTAL_VENDOR} ${KBC_DEVELOPERPORTAL_APP} shortDescription --value="$value"
else
    echo "shortDescription is empty!"
    exit 1
fi


================================================
FILE: src/component.py
================================================
import csv
import logging
import os
import re
import sys
import lxml.etree
import logging_gelf.handlers
import logging_gelf.formatters
from lib.client import iTunesClient
from lib.app import iTunesObject
from kbc.env_handler import KBCEnvHandler

# Environment setup
sys.tracebacklimit = 0


# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)-8s : [line:%(lineno)3s] %(message)s',
    datefmt="%Y-%m-%d %H:%M:%S")


logger = logging.getLogger()
logging_gelf_handler = logging_gelf.handlers.GELFTCPSocketHandler(
    host=os.getenv('KBC_LOGGER_ADDR'),
    port=int(os.getenv('KBC_LOGGER_PORT'))
    )
logging_gelf_handler.setFormatter(logging_gelf.formatters.GELFFormatter(null_character=True))
logger.addHandler(logging_gelf_handler)

# removes the initial stdout logging
logger.removeHandler(logger.handlers[0])


APP_VERSION = '0.1.0'
KEY_COUNTRY_CODES = 'country_code'
KEY_BACKFILL_MODE = 'backfill_mode'
MANDATORY_PARS = [KEY_COUNTRY_CODES, KEY_BACKFILL_MODE]

ALL_COUNTRY_CODES = ['DZ', 'AO', 'AI', 'AG', 'AR', 'AM', 'AU', 'AT',
                     'AZ', 'BH', 'BD', 'BB', 'BY', 'BE', 'BZ', 'BM',
                     'BO', 'BW', 'BR', 'VG', 'BN', 'BG', 'CA', 'KY',
                     'CL', 'CN', 'CO', 'CR', 'CI', 'HR', 'CY', 'CZ',
                     'DK', 'DM', 'DO', 'EC', 'EG', 'SV', 'EE', 'FI',
                     'FR', 'DE', 'GH', 'GR', 'GD', 'GT', 'GY', 'HN',
                     'HK', 'HU', 'IS', 'IN', 'ID', 'IE', 'IL', 'IT',
                     'JM', 'JP', 'JO', 'KZ', 'KE', 'KR', 'KW', 'LV',
                     'LB', 'LI', 'LT', 'LU', 'MO', 'MK', 'MG', 'MY',
                     'MV', 'ML', 'MT', 'MU', 'MX', 'MD', 'MS', 'NP',
                     'NL', 'NZ', 'NI', 'NE', 'NG', 'NO', 'OM', 'PK',
                     'PA', 'PY', 'PE', 'PH', 'PL', 'PT', 'QA', 'RO',
                     'RU', 'SA', 'SN', 'RS', 'SG', 'SK', 'SI', 'ZA',
                     'ES', 'LK', 'KN', 'LC', 'VC', 'SR', 'SE', 'CH',
                     'TW', 'TZ', 'TH', 'BS', 'TT', 'TN', 'TR', 'TC',
                     'UG', 'GB', 'UA', 'AE', 'UY', 'US', 'UZ', 'VE',
                     'VN', 'YE']

OUT_FIELDS = ['object_id',
              'country_code',
              'review_id',
              'updated',
              'title',
              'content',
              'voteSum',
              'voteCount',
              'rating',
              'author_name',
              'author_uri']


class Component(KBCEnvHandler):

    def __init__(self, ALL_COUNTRY_CODES, OUT_FIELDS):

        KBCEnvHandler.__init__(self, MANDATORY_PARS)

        try:

            self.validate_config()

        except ValueError as e:

            logging.error(e)
            sys.exit(1)

        _cc = self.cfg_params[KEY_COUNTRY_CODES]

        if 'ALL' in _cc:

            self.country_codes = ALL_COUNTRY_CODES

        else:

            self.country_codes = _cc

        self.backfill = self.cfg_params[KEY_BACKFILL_MODE]
        self.client = iTunesClient()

        try:
            self._input_table_path = self.configuration.get_input_tables()[
                0]['full_path']
        except IndexError:

            logging.error("No input table provided.")
            sys.exit(1)

        self._output_table_path = os.path.join(self.tables_out_path, 'reviews.csv')
        self._writer = csv.DictWriter(open(self._output_table_path, 'w+'),
                                      fieldnames=OUT_FIELDS,
                                      delimiter=',',
                                      quotechar='"',
                                      quoting=csv.QUOTE_ALL,
                                      extrasaction='ignore',
                                      restval='')

        self._writer.writeheader()
        self._get_state_file()

    def _get_state_file(self):

        logging.debug("Backfill mode: %s" % str(self.backfill))

        if self.backfill is True:

            self.state = {}
            self.state_out = {}

        else:

            self.state = self.get_state_file()
            self.state_out = self.state

        logging.debug("State for the component run: %s" % str(self.state))

    def _get_first_page(self, itunes_obj):

        object_id = itunes_obj.id
        country = itunes_obj.country
        page_number = 1

        _xml_str = self.client._get_paged_results(
            country, object_id, page_number)

        return _xml_str

    def _build_xml_tree(self, xml_str):

        tree = lxml.etree.ElementTree(lxml.etree.fromstring(xml_str))

        return tree

    def _get_last_page(self, xml_tree):

        root = xml_tree.getroot()
        _last_tag = root.find("{http://www.w3.org/2005/Atom}*[@rel='last']")
        _last_link = _last_tag.attrib.get('href')

        if _last_link == '':

            return None

        else:

            _last_link = _last_link.split('?')[0]
            _rgxp_page = re.search(r'page=\d+', _last_link)

            if _rgxp_page is None:

                return None

            else:

                return _rgxp_page.group(0).split('=')[1]

    def _get_entries(self, xml_tree, state_updated):

        root = xml_tree.getroot()

        entries = root.findall('{http://www.w3.org/2005/Atom}entry')

        _out = []

        _state_reached = False
        for entry in entries:

            _updt = entry.find('{http://www.w3.org/2005/Atom}updated').text
            _id = entry.find('{http://www.w3.org/2005/Atom}id').text
            _title = entry.find('{http://www.w3.org/2005/Atom}title').text.replace('\n', '\\n')
            _content = entry.find('{http://www.w3.org/2005/Atom}content').text.replace('\n', '\\n')
            _voteSum = entry.find('{http://itunes.apple.com/rss}voteSum').text
            _voteCount = entry.find(
                '{http://itunes.apple.com/rss}voteCount').text
            _rtg = entry.find('{http://itunes.apple.com/rss}rating').text
            _author = entry.find('{http://www.w3.org/2005/Atom}author')

            _usr_name = _author.find('{http://www.w3.org/2005/Atom}name').text
            _usr_uri = _author.find('{http://www.w3.org/2005/Atom}uri').text

            if _updt > state_updated:

                _dict = {'review_id': _id,
                         'updated': _updt,
                         'title': _title,
                         'content': _content,
                         'voteSum': _voteSum,
                         'voteCount': _voteCount,
                         'rating': _rtg,
                         'author_name': _usr_name,
                         'author_uri': _usr_uri}

                _out += [_dict]

            else:

                _state_reached = True
                return _out, _state_reached

        return _out, _state_reached

    def run(self):

        with open(self._input_table_path) as _inpt:

            _rdr = csv.reader(_inpt)

            for _row in _rdr:

                if len(_row) != 1:

                    logging.error("Input table must be a single column table")
                    sys.exit(1)

                elif _rdr.line_num == 1:

                    continue

                _app_id = _row[0]
                _app_state = self.state.get(_app_id)
                _app_state = {} if _app_state is None else _app_state
                logging.info("State for application: %s" % str(_app_state))

                for _c_code in self.country_codes:

                    logging.info("Downloading reviews for object id %s from country %s." % (_app_id, _c_code))

                    _country_state = _app_state.get(_c_code)
                    logging.info("State for country: %s" % str(_country_state))

                    it_obj = iTunesObject(_app_id, _c_code, _country_state)
                    _first_page_xml = self._get_first_page(it_obj)
                    _first_page_tree = self._build_xml_tree(_first_page_xml)
                    _last_page = self._get_last_page(_first_page_tree)

                    if _last_page is None:

                        logging.info("No reviews for application %s in country %s" % (it_obj.id, it_obj.country))

                        continue

                    else:

                        it_obj._last_page = _last_page

                    if it_obj.state is None:

                        _state_updt = '1970-01-01T00:00:00-0700'

                    else:

                        _state_updt = it_obj.state

                    logging.debug("Original state: %s" % str(it_obj.state))
                    logging.debug("New state: %s" % str(_state_updt))

                    _app_dict = {'object_id': it_obj.id,
                                 'country_code': it_obj.country}

                    _state_reached = False
                    _max_page = int(it_obj._last_page) + 1
                    _max_updt = None
                    for p in range(1, _max_page):

                        _xml_str = self.client._get_paged_results(it_obj.country, it_obj.id, p)
                        _xml_tree = self._build_xml_tree(_xml_str)
                        _entries, _state_reached = self._get_entries(_xml_tree, _state_updt)

                        if p == 1 and len(_entries) != 0:

                            _max_updt = _entries[0]['updated']

                        for d in _entries:

                            _dict_to_write = {**d, **_app_dict}
                            self._writer.writerow(_dict_to_write)

                        if _state_reached is True:

                            break

                    self.state_out[it_obj.id] = {it_obj.country: _max_updt}

            self.write_state_file(self.state_out)
            self.configuration.write_table_manifest(self._output_table_path,
                                                    incremental=True,
                                                    primary_key=['review_id', 'updated', 'country_code'])


if __name__ == '__main__':

    logging.info("Running extractor version %s." % APP_VERSION)
    c = Component(ALL_COUNTRY_CODES, OUT_FIELDS)
    c.run()



================================================
FILE: src/lib/__init__.py
================================================
[Empty file]


================================================
FILE: src/lib/app.py
================================================
class iTunesObject:

    def __init__(self, itunes_id, country, state):

        self.id = itunes_id
        self.country = country
        self.state = state



================================================
FILE: src/lib/client.py
================================================
import logging
import time
from kbc.client_base import HttpClientBase

BASE_URL = 'https://itunes.apple.com'


class iTunesClient(HttpClientBase):

    def __init__(self):

        HttpClientBase.__init__(self, BASE_URL, auth=None)

    def _get_paged_results(self, country_code, object_id, page_number):

        if page_number > 10:

            logging.warn("Max depth of RSS feed is enforced to 10.")

            return '<feed></feed>'

        url = self.base_url + f'/{country_code}/rss/customerreviews/page={page_number}' + \
            f'/id={object_id}/sortby=mostrecent/xml'

        rsp = self.get_raw(url)

        # Sleep for 3 seconds to ensure no more than 20 calls per minute are made.
        time.sleep(3)

        return rsp.content



================================================
FILE: tests/__init__.py
================================================
[Empty file]


================================================
FILE: tests/test_component.py
================================================
[Empty file]

