Directory structure:
└── keboola-python-utils/
    ├── README.md
    ├── LICENSE
    ├── flake8.cfg
    ├── requirements.txt
    ├── setup.py
    ├── docs/
    │   └── api-html/
    │       └── utils/
    │           ├── char_encoder.html
    │           ├── date.html
    │           ├── header_normalizer.html
    │           ├── helpers.html
    │           └── index.html
    ├── src/
    │   └── keboola/
    │       └── utils/
    │           ├── __init__.py
    │           ├── char_encoder.py
    │           ├── date.py
    │           ├── header_normalizer.py
    │           └── helpers.py
    ├── tests/
    │   ├── __init__.py
    │   ├── test_char_encoder.py
    │   ├── test_date.py
    │   ├── test_header_normalizer.py
    │   └── test_helpers.py
    └── .github/
        └── workflows/
            ├── deploy.yml
            ├── deploy_to_test.yml
            └── push_dev.yml

================================================
File: README.md
================================================
# Python Utility library

## Introduction

![Build & Test](https://github.com/keboola/python-utils/workflows/Build%20&%20Test/badge.svg?branch=main)
[![Code Climate](https://codeclimate.com/github/keboola/python-utils/badges/gpa.svg)](https://codeclimate.com/github/keboola/python-utils)
[![PyPI version](https://badge.fury.io/py/keboola.utils.svg)](https://badge.fury.io/py/keboola.utils)

The library provides a useful set of utility functions frequently used when creating Python components for Keboola Connection. The utility library should be used in cooperation with the main [Python Component](https://github.com/keboola/python-component) library.

The Python Utility library is developed the Keboola Data Services team and is officially supported by Keboola. The library aims to ease the component creation process by removing the necessity to write frequently used functions all over again.

## Links

- API Documentation: [API Docs](https://htmlpreview.github.io/?https://raw.githubusercontent.com/keboola/python-utils/main/docs/api-html/utils/date.html)
- Source code: [https://github.com/keboola/python-utils](https://github.com/keboola/python-utils)
- PYPI project code: [https://pypi.org/project/keboola.utils](https://pypi.org/project/keboola.utils)
- Documentation: [https://developers.keboola.com/extend/component/python-component-library](https://developers.keboola.com/extend/component/python-component-library)

## Quick start

### Installation

The package can be installed via `pip` using:

```
pip install keboola.utils
```

### Structure and functionality

The package currently contains one core module:

- `keboola.utils.date` - a set of methods for date manipulation.
- [`keboola.utils.helpers`](https://htmlpreview.github.io/?https://raw.githubusercontent.com/keboola/python-utils/main/docs/api-html/utils/helpers.html)  
  - a general helper functions and classes that are relevant in Keboola Connection environment.
- [`keboola.utils.header_normalizer`](https://htmlpreview.github.io/?https://raw.githubusercontent.com/keboola/python-utils/main/docs/api-html/utils/header_normalizer.html) 
  - Different strategies to convert column names to a valid KBC format.

### Helpers

The module contains general helper functions and classes that are relevant in Keboola Connection environment.

### Date Utilities

The module contains all date related functions, which can be utilized to effective work with dates, when creating components for Keboola Connection.

#### Initialization

All util functions can be imported from `keboola.utils` module.

```python
from keboola.utils import *
```

or 

```python
import keboola.utils.date
```

to import only functions from a certain module.

#### Getting converted date period from string

The function `parse_datetime_interval()` allows to parse any string containing date format into a Python datetime; or if `strformat` parameter is specified, into a datetime formatted string.

The positional arguments `period_from` and `period_to` can be specified in relative format (e.g. `3 days ago`, `2 months ago`, etc.) or in absolute format (e.g. `2020-01-01`). For full list of supported formats, please refer to [`dateparser` documentation](https://dateparser.readthedocs.io/en/latest/introduction.html#features).

```python
from keboola.utils import *

dt_str_1 = '5 days ago'
dt_str_2 = 'today'
dt_format = '%Y-%m-%d'

start_date, end_date = parse_datetime_interval(dt_str_1, dt_str_2, dt_format)
```

#### Generating date period chunks

The function `split_dates_to_chunks()` allows to split time interval into chunks of specified size.

```python
import keboola.utils.date as dutils
from datetime import date

dt_1 = date(2021, 1, 1)
dt_2 = date(2021, 1, 10)
dt_format = '%Y-%m-%d'

intervals = dutils.split_dates_to_chunks(dt_1, dt_2, intv=2, strformat=dt_format)

for intv in intervals:
    print(intv['start_date'], intv['end_date'])
```

#### Usage Example

```python
import keboola.utils.date as dutils

dt_str_1 = '5 days ago'
dt_str_2 = 'today'
dt_format = '%Y-%m-%d'

start_date, end_date = dutils.parse_datetime_interval(dt_str_1, dt_str_2)

intervals = dutils.split_dates_to_chunks(start_date, end_date, intv=2, strformat=dt_format)

for intv in intervals:
    print(intv['start_date'], intv['end_date'])
```


### Header normalizer

This module provides different strategies to normalize CSV column names
to a format supported by the [Keboola Connection Storage](https://help.keboola.com/):

`Only alphanumeric characters and underscores are allowed in column name.
Underscore is not allowed on the beginning.`


**Example:**

```python
import keboola.utils.header_normalizer as hnorm

head_norm = hnorm.get_normalizer(strategy=hnorm.NormalizerStrategy.ENCODER, char_encoder="unicode")
header = ["dactor#fd", "a*ruas$", "48DHBb#@"]
norm_headers = head_norm.normalize_header(header)
        
# Results in: ['dactor_35_fd', 'a_42_ruas_36_', '48DHBb_35__64_'])

```

## License

MIT licensed, see [LICENSE](./LICENSE) file.


================================================
File: LICENSE
================================================
MIT License

Copyright (c) Keboola :(){:|:&};: s.r.o.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
File: flake8.cfg
================================================
[flake8]
exclude =
    .git,
    __pycache__,
    tests,
    mapping.py,
    __init__.py
max-line-length = 119

# F812: list comprehension redefines ...
# H101: Use TODO(NAME)
# H202: assertRaises Exception too broad
# H233: Python 3.x incompatible use of print operator
# H301: one import per line
# H306: imports not in alphabetical order (time, os)
# H401: docstring should not start with a space
# H403: multi line docstrings should end on a new line
# H404: multi line docstring should start without a leading new line
# H405: multi line docstring summary not separated with an empty line
# H501: Do not use self.__dict__ for string formatting
ignore = F812,H101,H202,H233,H301,H306,H401,H403,H404,H405,H501

================================================
File: requirements.txt
================================================
dateparser
pytz

================================================
File: setup.py
================================================
import setuptools

with open("README.md", "r") as fh:
    long_description = fh.read()

project_urls = {
    'Documentation': 'https://htmlpreview.github.io/?https://raw.githubusercontent.com/keboola/'
                     'python-utils/main/docs/api-html/utils/index.html'
}

setuptools.setup(
    name="keboola.utils",
    version="1.1.0",
    author="Keboola KDS Team",
    project_urls=project_urls,
    setup_requires=['pytest-runner', 'flake8'],
    tests_require=['pytest'],
    install_requires=[
        'dateparser',
        'pytz'
    ],
    author_email="support@keboola.com",
    description="General utility library for Python applications running in Keboola Connection environment",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/keboola/python-utils",
    packages=['keboola.utils'],
    package_dir={'': 'src'},
    include_package_data=True,
    zip_safe=False,
    test_suite='tests',
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Intended Audience :: Developers",
        "Intended Audience :: Information Technology",
        "Intended Audience :: Education",
        "Topic :: Software Development :: Libraries",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Development Status :: 4 - Beta"
    ],
    python_requires='>=3.7'
)


================================================
File: docs/api-html/utils/char_encoder.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>keboola.utils.char_encoder API documentation</title>
<meta name="description" content="Get alphanumerical encoding of characters using different strategies." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>keboola.utils.char_encoder</code></h1>
</header>
<section id="section-intro">
<p>Get alphanumerical encoding of characters using different strategies.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Get alphanumerical encoding of characters using different strategies.

&#34;&#34;&#34;

from typing import Union

from .helpers import ValidatingEnum


class SupportedEncoder(ValidatingEnum):
    unicode = &#34;unicode&#34;
    utf8 = &#34;utf8&#34;


class CharEncoder:
    &#34;&#34;&#34;
    A class used to encode characters

    ...

    Attributes
    ----------
    encoder : fnc
        a function used to encode a character with a specific strategy

    &#34;&#34;&#34;

    def __init__(self, encode_type: Union[SupportedEncoder, str]):
        &#34;&#34;&#34;
        Parameters
        ----------
        encode_type: str
            A string symbolizing a encoding strategy
        &#34;&#34;&#34;

        self.encoder = self._get_encoder(encode_type)

    def encode_char(self, character):
        &#34;&#34;&#34;encodes a character using an encoder function

        Parameters
        ----------
        character : str
            character to be encoded

        Returns
        -------
        an encoded character
        &#34;&#34;&#34;
        return self.encoder(character)

    @staticmethod
    def _get_encoder(encode_type: Union[SupportedEncoder, str]):
        try:
            _type = SupportedEncoder.get_by_name(encode_type)
            if _type == SupportedEncoder.unicode:
                return ord
            elif _type == SupportedEncoder.utf8:
                return CharEncoder.encode_utf8
        except TypeError:
            raise ValueError(f&#34;Encoder type : {encode_type} not supported&#34;)

    @staticmethod
    def encode_utf8(character):
        &#34;&#34;&#34;encodes a character with utf8 encoding

        Parameters
        ----------
        character : str
            character to be encoded

        Returns
        -------
        an encoded character with utf8
        &#34;&#34;&#34;
        return character.encode(&#39;utf8&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="keboola.utils.char_encoder.CharEncoder"><code class="flex name class">
<span>class <span class="ident">CharEncoder</span></span>
<span>(</span><span>encode_type: Union[<a title="keboola.utils.char_encoder.SupportedEncoder" href="#keboola.utils.char_encoder.SupportedEncoder">SupportedEncoder</a>, str])</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to encode characters</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>encoder</code></strong> :&ensp;<code>fnc</code></dt>
<dd>a function used to encode a character with a specific strategy</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>encode_type</code></strong> :&ensp;<code>str</code></dt>
<dd>A string symbolizing a encoding strategy</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CharEncoder:
    &#34;&#34;&#34;
    A class used to encode characters

    ...

    Attributes
    ----------
    encoder : fnc
        a function used to encode a character with a specific strategy

    &#34;&#34;&#34;

    def __init__(self, encode_type: Union[SupportedEncoder, str]):
        &#34;&#34;&#34;
        Parameters
        ----------
        encode_type: str
            A string symbolizing a encoding strategy
        &#34;&#34;&#34;

        self.encoder = self._get_encoder(encode_type)

    def encode_char(self, character):
        &#34;&#34;&#34;encodes a character using an encoder function

        Parameters
        ----------
        character : str
            character to be encoded

        Returns
        -------
        an encoded character
        &#34;&#34;&#34;
        return self.encoder(character)

    @staticmethod
    def _get_encoder(encode_type: Union[SupportedEncoder, str]):
        try:
            _type = SupportedEncoder.get_by_name(encode_type)
            if _type == SupportedEncoder.unicode:
                return ord
            elif _type == SupportedEncoder.utf8:
                return CharEncoder.encode_utf8
        except TypeError:
            raise ValueError(f&#34;Encoder type : {encode_type} not supported&#34;)

    @staticmethod
    def encode_utf8(character):
        &#34;&#34;&#34;encodes a character with utf8 encoding

        Parameters
        ----------
        character : str
            character to be encoded

        Returns
        -------
        an encoded character with utf8
        &#34;&#34;&#34;
        return character.encode(&#39;utf8&#39;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="keboola.utils.char_encoder.CharEncoder.encode_utf8"><code class="name flex">
<span>def <span class="ident">encode_utf8</span></span>(<span>character)</span>
</code></dt>
<dd>
<div class="desc"><p>encodes a character with utf8 encoding</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>character</code></strong> :&ensp;<code>str</code></dt>
<dd>character to be encoded</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>an encoded character with utf8</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode_utf8(character):
    &#34;&#34;&#34;encodes a character with utf8 encoding

    Parameters
    ----------
    character : str
        character to be encoded

    Returns
    -------
    an encoded character with utf8
    &#34;&#34;&#34;
    return character.encode(&#39;utf8&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="keboola.utils.char_encoder.CharEncoder.encode_char"><code class="name flex">
<span>def <span class="ident">encode_char</span></span>(<span>self, character)</span>
</code></dt>
<dd>
<div class="desc"><p>encodes a character using an encoder function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>character</code></strong> :&ensp;<code>str</code></dt>
<dd>character to be encoded</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>an encoded character</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_char(self, character):
    &#34;&#34;&#34;encodes a character using an encoder function

    Parameters
    ----------
    character : str
        character to be encoded

    Returns
    -------
    an encoded character
    &#34;&#34;&#34;
    return self.encoder(character)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="keboola.utils.char_encoder.SupportedEncoder"><code class="flex name class">
<span>class <span class="ident">SupportedEncoder</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SupportedEncoder(ValidatingEnum):
    unicode = &#34;unicode&#34;
    utf8 = &#34;utf8&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="keboola.utils.helpers.ValidatingEnum" href="helpers.html#keboola.utils.helpers.ValidatingEnum">ValidatingEnum</a></li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="keboola.utils.char_encoder.SupportedEncoder.unicode"><code class="name">var <span class="ident">unicode</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="keboola.utils.char_encoder.SupportedEncoder.utf8"><code class="name">var <span class="ident">utf8</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="keboola.utils" href="index.html">keboola.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="keboola.utils.char_encoder.CharEncoder" href="#keboola.utils.char_encoder.CharEncoder">CharEncoder</a></code></h4>
<ul class="">
<li><code><a title="keboola.utils.char_encoder.CharEncoder.encode_char" href="#keboola.utils.char_encoder.CharEncoder.encode_char">encode_char</a></code></li>
<li><code><a title="keboola.utils.char_encoder.CharEncoder.encode_utf8" href="#keboola.utils.char_encoder.CharEncoder.encode_utf8">encode_utf8</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="keboola.utils.char_encoder.SupportedEncoder" href="#keboola.utils.char_encoder.SupportedEncoder">SupportedEncoder</a></code></h4>
<ul class="">
<li><code><a title="keboola.utils.char_encoder.SupportedEncoder.unicode" href="#keboola.utils.char_encoder.SupportedEncoder.unicode">unicode</a></code></li>
<li><code><a title="keboola.utils.char_encoder.SupportedEncoder.utf8" href="#keboola.utils.char_encoder.SupportedEncoder.utf8">utf8</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: docs/api-html/utils/date.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>keboola.utils.date API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>keboola.utils.date</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
from _datetime import timedelta
from datetime import datetime
from typing import Tuple, Generator, Union, Dict, List

import dateparser
import pytz
from dateutil.relativedelta import relativedelta

date_tuple = Union[Tuple[datetime, datetime], Tuple[str, str]]
date_gen = Generator[Dict[str, datetime], None, None]
date_chunk = Union[date_gen, List]


def parse_datetime_interval(period_from: str, period_to: str, strformat: str = None) -&gt; date_tuple:
    &#34;&#34;&#34;
    Returns given period parameters in datetime format, or next step in back-fill mode
    along with generated last state for next iteration.

    Args:
        period_from: YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago
        period_to: YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago
        strformat: A python strtime format, in which output dates will be returned. If not specified
                    function returns dates in datetime.datetime type

    Returns:
        start_date: datetime, end_date: datetime
    &#34;&#34;&#34;

    start_date_form = dateparser.parse(period_from)
    end_date_form = dateparser.parse(period_to)
    day_diff = (end_date_form - start_date_form).days
    if day_diff &lt; 0:
        raise ValueError(&#34;start_date cannot exceed end_date.&#34;)

    if strformat is None:
        return start_date_form, end_date_form
    else:
        return start_date_form.strftime(strformat), end_date_form.strftime(strformat)


def get_past_date(str_days_ago: str, to_date: datetime = None,
                  tz: pytz.tzinfo = pytz.utc) -&gt; object:
    &#34;&#34;&#34;
    Returns date in specified timezone relative to to_date parameter.

    e.g.
    &#39;5 hours ago&#39;,
    &#39;yesterday&#39;,
    &#39;3 days ago&#39;,
    &#39;4 months ago&#39;,
    &#39;2 years ago&#39;,
    &#39;today&#39;

    Args:
        str_days_ago: A string specifying some kind of date, in relative or absolute format
        to_date: A date, from which the relative date will be calculated. Default: today&#39;s date
        tz: A timezone specifier of type pytz.tzinfo

    Returns:
        date: datetime
    &#34;&#34;&#34;

    today_date = datetime.now(tz)
    if not to_date:
        to_date = today_date

    # add timezone awareness to allow date subtraction
    to_date = add_timezone_info(to_date, tz)

    try:
        today_diff = (today_date - to_date).days
        past_date = dateparser.parse(str_days_ago)
        past_date = past_date.replace(tzinfo=tz)
        date = past_date - relativedelta(days=today_diff)
        return date
    except TypeError as e:
        raise ValueError(
            f&#34;Please enter valid date parameters. Some of the values ({str_days_ago}, {str(to_date)}) are &#34;
            f&#34;not in supported format. Raised: {e}&#34;)


def add_timezone_info(to_date: datetime, tz: pytz.tzinfo = pytz.utc) -&gt; datetime:
    &#34;&#34;&#34;
    Add timezone info if not present. Useful when making sure the datetime instances are offset-aware to allow
    date subtracting.
    Args:
        to_date: datetime
        tz: timezone

    Returns: datetime object with updated timezone info

    &#34;&#34;&#34;
    if to_date.tzinfo is None:
        to_date = to_date.replace(tzinfo=tz)

    return to_date


def split_dates_to_chunks(start_date: datetime, end_date: datetime, intv: int,
                          strformat: str = &#34;%Y-%m-%d&#34;, generator: bool = False) -&gt; date_chunk:
    &#34;&#34;&#34;
    Splits dates in given period into chunks of specified max size.

    Args:
        start_date: Start date, from which periods will be calculated
        end_date: End date, to which periods will be calculated
        intv: Size of interval in days
        strformat: A strftime format string

    Returns:
        list

    Usage example:
    list(split_dates_to_chunks(&#34;2018-01-01&#34;, &#34;2018-01-04&#34;, 2, &#34;%Y-%m-%d&#34;))

        returns [{start_date: &#34;2018-01-01&#34;, &#34;end_date&#34;:&#34;2018-01-02&#34;}
                 {start_date: &#34;2018-01-02&#34;, &#34;end_date&#34;:&#34;2018-01-04&#34;}]
    &#34;&#34;&#34;

    def split_dates_to_chunks_gen(start_date, end_date, intv, strformat):

        nr_days = (end_date - start_date).days

        if nr_days &lt;= intv:
            yield {&#39;start_date&#39;: start_date.strftime(strformat),
                   &#39;end_date&#39;: end_date.strftime(strformat)}
        elif intv == 0:
            diff = timedelta(days=1)
            for i in range(nr_days):
                yield {&#39;start_date&#39;: (start_date + diff * i).strftime(strformat),
                       &#39;end_date&#39;: (start_date + diff * i).strftime(strformat)}
        else:
            nr_parts = math.ceil(nr_days / intv)
            diff = (end_date - start_date) / nr_parts
            for i in range(nr_parts):
                yield {&#39;start_date&#39;: (start_date + diff * i).strftime(strformat),
                       &#39;end_date&#39;: (start_date + diff * (i + 1)).strftime(strformat)}

    _gen = split_dates_to_chunks_gen(start_date, end_date, intv, strformat)

    if generator is True:
        return _gen
    else:
        return list(_gen)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="keboola.utils.date.add_timezone_info"><code class="name flex">
<span>def <span class="ident">add_timezone_info</span></span>(<span>to_date: datetime.datetime, tz: <module 'pytz.tzinfo' from 'c:\\users\\esner\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pytz\\tzinfo.py'> = &lt;UTC&gt;) ‑> datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Add timezone info if not present. Useful when making sure the datetime instances are offset-aware to allow
date subtracting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to_date</code></strong></dt>
<dd>datetime</dd>
<dt><strong><code>tz</code></strong></dt>
<dd>timezone</dd>
</dl>
<p>Returns: datetime object with updated timezone info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_timezone_info(to_date: datetime, tz: pytz.tzinfo = pytz.utc) -&gt; datetime:
    &#34;&#34;&#34;
    Add timezone info if not present. Useful when making sure the datetime instances are offset-aware to allow
    date subtracting.
    Args:
        to_date: datetime
        tz: timezone

    Returns: datetime object with updated timezone info

    &#34;&#34;&#34;
    if to_date.tzinfo is None:
        to_date = to_date.replace(tzinfo=tz)

    return to_date</code></pre>
</details>
</dd>
<dt id="keboola.utils.date.get_past_date"><code class="name flex">
<span>def <span class="ident">get_past_date</span></span>(<span>str_days_ago: str, to_date: datetime.datetime = None, tz: <module 'pytz.tzinfo' from 'c:\\users\\esner\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pytz\\tzinfo.py'> = &lt;UTC&gt;) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Returns date in specified timezone relative to to_date parameter.</p>
<p>e.g.
'5 hours ago',
'yesterday',
'3 days ago',
'4 months ago',
'2 years ago',
'today'</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>str_days_ago</code></strong></dt>
<dd>A string specifying some kind of date, in relative or absolute format</dd>
<dt><strong><code>to_date</code></strong></dt>
<dd>A date, from which the relative date will be calculated. Default: today's date</dd>
<dt><strong><code>tz</code></strong></dt>
<dd>A timezone specifier of type pytz.tzinfo</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>date</code></dt>
<dd>datetime</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_past_date(str_days_ago: str, to_date: datetime = None,
                  tz: pytz.tzinfo = pytz.utc) -&gt; object:
    &#34;&#34;&#34;
    Returns date in specified timezone relative to to_date parameter.

    e.g.
    &#39;5 hours ago&#39;,
    &#39;yesterday&#39;,
    &#39;3 days ago&#39;,
    &#39;4 months ago&#39;,
    &#39;2 years ago&#39;,
    &#39;today&#39;

    Args:
        str_days_ago: A string specifying some kind of date, in relative or absolute format
        to_date: A date, from which the relative date will be calculated. Default: today&#39;s date
        tz: A timezone specifier of type pytz.tzinfo

    Returns:
        date: datetime
    &#34;&#34;&#34;

    today_date = datetime.now(tz)
    if not to_date:
        to_date = today_date

    # add timezone awareness to allow date subtraction
    to_date = add_timezone_info(to_date, tz)

    try:
        today_diff = (today_date - to_date).days
        past_date = dateparser.parse(str_days_ago)
        past_date = past_date.replace(tzinfo=tz)
        date = past_date - relativedelta(days=today_diff)
        return date
    except TypeError as e:
        raise ValueError(
            f&#34;Please enter valid date parameters. Some of the values ({str_days_ago}, {str(to_date)}) are &#34;
            f&#34;not in supported format. Raised: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="keboola.utils.date.parse_datetime_interval"><code class="name flex">
<span>def <span class="ident">parse_datetime_interval</span></span>(<span>period_from: str, period_to: str, strformat: str = None) ‑> Union[Tuple[datetime.datetime, datetime.datetime], Tuple[str, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns given period parameters in datetime format, or next step in back-fill mode
along with generated last state for next iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period_from</code></strong></dt>
<dd>YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago</dd>
<dt><strong><code>period_to</code></strong></dt>
<dd>YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago</dd>
<dt><strong><code>strformat</code></strong></dt>
<dd>A python strtime format, in which output dates will be returned. If not specified
function returns dates in datetime.datetime type</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>start_date</code></dt>
<dd>datetime, end_date: datetime</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_datetime_interval(period_from: str, period_to: str, strformat: str = None) -&gt; date_tuple:
    &#34;&#34;&#34;
    Returns given period parameters in datetime format, or next step in back-fill mode
    along with generated last state for next iteration.

    Args:
        period_from: YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago
        period_to: YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago
        strformat: A python strtime format, in which output dates will be returned. If not specified
                    function returns dates in datetime.datetime type

    Returns:
        start_date: datetime, end_date: datetime
    &#34;&#34;&#34;

    start_date_form = dateparser.parse(period_from)
    end_date_form = dateparser.parse(period_to)
    day_diff = (end_date_form - start_date_form).days
    if day_diff &lt; 0:
        raise ValueError(&#34;start_date cannot exceed end_date.&#34;)

    if strformat is None:
        return start_date_form, end_date_form
    else:
        return start_date_form.strftime(strformat), end_date_form.strftime(strformat)</code></pre>
</details>
</dd>
<dt id="keboola.utils.date.split_dates_to_chunks"><code class="name flex">
<span>def <span class="ident">split_dates_to_chunks</span></span>(<span>start_date: datetime.datetime, end_date: datetime.datetime, intv: int, strformat: str = '%Y-%m-%d', generator: bool = False) ‑> Union[Generator[Dict[str, datetime.datetime], NoneType, NoneType], List]</span>
</code></dt>
<dd>
<div class="desc"><p>Splits dates in given period into chunks of specified max size.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_date</code></strong></dt>
<dd>Start date, from which periods will be calculated</dd>
<dt><strong><code>end_date</code></strong></dt>
<dd>End date, to which periods will be calculated</dd>
<dt><strong><code>intv</code></strong></dt>
<dd>Size of interval in days</dd>
<dt><strong><code>strformat</code></strong></dt>
<dd>A strftime format string</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list
Usage example:
list(split_dates_to_chunks("2018-01-01", "2018-01-04", 2, "%Y-%m-%d"))</p>
<pre><code>returns [{start_date: "2018-01-01", "end_date":"2018-01-02"}
         {start_date: "2018-01-02", "end_date":"2018-01-04"}]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_dates_to_chunks(start_date: datetime, end_date: datetime, intv: int,
                          strformat: str = &#34;%Y-%m-%d&#34;, generator: bool = False) -&gt; date_chunk:
    &#34;&#34;&#34;
    Splits dates in given period into chunks of specified max size.

    Args:
        start_date: Start date, from which periods will be calculated
        end_date: End date, to which periods will be calculated
        intv: Size of interval in days
        strformat: A strftime format string

    Returns:
        list

    Usage example:
    list(split_dates_to_chunks(&#34;2018-01-01&#34;, &#34;2018-01-04&#34;, 2, &#34;%Y-%m-%d&#34;))

        returns [{start_date: &#34;2018-01-01&#34;, &#34;end_date&#34;:&#34;2018-01-02&#34;}
                 {start_date: &#34;2018-01-02&#34;, &#34;end_date&#34;:&#34;2018-01-04&#34;}]
    &#34;&#34;&#34;

    def split_dates_to_chunks_gen(start_date, end_date, intv, strformat):

        nr_days = (end_date - start_date).days

        if nr_days &lt;= intv:
            yield {&#39;start_date&#39;: start_date.strftime(strformat),
                   &#39;end_date&#39;: end_date.strftime(strformat)}
        elif intv == 0:
            diff = timedelta(days=1)
            for i in range(nr_days):
                yield {&#39;start_date&#39;: (start_date + diff * i).strftime(strformat),
                       &#39;end_date&#39;: (start_date + diff * i).strftime(strformat)}
        else:
            nr_parts = math.ceil(nr_days / intv)
            diff = (end_date - start_date) / nr_parts
            for i in range(nr_parts):
                yield {&#39;start_date&#39;: (start_date + diff * i).strftime(strformat),
                       &#39;end_date&#39;: (start_date + diff * (i + 1)).strftime(strformat)}

    _gen = split_dates_to_chunks_gen(start_date, end_date, intv, strformat)

    if generator is True:
        return _gen
    else:
        return list(_gen)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="keboola.utils" href="index.html">keboola.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="keboola.utils.date.add_timezone_info" href="#keboola.utils.date.add_timezone_info">add_timezone_info</a></code></li>
<li><code><a title="keboola.utils.date.get_past_date" href="#keboola.utils.date.get_past_date">get_past_date</a></code></li>
<li><code><a title="keboola.utils.date.parse_datetime_interval" href="#keboola.utils.date.parse_datetime_interval">parse_datetime_interval</a></code></li>
<li><code><a title="keboola.utils.date.split_dates_to_chunks" href="#keboola.utils.date.split_dates_to_chunks">split_dates_to_chunks</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: docs/api-html/utils/header_normalizer.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>keboola.utils.header_normalizer API documentation</title>
<meta name="description" content="This module provides different strategies to normalize CSV column names
to a format supported by the [Keboola Connection …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>keboola.utils.header_normalizer</code></h1>
</header>
<section id="section-intro">
<p>This module provides different strategies to normalize CSV column names
to a format supported by the <a href="https://help.keboola.com/">Keboola Connection Storage</a>:</p>
<p><code>Only alphanumeric characters and underscores are allowed in column name.
Underscore is not allowed on the beginning.</code></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides different strategies to normalize CSV column names
to a format supported by the [Keboola Connection Storage](https://help.keboola.com/):

`Only alphanumeric characters and underscores are allowed in column name.
Underscore is not allowed on the beginning.`

&#34;&#34;&#34;

import re
import string
from abc import ABC, abstractmethod
from enum import Enum
from typing import List, Tuple, Union

from .char_encoder import CharEncoder, SupportedEncoder

PERMITTED_CHARS = string.digits + string.ascii_letters + &#39;_&#39;

DEFAULT_WHITESPACE_SUB = &#34;_&#34;
DEFAULT_NON_PERMITTED_SUB = &#34;&#34;
DEFAULT_ENCODE_DELIM = &#34;_&#34;
DEFAULT_ENCODER = SupportedEncoder.unicode


class HeaderNormalizer(ABC):
    &#34;&#34;&#34;
    Abstract class for column normalization.

    &#34;&#34;&#34;

    def __init__(self, permitted_chars: str = PERMITTED_CHARS, whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            permitted_chars: all characters that are permitted to be in a column concatenated together in one string
            whitespace_sub: character to substitute a whitespace
        &#34;&#34;&#34;

        self.permitted_chars = permitted_chars
        self.whitespace_sub = whitespace_sub
        self._check_chars_permitted(self.whitespace_sub)

    @abstractmethod
    def _normalize_column_name(self, column_name: str):
        pass

    def _check_chars_permitted(self, in_string: str):
        &#34;&#34;&#34;
        Checks whether characters of a string are within a permitted characters string

        Args:
            in_string: Input string

        Returns:

        Raises:
            ValueError
                If string contains characters that are not permitted

        &#34;&#34;&#34;

        for char in in_string:
            if char not in self.permitted_chars:
                raise ValueError(f&#34;Substitute: &#39;{in_string}&#39; not in permitted characters&#34;)

    def _replace_whitespace(self, in_string: str) -&gt; str:
        &#34;&#34;&#34;
        Replaces whitespaces with a substitute character
        Args:
            in_string:

        Returns:
            in_string : str
                A string with replaced whitespaces by a substitute character

        &#34;&#34;&#34;
        in_string = self.whitespace_sub.join(in_string.split())
        return in_string

    def normalize_header(self, header: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;
        Normalizes a list of columns to match the Keboola Connection Storage requirements:

        `Only alphanumeric characters and underscores are allowed in column name.
         Underscore is not allowed on the beginning.`

        It also checks for empty headers and adds a name to them so they do not remain empty

        Args:
            header:

        Returns:
            Normalized column.

        &#34;&#34;&#34;

        normalized_header = []
        empty_column_id = 1

        for column in header:
            column = self._normalize_column_name(column)
            column, empty_column_id = self._check_empty_column(column, empty_column_id)
            normalized_header.append(column)
        return normalized_header

    @staticmethod
    def _check_empty_column(column: str, empty_column_id: int) -&gt; Tuple[str, int]:
        &#34;&#34;&#34;
        Checks if header is empty and fills it in

        Headers are checked if the string is empty, and if it is a new name is given.
        If the header contains more than 0 characters it will be returned.
        Each new name is appended a number, this number is increased and return as well if the
        header is empty.

        Args:
            column:
            empty_column_id: An integer contaning a number to be appended to the new name of an empty header

        Returns:
            column (str): The new name of an empty column
            empty_header_id (int) : An integer holding the id of the next empty column string

        &#34;&#34;&#34;

        if not column:
            column = f&#34;empty_{str(empty_column_id)}&#34;
            empty_column_id += 1
        return column, empty_column_id


class DefaultHeaderNormalizer(HeaderNormalizer):
    &#34;&#34;&#34;
        A class used to normalize headers using a substitute character
    &#34;&#34;&#34;

    def __init__(self, permitted_chars: str = PERMITTED_CHARS, forbidden_sub: str = DEFAULT_NON_PERMITTED_SUB,
                 whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            permitted_chars: all characters that are permitted to be in a column concatenated together in one string
            forbidden_sub: substitute character for a forbidden character
            whitespace_sub: character to substitute a whitespace
        &#34;&#34;&#34;

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self._check_chars_permitted(forbidden_sub)
        self.forbidden_sub = forbidden_sub

    def _normalize_column_name(self, header: str) -&gt; str:
        header = self._replace_whitespace(header)
        header = self._replace_forbidden(header)
        return header

    def _replace_forbidden(self, in_string: str) -&gt; str:
        &#34;&#34;&#34;
        Replaces forbidden characters in a string by a substitute character

        Args:
            in_string:
        Returns:
            str - fixed name

        &#34;&#34;&#34;

        in_string = re.sub(&#34;[^&#34; + self.permitted_chars + &#34;]&#34;, self.forbidden_sub, in_string)
        return in_string


class EncoderHeaderNormalizer(HeaderNormalizer):
    &#34;&#34;&#34;
    Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
    to the original values. e.g. `a#` -&gt; `a_35_`


    &#34;&#34;&#34;

    def __init__(self, char_encoder: Union[SupportedEncoder, str] = DEFAULT_ENCODER,
                 encode_delimiter: str = DEFAULT_ENCODE_DELIM,
                 permitted_chars: str = PERMITTED_CHARS, whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            permitted_chars:
            char_encoder: type of encoder to be used for encoding forbidden characters
            encode_delimiter : str - character to put before and after an encoded character
            whitespace_sub : str - character to substitute a whitespace
        &#34;&#34;&#34;

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self.encode_delimiter = encode_delimiter
        self.char_encoder = CharEncoder(char_encoder)

    def _normalize_column_name(self, column_name: str) -&gt; str:

        new_column_name = self._replace_whitespace(column_name)
        new_column_name = self._encode_non_permitted_chars(new_column_name)
        return new_column_name

    def _encode_non_permitted_chars(self, in_string: str) -&gt; str:

        column_characters = list(in_string)
        for i, char in enumerate(column_characters):
            if char not in self.permitted_chars:
                column_characters[i] = self.encode_delimiter + str(
                    self.char_encoder.encode_char(char)) + self.encode_delimiter
        return &#34;&#34;.join(column_characters)


class DictHeaderNormalizer(HeaderNormalizer):
    &#34;&#34;&#34;&#34;
        A class used to normalize headers using a dictionary to replace characters.
     e.g. `{&#34;#&#34;:&#34;hsh&#34;}`
    &#34;&#34;&#34;

    def __init__(self, replace_dict: dict, permitted_chars: str = PERMITTED_CHARS,
                 whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            replace_dict: The dictionary contains a key representing the character to be replaced and a value which
                is used to replace the key character.
            permitted_chars:
            whitespace_sub:
        &#34;&#34;&#34;

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self.replace_dict = replace_dict
        self._check_dict_permitted(replace_dict)

    def _normalize_column_name(self, column_name: str) -&gt; str:

        new_column_name = self.replace_chars_using_dict(column_name, self.replace_dict)
        return new_column_name

    @staticmethod
    def _replace_chars_using_dict(in_string: str, replace_dict: dict) -&gt; str:
        &#34;&#34;&#34;
        Replaces characters in a string using a dictionary

        Args:
            in_string : str
                A string containing characters to be replaced using a dictionary
            replace_dict : dict
                A dictionary where keys are characters to be substituted by their specific values

        Returns:

        &#34;&#34;&#34;

        for key in replace_dict:
            in_string = in_string.replace(key, replace_dict[key])
        return in_string

    def _check_dict_permitted(self, in_dict: dict):
        &#34;&#34;&#34;
        Checks whether characters of strings in a dictionary are within a permitted characters string

        &#34;&#34;&#34;
        for key in in_dict:
            self._check_chars_permitted(in_dict[key])


class NormalizerStrategy(Enum):
    &#34;&#34;&#34;&#34;
        Enumerator for column normalization strategies

        ...

        NormalizerStrategy
        ----------
        DEFAULT :
            Normalize headers using a substitute character
        ENCODER :
            Normalize headers using a character encoder
        DICT :
            Normalize headers using a dictionary to replace characters
        &#34;&#34;&#34;
    DEFAULT = &#34;DEFAULT&#34;
    ENCODER = &#34;ENCODER&#34;
    DICT = &#34;DICT&#34;


def get_normalizer(strategy: NormalizerStrategy, **params) -&gt; HeaderNormalizer:
    &#34;&#34;&#34;

    Factory method to initialize a column normalizer with various strategies:

        DEFAULT :
            Normalize headers using a substitute character

        ENCODER :
            Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
             to the original values. e.g. `a#` -&gt; `a_35_`

                 params:
                    `char_encoder: SupportedEncoder = DEFAULT_ENCODER, encode_delimiter: str = DEFAULT_ENCODE_DELIM`
        DICT :
            Specify a dictionary with character replacements. e.g. {&#34;#&#34;:&#34;hsh&#34;}

                params:
                `replace_dict`
    Args:
        strategy:
        **params:

    Returns: HeaderNormalizer

    &#34;&#34;&#34;

    if strategy == NormalizerStrategy.DEFAULT:
        return DefaultHeaderNormalizer(**params)

    elif strategy == NormalizerStrategy.ENCODER:
        return EncoderHeaderNormalizer(**params)

    elif strategy == NormalizerStrategy.DICT:
        return DictHeaderNormalizer(**params)
    else:
        raise ValueError(f&#34;Strategy &#39;{strategy}&#39; is not supported&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="keboola.utils.header_normalizer.get_normalizer"><code class="name flex">
<span>def <span class="ident">get_normalizer</span></span>(<span>strategy: <a title="keboola.utils.header_normalizer.NormalizerStrategy" href="#keboola.utils.header_normalizer.NormalizerStrategy">NormalizerStrategy</a>, **params) ‑> <a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Factory method to initialize a column normalizer with various strategies:</p>
<pre><code>DEFAULT :
    Normalize headers using a substitute character

ENCODER :
    Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
     to the original values. e.g. `a#` -&gt; &lt;code&gt;a\_35\_&lt;/code&gt;

         params:
            `char_encoder: SupportedEncoder = DEFAULT_ENCODER, encode_delimiter: str = DEFAULT_ENCODE_DELIM`
DICT :
    Specify a dictionary with character replacements. e.g. {"#":"hsh"}

        params:
        &lt;code&gt;replace\_dict&lt;/code&gt;
</code></pre>
<h2 id="args">Args</h2>
<p>strategy:
**params:
Returns: HeaderNormalizer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_normalizer(strategy: NormalizerStrategy, **params) -&gt; HeaderNormalizer:
    &#34;&#34;&#34;

    Factory method to initialize a column normalizer with various strategies:

        DEFAULT :
            Normalize headers using a substitute character

        ENCODER :
            Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
             to the original values. e.g. `a#` -&gt; `a_35_`

                 params:
                    `char_encoder: SupportedEncoder = DEFAULT_ENCODER, encode_delimiter: str = DEFAULT_ENCODE_DELIM`
        DICT :
            Specify a dictionary with character replacements. e.g. {&#34;#&#34;:&#34;hsh&#34;}

                params:
                `replace_dict`
    Args:
        strategy:
        **params:

    Returns: HeaderNormalizer

    &#34;&#34;&#34;

    if strategy == NormalizerStrategy.DEFAULT:
        return DefaultHeaderNormalizer(**params)

    elif strategy == NormalizerStrategy.ENCODER:
        return EncoderHeaderNormalizer(**params)

    elif strategy == NormalizerStrategy.DICT:
        return DictHeaderNormalizer(**params)
    else:
        raise ValueError(f&#34;Strategy &#39;{strategy}&#39; is not supported&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="keboola.utils.header_normalizer.DefaultHeaderNormalizer"><code class="flex name class">
<span>class <span class="ident">DefaultHeaderNormalizer</span></span>
<span>(</span><span>permitted_chars: str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', forbidden_sub: str = '', whitespace_sub: str = '_')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to normalize headers using a substitute character</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>permitted_chars</code></strong></dt>
<dd>all characters that are permitted to be in a column concatenated together in one string</dd>
<dt><strong><code>forbidden_sub</code></strong></dt>
<dd>substitute character for a forbidden character</dd>
<dt><strong><code>whitespace_sub</code></strong></dt>
<dd>character to substitute a whitespace</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultHeaderNormalizer(HeaderNormalizer):
    &#34;&#34;&#34;
        A class used to normalize headers using a substitute character
    &#34;&#34;&#34;

    def __init__(self, permitted_chars: str = PERMITTED_CHARS, forbidden_sub: str = DEFAULT_NON_PERMITTED_SUB,
                 whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            permitted_chars: all characters that are permitted to be in a column concatenated together in one string
            forbidden_sub: substitute character for a forbidden character
            whitespace_sub: character to substitute a whitespace
        &#34;&#34;&#34;

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self._check_chars_permitted(forbidden_sub)
        self.forbidden_sub = forbidden_sub

    def _normalize_column_name(self, header: str) -&gt; str:
        header = self._replace_whitespace(header)
        header = self._replace_forbidden(header)
        return header

    def _replace_forbidden(self, in_string: str) -&gt; str:
        &#34;&#34;&#34;
        Replaces forbidden characters in a string by a substitute character

        Args:
            in_string:
        Returns:
            str - fixed name

        &#34;&#34;&#34;

        in_string = re.sub(&#34;[^&#34; + self.permitted_chars + &#34;]&#34;, self.forbidden_sub, in_string)
        return in_string</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></b></code>:
<ul class="hlist">
<li><code><a title="keboola.utils.header_normalizer.HeaderNormalizer.normalize_header" href="#keboola.utils.header_normalizer.HeaderNormalizer.normalize_header">normalize_header</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="keboola.utils.header_normalizer.DictHeaderNormalizer"><code class="flex name class">
<span>class <span class="ident">DictHeaderNormalizer</span></span>
<span>(</span><span>replace_dict: dict, permitted_chars: str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', whitespace_sub: str = '_')</span>
</code></dt>
<dd>
<div class="desc"><p>"
A class used to normalize headers using a dictionary to replace characters.
e.g. <code>{"#":"hsh"}</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>replace_dict</code></strong></dt>
<dd>The dictionary contains a key representing the character to be replaced and a value which
is used to replace the key character.</dd>
</dl>
<p>permitted_chars:
whitespace_sub:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictHeaderNormalizer(HeaderNormalizer):
    &#34;&#34;&#34;&#34;
        A class used to normalize headers using a dictionary to replace characters.
     e.g. `{&#34;#&#34;:&#34;hsh&#34;}`
    &#34;&#34;&#34;

    def __init__(self, replace_dict: dict, permitted_chars: str = PERMITTED_CHARS,
                 whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            replace_dict: The dictionary contains a key representing the character to be replaced and a value which
                is used to replace the key character.
            permitted_chars:
            whitespace_sub:
        &#34;&#34;&#34;

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self.replace_dict = replace_dict
        self._check_dict_permitted(replace_dict)

    def _normalize_column_name(self, column_name: str) -&gt; str:

        new_column_name = self.replace_chars_using_dict(column_name, self.replace_dict)
        return new_column_name

    @staticmethod
    def _replace_chars_using_dict(in_string: str, replace_dict: dict) -&gt; str:
        &#34;&#34;&#34;
        Replaces characters in a string using a dictionary

        Args:
            in_string : str
                A string containing characters to be replaced using a dictionary
            replace_dict : dict
                A dictionary where keys are characters to be substituted by their specific values

        Returns:

        &#34;&#34;&#34;

        for key in replace_dict:
            in_string = in_string.replace(key, replace_dict[key])
        return in_string

    def _check_dict_permitted(self, in_dict: dict):
        &#34;&#34;&#34;
        Checks whether characters of strings in a dictionary are within a permitted characters string

        &#34;&#34;&#34;
        for key in in_dict:
            self._check_chars_permitted(in_dict[key])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></b></code>:
<ul class="hlist">
<li><code><a title="keboola.utils.header_normalizer.HeaderNormalizer.normalize_header" href="#keboola.utils.header_normalizer.HeaderNormalizer.normalize_header">normalize_header</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="keboola.utils.header_normalizer.EncoderHeaderNormalizer"><code class="flex name class">
<span>class <span class="ident">EncoderHeaderNormalizer</span></span>
<span>(</span><span>char_encoder: Union[<a title="keboola.utils.char_encoder.SupportedEncoder" href="char_encoder.html#keboola.utils.char_encoder.SupportedEncoder">SupportedEncoder</a>, str] = SupportedEncoder.unicode, encode_delimiter: str = '_', permitted_chars: str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', whitespace_sub: str = '_')</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
to the original values. e.g. <code>a#</code> -&gt; <code>a_35_</code></p>
<h2 id="args">Args</h2>
<dl>
<dt>permitted_chars:</dt>
<dt><strong><code>char_encoder</code></strong></dt>
<dd>type of encoder to be used for encoding forbidden characters</dd>
</dl>
<p>encode_delimiter : str - character to put before and after an encoded character
whitespace_sub : str - character to substitute a whitespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EncoderHeaderNormalizer(HeaderNormalizer):
    &#34;&#34;&#34;
    Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
    to the original values. e.g. `a#` -&gt; `a_35_`


    &#34;&#34;&#34;

    def __init__(self, char_encoder: Union[SupportedEncoder, str] = DEFAULT_ENCODER,
                 encode_delimiter: str = DEFAULT_ENCODE_DELIM,
                 permitted_chars: str = PERMITTED_CHARS, whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            permitted_chars:
            char_encoder: type of encoder to be used for encoding forbidden characters
            encode_delimiter : str - character to put before and after an encoded character
            whitespace_sub : str - character to substitute a whitespace
        &#34;&#34;&#34;

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self.encode_delimiter = encode_delimiter
        self.char_encoder = CharEncoder(char_encoder)

    def _normalize_column_name(self, column_name: str) -&gt; str:

        new_column_name = self._replace_whitespace(column_name)
        new_column_name = self._encode_non_permitted_chars(new_column_name)
        return new_column_name

    def _encode_non_permitted_chars(self, in_string: str) -&gt; str:

        column_characters = list(in_string)
        for i, char in enumerate(column_characters):
            if char not in self.permitted_chars:
                column_characters[i] = self.encode_delimiter + str(
                    self.char_encoder.encode_char(char)) + self.encode_delimiter
        return &#34;&#34;.join(column_characters)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></b></code>:
<ul class="hlist">
<li><code><a title="keboola.utils.header_normalizer.HeaderNormalizer.normalize_header" href="#keboola.utils.header_normalizer.HeaderNormalizer.normalize_header">normalize_header</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="keboola.utils.header_normalizer.HeaderNormalizer"><code class="flex name class">
<span>class <span class="ident">HeaderNormalizer</span></span>
<span>(</span><span>permitted_chars: str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', whitespace_sub: str = '_')</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for column normalization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>permitted_chars</code></strong></dt>
<dd>all characters that are permitted to be in a column concatenated together in one string</dd>
<dt><strong><code>whitespace_sub</code></strong></dt>
<dd>character to substitute a whitespace</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderNormalizer(ABC):
    &#34;&#34;&#34;
    Abstract class for column normalization.

    &#34;&#34;&#34;

    def __init__(self, permitted_chars: str = PERMITTED_CHARS, whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        &#34;&#34;&#34;

        Args:
            permitted_chars: all characters that are permitted to be in a column concatenated together in one string
            whitespace_sub: character to substitute a whitespace
        &#34;&#34;&#34;

        self.permitted_chars = permitted_chars
        self.whitespace_sub = whitespace_sub
        self._check_chars_permitted(self.whitespace_sub)

    @abstractmethod
    def _normalize_column_name(self, column_name: str):
        pass

    def _check_chars_permitted(self, in_string: str):
        &#34;&#34;&#34;
        Checks whether characters of a string are within a permitted characters string

        Args:
            in_string: Input string

        Returns:

        Raises:
            ValueError
                If string contains characters that are not permitted

        &#34;&#34;&#34;

        for char in in_string:
            if char not in self.permitted_chars:
                raise ValueError(f&#34;Substitute: &#39;{in_string}&#39; not in permitted characters&#34;)

    def _replace_whitespace(self, in_string: str) -&gt; str:
        &#34;&#34;&#34;
        Replaces whitespaces with a substitute character
        Args:
            in_string:

        Returns:
            in_string : str
                A string with replaced whitespaces by a substitute character

        &#34;&#34;&#34;
        in_string = self.whitespace_sub.join(in_string.split())
        return in_string

    def normalize_header(self, header: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;
        Normalizes a list of columns to match the Keboola Connection Storage requirements:

        `Only alphanumeric characters and underscores are allowed in column name.
         Underscore is not allowed on the beginning.`

        It also checks for empty headers and adds a name to them so they do not remain empty

        Args:
            header:

        Returns:
            Normalized column.

        &#34;&#34;&#34;

        normalized_header = []
        empty_column_id = 1

        for column in header:
            column = self._normalize_column_name(column)
            column, empty_column_id = self._check_empty_column(column, empty_column_id)
            normalized_header.append(column)
        return normalized_header

    @staticmethod
    def _check_empty_column(column: str, empty_column_id: int) -&gt; Tuple[str, int]:
        &#34;&#34;&#34;
        Checks if header is empty and fills it in

        Headers are checked if the string is empty, and if it is a new name is given.
        If the header contains more than 0 characters it will be returned.
        Each new name is appended a number, this number is increased and return as well if the
        header is empty.

        Args:
            column:
            empty_column_id: An integer contaning a number to be appended to the new name of an empty header

        Returns:
            column (str): The new name of an empty column
            empty_header_id (int) : An integer holding the id of the next empty column string

        &#34;&#34;&#34;

        if not column:
            column = f&#34;empty_{str(empty_column_id)}&#34;
            empty_column_id += 1
        return column, empty_column_id</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="keboola.utils.header_normalizer.DefaultHeaderNormalizer" href="#keboola.utils.header_normalizer.DefaultHeaderNormalizer">DefaultHeaderNormalizer</a></li>
<li><a title="keboola.utils.header_normalizer.DictHeaderNormalizer" href="#keboola.utils.header_normalizer.DictHeaderNormalizer">DictHeaderNormalizer</a></li>
<li><a title="keboola.utils.header_normalizer.EncoderHeaderNormalizer" href="#keboola.utils.header_normalizer.EncoderHeaderNormalizer">EncoderHeaderNormalizer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="keboola.utils.header_normalizer.HeaderNormalizer.normalize_header"><code class="name flex">
<span>def <span class="ident">normalize_header</span></span>(<span>self, header: List[str]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes a list of columns to match the Keboola Connection Storage requirements:</p>
<p><code>Only alphanumeric characters and underscores are allowed in column name.
Underscore is not allowed on the beginning.</code></p>
<p>It also checks for empty headers and adds a name to them so they do not remain empty</p>
<h2 id="args">Args</h2>
<p>header:</p>
<h2 id="returns">Returns</h2>
<p>Normalized column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_header(self, header: List[str]) -&gt; List[str]:
    &#34;&#34;&#34;
    Normalizes a list of columns to match the Keboola Connection Storage requirements:

    `Only alphanumeric characters and underscores are allowed in column name.
     Underscore is not allowed on the beginning.`

    It also checks for empty headers and adds a name to them so they do not remain empty

    Args:
        header:

    Returns:
        Normalized column.

    &#34;&#34;&#34;

    normalized_header = []
    empty_column_id = 1

    for column in header:
        column = self._normalize_column_name(column)
        column, empty_column_id = self._check_empty_column(column, empty_column_id)
        normalized_header.append(column)
    return normalized_header</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="keboola.utils.header_normalizer.NormalizerStrategy"><code class="flex name class">
<span>class <span class="ident">NormalizerStrategy</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>"
Enumerator for column normalization strategies</p>
<p>&hellip;</p>
<h2 id="normalizerstrategy">Normalizerstrategy</h2>
<p>DEFAULT :
Normalize headers using a substitute character
ENCODER :
Normalize headers using a character encoder
DICT :
Normalize headers using a dictionary to replace characters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NormalizerStrategy(Enum):
    &#34;&#34;&#34;&#34;
        Enumerator for column normalization strategies

        ...

        NormalizerStrategy
        ----------
        DEFAULT :
            Normalize headers using a substitute character
        ENCODER :
            Normalize headers using a character encoder
        DICT :
            Normalize headers using a dictionary to replace characters
        &#34;&#34;&#34;
    DEFAULT = &#34;DEFAULT&#34;
    ENCODER = &#34;ENCODER&#34;
    DICT = &#34;DICT&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="keboola.utils.header_normalizer.NormalizerStrategy.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="keboola.utils.header_normalizer.NormalizerStrategy.DICT"><code class="name">var <span class="ident">DICT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="keboola.utils.header_normalizer.NormalizerStrategy.ENCODER"><code class="name">var <span class="ident">ENCODER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="keboola.utils" href="index.html">keboola.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="keboola.utils.header_normalizer.get_normalizer" href="#keboola.utils.header_normalizer.get_normalizer">get_normalizer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="keboola.utils.header_normalizer.DefaultHeaderNormalizer" href="#keboola.utils.header_normalizer.DefaultHeaderNormalizer">DefaultHeaderNormalizer</a></code></h4>
</li>
<li>
<h4><code><a title="keboola.utils.header_normalizer.DictHeaderNormalizer" href="#keboola.utils.header_normalizer.DictHeaderNormalizer">DictHeaderNormalizer</a></code></h4>
</li>
<li>
<h4><code><a title="keboola.utils.header_normalizer.EncoderHeaderNormalizer" href="#keboola.utils.header_normalizer.EncoderHeaderNormalizer">EncoderHeaderNormalizer</a></code></h4>
</li>
<li>
<h4><code><a title="keboola.utils.header_normalizer.HeaderNormalizer" href="#keboola.utils.header_normalizer.HeaderNormalizer">HeaderNormalizer</a></code></h4>
<ul class="">
<li><code><a title="keboola.utils.header_normalizer.HeaderNormalizer.normalize_header" href="#keboola.utils.header_normalizer.HeaderNormalizer.normalize_header">normalize_header</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="keboola.utils.header_normalizer.NormalizerStrategy" href="#keboola.utils.header_normalizer.NormalizerStrategy">NormalizerStrategy</a></code></h4>
<ul class="">
<li><code><a title="keboola.utils.header_normalizer.NormalizerStrategy.DEFAULT" href="#keboola.utils.header_normalizer.NormalizerStrategy.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="keboola.utils.header_normalizer.NormalizerStrategy.DICT" href="#keboola.utils.header_normalizer.NormalizerStrategy.DICT">DICT</a></code></li>
<li><code><a title="keboola.utils.header_normalizer.NormalizerStrategy.ENCODER" href="#keboola.utils.header_normalizer.NormalizerStrategy.ENCODER">ENCODER</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: docs/api-html/utils/helpers.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>keboola.utils.helpers API documentation</title>
<meta name="description" content="General helper functions and classes that are relevant in Keboola Connection environment." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>keboola.utils.helpers</code></h1>
</header>
<section id="section-intro">
<p>General helper functions and classes that are relevant in Keboola Connection environment.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
General helper functions and classes that are relevant in Keboola Connection environment.


&#34;&#34;&#34;
from enum import Enum
from typing import List, Union


class ValidatingEnum(Enum):

    @classmethod
    def list(cls):
        return list(map(lambda c: c.name, cls))

    @classmethod
    def validate_fields(cls, fields: List[Union[Enum, str]]):
        errors = []
        for f in fields:
            valid, error = cls.validate_field(f)
            if error:
                errors.append(error)
        if errors:
            raise ValueError(
                &#39;, &#39;.join(errors) + f&#39;\n Supported {cls.__name__} values are: [{cls.list()}]&#39;)

    @classmethod
    def validate_field(cls, field: Union[Enum, str]):
        error = &#39;&#39;
        valid = True
        if isinstance(field, cls):
            pass
        elif isinstance(field, str):
            if field not in cls.list():
                error = f&#39;&#34;{field}&#34; is not valid {cls.__name__} value!&#39;
                valid = False
        else:
            error = f&#39;&#34;{field}&#34; is not valid Enum {cls.__name__} type!&#39;
            valid = False

        return valid, error

    @classmethod
    def get_by_name(cls, name: Union[Enum, str]):
        instance = None
        if isinstance(name, cls):
            instance = name
        elif isinstance(name, str) and name in cls.list():
            instance = cls.__get_instance_by_name(name)
        else:
            raise TypeError(f&#39;&#34;{name}&#34; is not valid {cls.__name__} name or instance!&#39;)

        return instance

    @classmethod
    def __get_instance_by_name(cls, name: str):
        for inst in cls:
            if name == inst.name:
                return inst


def comma_separated_values_to_list(csv_string: str) -&gt; List:
    &#39;&#39;&#39;
    Coverts a string with comma separated values to a list of these values
    Args:
        csv_string : string containing comma separated values

    Returns: separated_list of parsed elements from the input

    &#39;&#39;&#39;
    if not isinstance(csv_string, str):
        raise TypeError(&#34;input must be a string&#34;)
    parsed_list = []
    if csv_string:
        parsed_list = [p.strip() for p in csv_string.split(&#34;,&#34;)]
    return parsed_list</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="keboola.utils.helpers.comma_separated_values_to_list"><code class="name flex">
<span>def <span class="ident">comma_separated_values_to_list</span></span>(<span>csv_string: str) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><p>Coverts a string with comma separated values to a list of these values</p>
<h2 id="args">Args</h2>
<p>csv_string : string containing comma separated values
Returns: separated_list of parsed elements from the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comma_separated_values_to_list(csv_string: str) -&gt; List:
    &#39;&#39;&#39;
    Coverts a string with comma separated values to a list of these values
    Args:
        csv_string : string containing comma separated values

    Returns: separated_list of parsed elements from the input

    &#39;&#39;&#39;
    if not isinstance(csv_string, str):
        raise TypeError(&#34;input must be a string&#34;)
    parsed_list = []
    if csv_string:
        parsed_list = [p.strip() for p in csv_string.split(&#34;,&#34;)]
    return parsed_list</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="keboola.utils.helpers.ValidatingEnum"><code class="flex name class">
<span>class <span class="ident">ValidatingEnum</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidatingEnum(Enum):

    @classmethod
    def list(cls):
        return list(map(lambda c: c.name, cls))

    @classmethod
    def validate_fields(cls, fields: List[Union[Enum, str]]):
        errors = []
        for f in fields:
            valid, error = cls.validate_field(f)
            if error:
                errors.append(error)
        if errors:
            raise ValueError(
                &#39;, &#39;.join(errors) + f&#39;\n Supported {cls.__name__} values are: [{cls.list()}]&#39;)

    @classmethod
    def validate_field(cls, field: Union[Enum, str]):
        error = &#39;&#39;
        valid = True
        if isinstance(field, cls):
            pass
        elif isinstance(field, str):
            if field not in cls.list():
                error = f&#39;&#34;{field}&#34; is not valid {cls.__name__} value!&#39;
                valid = False
        else:
            error = f&#39;&#34;{field}&#34; is not valid Enum {cls.__name__} type!&#39;
            valid = False

        return valid, error

    @classmethod
    def get_by_name(cls, name: Union[Enum, str]):
        instance = None
        if isinstance(name, cls):
            instance = name
        elif isinstance(name, str) and name in cls.list():
            instance = cls.__get_instance_by_name(name)
        else:
            raise TypeError(f&#39;&#34;{name}&#34; is not valid {cls.__name__} name or instance!&#39;)

        return instance

    @classmethod
    def __get_instance_by_name(cls, name: str):
        for inst in cls:
            if name == inst.name:
                return inst</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="keboola.utils.char_encoder.SupportedEncoder" href="char_encoder.html#keboola.utils.char_encoder.SupportedEncoder">SupportedEncoder</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="keboola.utils.helpers.ValidatingEnum.get_by_name"><code class="name flex">
<span>def <span class="ident">get_by_name</span></span>(<span>name: Union[enum.Enum, str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_by_name(cls, name: Union[Enum, str]):
    instance = None
    if isinstance(name, cls):
        instance = name
    elif isinstance(name, str) and name in cls.list():
        instance = cls.__get_instance_by_name(name)
    else:
        raise TypeError(f&#39;&#34;{name}&#34; is not valid {cls.__name__} name or instance!&#39;)

    return instance</code></pre>
</details>
</dd>
<dt id="keboola.utils.helpers.ValidatingEnum.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def list(cls):
    return list(map(lambda c: c.name, cls))</code></pre>
</details>
</dd>
<dt id="keboola.utils.helpers.ValidatingEnum.validate_field"><code class="name flex">
<span>def <span class="ident">validate_field</span></span>(<span>field: Union[enum.Enum, str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate_field(cls, field: Union[Enum, str]):
    error = &#39;&#39;
    valid = True
    if isinstance(field, cls):
        pass
    elif isinstance(field, str):
        if field not in cls.list():
            error = f&#39;&#34;{field}&#34; is not valid {cls.__name__} value!&#39;
            valid = False
    else:
        error = f&#39;&#34;{field}&#34; is not valid Enum {cls.__name__} type!&#39;
        valid = False

    return valid, error</code></pre>
</details>
</dd>
<dt id="keboola.utils.helpers.ValidatingEnum.validate_fields"><code class="name flex">
<span>def <span class="ident">validate_fields</span></span>(<span>fields: List[Union[enum.Enum, str]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate_fields(cls, fields: List[Union[Enum, str]]):
    errors = []
    for f in fields:
        valid, error = cls.validate_field(f)
        if error:
            errors.append(error)
    if errors:
        raise ValueError(
            &#39;, &#39;.join(errors) + f&#39;\n Supported {cls.__name__} values are: [{cls.list()}]&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="keboola.utils" href="index.html">keboola.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="keboola.utils.helpers.comma_separated_values_to_list" href="#keboola.utils.helpers.comma_separated_values_to_list">comma_separated_values_to_list</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="keboola.utils.helpers.ValidatingEnum" href="#keboola.utils.helpers.ValidatingEnum">ValidatingEnum</a></code></h4>
<ul class="">
<li><code><a title="keboola.utils.helpers.ValidatingEnum.get_by_name" href="#keboola.utils.helpers.ValidatingEnum.get_by_name">get_by_name</a></code></li>
<li><code><a title="keboola.utils.helpers.ValidatingEnum.list" href="#keboola.utils.helpers.ValidatingEnum.list">list</a></code></li>
<li><code><a title="keboola.utils.helpers.ValidatingEnum.validate_field" href="#keboola.utils.helpers.ValidatingEnum.validate_field">validate_field</a></code></li>
<li><code><a title="keboola.utils.helpers.ValidatingEnum.validate_fields" href="#keboola.utils.helpers.ValidatingEnum.validate_fields">validate_fields</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: docs/api-html/utils/index.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>keboola.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>keboola.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .date import *  # noqa</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="keboola.utils.char_encoder" href="char_encoder.html">keboola.utils.char_encoder</a></code></dt>
<dd>
<div class="desc"><p>Get alphanumerical encoding of characters using different strategies.</p></div>
</dd>
<dt><code class="name"><a title="keboola.utils.date" href="date.html">keboola.utils.date</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="keboola.utils.header_normalizer" href="header_normalizer.html">keboola.utils.header_normalizer</a></code></dt>
<dd>
<div class="desc"><p>This module provides different strategies to normalize CSV column names
to a format supported by the [Keboola Connection …</p></div>
</dd>
<dt><code class="name"><a title="keboola.utils.helpers" href="helpers.html">keboola.utils.helpers</a></code></dt>
<dd>
<div class="desc"><p>General helper functions and classes that are relevant in Keboola Connection environment.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="keboola.utils.char_encoder" href="char_encoder.html">keboola.utils.char_encoder</a></code></li>
<li><code><a title="keboola.utils.date" href="date.html">keboola.utils.date</a></code></li>
<li><code><a title="keboola.utils.header_normalizer" href="header_normalizer.html">keboola.utils.header_normalizer</a></code></li>
<li><code><a title="keboola.utils.helpers" href="helpers.html">keboola.utils.helpers</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: src/keboola/utils/__init__.py
================================================
from .date import *  # noqa


================================================
File: src/keboola/utils/char_encoder.py
================================================
"""
Get alphanumerical encoding of characters using different strategies.

"""

from typing import Union

from .helpers import ValidatingEnum


class SupportedEncoder(ValidatingEnum):
    unicode = "unicode"
    utf8 = "utf8"


class CharEncoder:
    """
    A class used to encode characters

    ...

    Attributes
    ----------
    encoder : fnc
        a function used to encode a character with a specific strategy

    """

    def __init__(self, encode_type: Union[SupportedEncoder, str]):
        """
        Parameters
        ----------
        encode_type: str
            A string symbolizing a encoding strategy
        """

        self.encoder = self._get_encoder(encode_type)

    def encode_char(self, character):
        """encodes a character using an encoder function

        Parameters
        ----------
        character : str
            character to be encoded

        Returns
        -------
        an encoded character
        """
        return self.encoder(character)

    @staticmethod
    def _get_encoder(encode_type: Union[SupportedEncoder, str]):
        try:
            _type = SupportedEncoder.get_by_name(encode_type)
            if _type == SupportedEncoder.unicode:
                return ord
            elif _type == SupportedEncoder.utf8:
                return CharEncoder.encode_utf8
        except TypeError:
            raise ValueError(f"Encoder type : {encode_type} not supported")

    @staticmethod
    def encode_utf8(character):
        """encodes a character with utf8 encoding

        Parameters
        ----------
        character : str
            character to be encoded

        Returns
        -------
        an encoded character with utf8
        """
        return character.encode('utf8')


================================================
File: src/keboola/utils/date.py
================================================
import math
from _datetime import timedelta
from datetime import datetime
from typing import Tuple, Generator, Union, Dict, List

import dateparser
import pytz
from dateutil.relativedelta import relativedelta

date_tuple = Union[Tuple[datetime, datetime], Tuple[str, str]]
date_gen = Generator[Dict[str, datetime], None, None]
date_chunk = Union[date_gen, List]


def parse_datetime_interval(period_from: str, period_to: str, strformat: str = None) -> date_tuple:
    """
    Returns given period parameters in datetime format, or next step in back-fill mode
    along with generated last state for next iteration.

    Args:
        period_from: YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago
        period_to: YYYY-MM-DD or relative string supported by date parser e.g. 5 days ago
        strformat: A python strtime format, in which output dates will be returned. If not specified
                    function returns dates in datetime.datetime type

    Returns:
        start_date: datetime, end_date: datetime
    """

    start_date_form = dateparser.parse(period_from)
    end_date_form = dateparser.parse(period_to)
    day_diff = (end_date_form - start_date_form).days
    if day_diff < 0:
        raise ValueError("start_date cannot exceed end_date.")

    if strformat is None:
        return start_date_form, end_date_form
    else:
        return start_date_form.strftime(strformat), end_date_form.strftime(strformat)


def get_past_date(str_days_ago: str, to_date: datetime = None,
                  tz: pytz.tzinfo = pytz.utc) -> object:
    """
    Returns date in specified timezone relative to to_date parameter.

    e.g.
    '5 hours ago',
    'yesterday',
    '3 days ago',
    '4 months ago',
    '2 years ago',
    'today'

    Args:
        str_days_ago: A string specifying some kind of date, in relative or absolute format
        to_date: A date, from which the relative date will be calculated. Default: today's date
        tz: A timezone specifier of type pytz.tzinfo

    Returns:
        date: datetime
    """

    today_date = datetime.now(tz)
    if not to_date:
        to_date = today_date

    # add timezone awareness to allow date subtraction
    to_date = add_timezone_info(to_date, tz)

    try:
        today_diff = (today_date.date() - to_date.date()).days
        past_date = dateparser.parse(str_days_ago)
        past_date = past_date.replace(tzinfo=tz)
        date = past_date - relativedelta(days=today_diff)
        return date
    except TypeError as e:
        raise ValueError(
            f"Please enter valid date parameters. Some of the values ({str_days_ago}, {str(to_date)}) are "
            f"not in supported format. Raised: {e}")


def add_timezone_info(to_date: datetime, tz: pytz.tzinfo = pytz.utc) -> datetime:
    """
    Add timezone info if not present. Useful when making sure the datetime instances are offset-aware to allow
    date subtracting.
    Args:
        to_date: datetime
        tz: timezone

    Returns: datetime object with updated timezone info

    """
    if to_date.tzinfo is None:
        to_date = to_date.replace(tzinfo=tz)

    return to_date


def split_dates_to_chunks(start_date: datetime, end_date: datetime, intv: int,
                          strformat: str = "%Y-%m-%d", generator: bool = False) -> date_chunk:
    """
    Splits dates in given period into chunks of specified max size.

    Args:
        start_date: Start date, from which periods will be calculated
        end_date: End date, to which periods will be calculated
        intv: Size of interval in days
        strformat: A strftime format string

    Returns:
        list

    Usage example:
    list(split_dates_to_chunks("2018-01-01", "2018-01-04", 2, "%Y-%m-%d"))

        returns [{start_date: "2018-01-01", "end_date":"2018-01-02"}
                 {start_date: "2018-01-02", "end_date":"2018-01-04"}]
    """

    def split_dates_to_chunks_gen(start_date, end_date, intv, strformat):

        nr_days = (end_date - start_date).days

        if nr_days <= intv:
            yield {'start_date': start_date.strftime(strformat),
                   'end_date': end_date.strftime(strformat)}
        elif intv == 0:
            diff = timedelta(days=1)
            for i in range(nr_days):
                yield {'start_date': (start_date + diff * i).strftime(strformat),
                       'end_date': (start_date + diff * i).strftime(strformat)}
        else:
            nr_parts = math.ceil(nr_days / intv)
            diff = (end_date - start_date) / nr_parts
            for i in range(nr_parts):
                yield {'start_date': (start_date + diff * i).strftime(strformat),
                       'end_date': (start_date + diff * (i + 1)).strftime(strformat)}

    _gen = split_dates_to_chunks_gen(start_date, end_date, intv, strformat)

    if generator is True:
        return _gen
    else:
        return list(_gen)


================================================
File: src/keboola/utils/header_normalizer.py
================================================
"""
This module provides different strategies to normalize CSV column names
to a format supported by the [Keboola Connection Storage](https://help.keboola.com/):

`Only alphanumeric characters and underscores are allowed in column name.
Underscore is not allowed on the beginning.`

"""

import re
import string
from abc import ABC, abstractmethod
from enum import Enum
from typing import List, Tuple, Union

from .char_encoder import CharEncoder, SupportedEncoder

PERMITTED_CHARS = string.digits + string.ascii_letters + '_'

DEFAULT_WHITESPACE_SUB = "_"
DEFAULT_NON_PERMITTED_SUB = ""
DEFAULT_ENCODE_DELIM = "_"
DEFAULT_ENCODER = SupportedEncoder.unicode


class HeaderNormalizer(ABC):
    """
    Abstract class for column normalization.

    """

    def __init__(self, permitted_chars: str = PERMITTED_CHARS, whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        """

        Args:
            permitted_chars: all characters that are permitted to be in a column concatenated together in one string
            whitespace_sub: character to substitute a whitespace
        """

        self.permitted_chars = permitted_chars
        self.whitespace_sub = whitespace_sub
        self._check_chars_permitted(self.whitespace_sub)

    @abstractmethod
    def _normalize_column_name(self, column_name: str):
        pass

    def _check_chars_permitted(self, in_string: str):
        """
        Checks whether characters of a string are within a permitted characters string

        Args:
            in_string: Input string

        Returns:

        Raises:
            ValueError
                If string contains characters that are not permitted

        """

        for char in in_string:
            if char not in self.permitted_chars:
                raise ValueError(f"Substitute: '{in_string}' not in permitted characters")

    def _replace_whitespace(self, in_string: str) -> str:
        """
        Replaces whitespaces with a substitute character
        Args:
            in_string:

        Returns:
            in_string : str
                A string with replaced whitespaces by a substitute character

        """
        in_string = self.whitespace_sub.join(in_string.split())
        return in_string

    def normalize_header(self, header: List[str]) -> List[str]:
        """
        Normalizes a list of columns to match the Keboola Connection Storage requirements:

        `Only alphanumeric characters and underscores are allowed in column name.
         Underscore is not allowed on the beginning.`

        It also checks for empty headers and adds a name to them so they do not remain empty

        Args:
            header:

        Returns:
            Normalized column.

        """

        normalized_header = []
        empty_column_id = 1

        for column in header:
            column = self._normalize_column_name(column)
            column, empty_column_id = self._check_empty_column(column, empty_column_id)
            normalized_header.append(column)
        return normalized_header

    @staticmethod
    def _check_empty_column(column: str, empty_column_id: int) -> Tuple[str, int]:
        """
        Checks if header is empty and fills it in

        Headers are checked if the string is empty, and if it is a new name is given.
        If the header contains more than 0 characters it will be returned.
        Each new name is appended a number, this number is increased and return as well if the
        header is empty.

        Args:
            column:
            empty_column_id: An integer contaning a number to be appended to the new name of an empty header

        Returns:
            column (str): The new name of an empty column
            empty_header_id (int) : An integer holding the id of the next empty column string

        """

        if not column:
            column = f"empty_{str(empty_column_id)}"
            empty_column_id += 1
        return column, empty_column_id


class DefaultHeaderNormalizer(HeaderNormalizer):
    """
        A class used to normalize headers using a substitute character
    """

    def __init__(self, permitted_chars: str = PERMITTED_CHARS, forbidden_sub: str = DEFAULT_NON_PERMITTED_SUB,
                 whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        """

        Args:
            permitted_chars: all characters that are permitted to be in a column concatenated together in one string
            forbidden_sub: substitute character for a forbidden character
            whitespace_sub: character to substitute a whitespace
        """

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self._check_chars_permitted(forbidden_sub)
        self.forbidden_sub = forbidden_sub

    def _normalize_column_name(self, header: str) -> str:
        header = self._replace_whitespace(header)
        header = self._replace_forbidden(header)
        return header

    def _replace_forbidden(self, in_string: str) -> str:
        """
        Replaces forbidden characters in a string by a substitute character

        Args:
            in_string:
        Returns:
            str - fixed name

        """

        in_string = re.sub("[^" + self.permitted_chars + "]", self.forbidden_sub, in_string)
        return in_string


class EncoderHeaderNormalizer(HeaderNormalizer):
    """
    Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
    to the original values. e.g. `a#` -> `a_35_`


    """

    def __init__(self, char_encoder: Union[SupportedEncoder, str] = DEFAULT_ENCODER,
                 encode_delimiter: str = DEFAULT_ENCODE_DELIM,
                 permitted_chars: str = PERMITTED_CHARS, whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        """

        Args:
            permitted_chars:
            char_encoder: type of encoder to be used for encoding forbidden characters
            encode_delimiter : str - character to put before and after an encoded character
            whitespace_sub : str - character to substitute a whitespace
        """

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self.encode_delimiter = encode_delimiter
        self.char_encoder = CharEncoder(char_encoder)

    def _normalize_column_name(self, column_name: str) -> str:

        new_column_name = self._replace_whitespace(column_name)
        new_column_name = self._encode_non_permitted_chars(new_column_name)
        return new_column_name

    def _encode_non_permitted_chars(self, in_string: str) -> str:

        column_characters = list(in_string)
        for i, char in enumerate(column_characters):
            if char not in self.permitted_chars:
                column_characters[i] = self.encode_delimiter + str(
                    self.char_encoder.encode_char(char)) + self.encode_delimiter
        return "".join(column_characters)


class DictHeaderNormalizer(HeaderNormalizer):
    """"
        A class used to normalize headers using a dictionary to replace characters.
     e.g. `{"#":"hsh"}`
    """

    def __init__(self, replace_dict: dict, permitted_chars: str = PERMITTED_CHARS,
                 whitespace_sub: str = DEFAULT_WHITESPACE_SUB):
        """

        Args:
            replace_dict: The dictionary contains a key representing the character to be replaced and a value which
                is used to replace the key character.
            permitted_chars:
            whitespace_sub:
        """

        super().__init__(permitted_chars=permitted_chars, whitespace_sub=whitespace_sub)

        self.replace_dict = replace_dict
        self._check_dict_permitted(replace_dict)

    def _normalize_column_name(self, column_name: str) -> str:

        new_column_name = self._replace_chars_using_dict(column_name, self.replace_dict)
        return new_column_name

    @staticmethod
    def _replace_chars_using_dict(in_string: str, replace_dict: dict) -> str:
        """
        Replaces characters in a string using a dictionary

        Args:
            in_string : str
                A string containing characters to be replaced using a dictionary
            replace_dict : dict
                A dictionary where keys are characters to be substituted by their specific values

        Returns:

        """

        for key in replace_dict:
            in_string = in_string.replace(key, replace_dict[key])
        return in_string

    def _check_dict_permitted(self, in_dict: dict):
        """
        Checks whether characters of strings in a dictionary are within a permitted characters string

        """
        for key in in_dict:
            self._check_chars_permitted(in_dict[key])


class NormalizerStrategy(Enum):
    """"
        Enumerator for column normalization strategies

        ...

        NormalizerStrategy
        ----------
        DEFAULT :
            Normalize headers using a substitute character
        ENCODER :
            Normalize headers using a character encoder
        DICT :
            Normalize headers using a dictionary to replace characters
        """
    DEFAULT = "DEFAULT"
    ENCODER = "ENCODER"
    DICT = "DICT"


def get_normalizer(strategy: NormalizerStrategy, **params) -> HeaderNormalizer:
    """

    Factory method to initialize a column normalizer with various strategies:

        DEFAULT :
            Normalize headers using a substitute character

        ENCODER :
            Normalize headers by encoding character in utf8 or unicode. This enables unique mapping back
             to the original values. e.g. `a#` -> `a_35_`

                 params:
                    `char_encoder: SupportedEncoder = DEFAULT_ENCODER, encode_delimiter: str = DEFAULT_ENCODE_DELIM`
        DICT :
            Specify a dictionary with character replacements. e.g. {"#":"hsh"}

                params:
                `replace_dict`
    Args:
        strategy:
        **params:

    Returns: HeaderNormalizer

    """

    if strategy == NormalizerStrategy.DEFAULT:
        return DefaultHeaderNormalizer(**params)

    elif strategy == NormalizerStrategy.ENCODER:
        return EncoderHeaderNormalizer(**params)

    elif strategy == NormalizerStrategy.DICT:
        return DictHeaderNormalizer(**params)
    else:
        raise ValueError(f"Strategy '{strategy}' is not supported")


================================================
File: src/keboola/utils/helpers.py
================================================
"""
General helper functions and classes that are relevant in Keboola Connection environment.


"""
from enum import Enum
from typing import List, Union


class ValidatingEnum(Enum):

    @classmethod
    def list(cls):
        return list(map(lambda c: c.name, cls))

    @classmethod
    def validate_fields(cls, fields: List[Union[Enum, str]]):
        errors = []
        for f in fields:
            valid, error = cls.validate_field(f)
            if error:
                errors.append(error)
        if errors:
            raise ValueError(
                ', '.join(errors) + f'\n Supported {cls.__name__} values are: [{cls.list()}]')

    @classmethod
    def validate_field(cls, field: Union[Enum, str]):
        error = ''
        valid = True
        if isinstance(field, cls):
            pass
        elif isinstance(field, str):
            if field not in cls.list():
                error = f'"{field}" is not valid {cls.__name__} value!'
                valid = False
        else:
            error = f'"{field}" is not valid Enum {cls.__name__} type!'
            valid = False

        return valid, error

    @classmethod
    def get_by_name(cls, name: Union[Enum, str]):
        instance = None
        if isinstance(name, cls):
            instance = name
        elif isinstance(name, str) and name in cls.list():
            instance = cls.__get_instance_by_name(name)
        else:
            raise TypeError(f'"{name}" is not valid {cls.__name__} name or instance!')

        return instance

    @classmethod
    def __get_instance_by_name(cls, name: str):
        for inst in cls:
            if name == inst.name:
                return inst


def comma_separated_values_to_list(csv_string: str) -> List:
    '''
    Coverts a string with comma separated values to a list of these values
    Args:
        csv_string : string containing comma separated values

    Returns: separated_list of parsed elements from the input

    '''
    if not isinstance(csv_string, str):
        raise TypeError("input must be a string")
    parsed_list = []
    if csv_string:
        parsed_list = [p.strip() for p in csv_string.split(",")]
    return parsed_list


================================================
File: tests/__init__.py
================================================
import pathlib
import sys

# just in case include in path
sys.path.insert(0, str(pathlib.Path(__file__).resolve().parents[1].joinpath('src')))


================================================
File: tests/test_char_encoder.py
================================================
import unittest
from src.keboola.utils.char_encoder import CharEncoder


class TestFormatterUtils(unittest.TestCase):
    def test_unicode_encode_char(self):
        char_encoder = CharEncoder("unicode")
        encoded_char = char_encoder.encode_char("#")
        self.assertEqual(encoded_char, 35)

    def test_utf8_encode_char(self):
        char_encoder = CharEncoder("utf8")
        encoded_char = char_encoder.encode_char("š")
        self.assertEqual(encoded_char, b'\xc5\xa1')


================================================
File: tests/test_date.py
================================================
import dateparser
import datetime
import types
import unittest
import pytz

import keboola.utils.date as dutils


class TestDateUtils(unittest.TestCase):

    def test_parse_datetime_interval_success(self):
        period_1 = '5 days ago'
        period_2 = 'yesterday'
        dt_format = '%Y-%m-%d'

        period_1_str = dateparser.parse(period_1).strftime(dt_format)
        period_2_str = dateparser.parse(period_2).strftime(dt_format)

        self.assertTupleEqual((period_1_str, period_2_str),
                              dutils.parse_datetime_interval(period_1, period_2, dt_format))

    def test_get_past_date(self):
        str_days_ago = '3 days ago'
        tz = pytz.timezone('Europe/Prague')
        to_date = datetime.datetime(2021, 3, 10, 10, 0, 0, tzinfo=tz)

        expected_result = datetime.datetime(2021, 3, 7, 10, 0, 0).strftime('%Y-%m-%d')

        self.assertEqual(expected_result,
                         dutils.get_past_date(str_days_ago=str_days_ago, to_date=to_date, tz=tz).strftime('%Y-%m-%d'))

    def test_get_past_date_no_tz(self):
        str_days_ago = '3 days ago'
        tz = pytz.timezone('Europe/Prague')
        to_date = datetime.datetime(2021, 3, 10, 10, 0, 0)

        expected_result = datetime.datetime(2021, 3, 7, 10, 0, 0).strftime('%Y-%m-%d')

        self.assertEqual(expected_result,
                         dutils.get_past_date(str_days_ago=str_days_ago, to_date=to_date, tz=tz).strftime('%Y-%m-%d'))

    def test_parse_datetime_interval_fail(self):
        period_1 = '5 days ago'
        period_2 = 'yesterday'

        with self.assertRaises(ValueError, msg='start_date cannot exceed end_date.'):
            dutils.parse_datetime_interval(period_2, period_1)

    def test_split_dates_to_chunks_list_interval_0(self):
        expected_result = [
            {'start_date': '2021-01-01', 'end_date': '2021-01-01'},
            {'start_date': '2021-01-02', 'end_date': '2021-01-02'},
            {'start_date': '2021-01-03', 'end_date': '2021-01-03'},
            {'start_date': '2021-01-04', 'end_date': '2021-01-04'},
        ]

        dt_1 = datetime.datetime(2021, 1, 1, 0, 0, 0, tzinfo=pytz.UTC)
        dt_2 = datetime.datetime(2021, 1, 5, 0, 0, 0, tzinfo=pytz.UTC)
        dt_f = '%Y-%m-%d'

        self.assertCountEqual(expected_result,
                              dutils.split_dates_to_chunks(dt_1, dt_2, 0, dt_f, generator=False))

    def test_split_dates_to_chunks_list_interval_lower_than_nr(self):
        expected_result = [
            {'start_date': '2021-01-01', 'end_date': '2021-01-02'},
            {'start_date': '2021-01-02', 'end_date': '2021-01-04'},
            {'start_date': '2021-01-04', 'end_date': '2021-01-06'},
        ]

        dt_1 = datetime.datetime(2021, 1, 1, 0, 0, 0, tzinfo=pytz.UTC)
        dt_2 = datetime.datetime(2021, 1, 6, 0, 0, 0, tzinfo=pytz.UTC)
        dt_f = '%Y-%m-%d'

        self.assertCountEqual(expected_result,
                              dutils.split_dates_to_chunks(dt_1, dt_2, 2, dt_f, generator=False))

    def test_split_dates_to_chunks_list_interval_higher_than_nr(self):
        expected_result = [
            {'start_date': '2021-01-01', 'end_date': '2021-01-06'}
        ]

        dt_1 = datetime.datetime(2021, 1, 1, 0, 0, 0, tzinfo=pytz.UTC)
        dt_2 = datetime.datetime(2021, 1, 6, 0, 0, 0, tzinfo=pytz.UTC)
        dt_f = '%Y-%m-%d'

        self.assertCountEqual(expected_result,
                              dutils.split_dates_to_chunks(dt_1, dt_2, 10, dt_f, generator=False))

    def test_split_dates_to_chunks_gen_interval_0(self):
        expected_result = [
            {'start_date': '2021-01-01', 'end_date': '2021-01-01'},
            {'start_date': '2021-01-02', 'end_date': '2021-01-02'},
            {'start_date': '2021-01-03', 'end_date': '2021-01-03'},
            {'start_date': '2021-01-04', 'end_date': '2021-01-04'},
        ]

        dt_1 = datetime.datetime(2021, 1, 1, 0, 0, 0, tzinfo=pytz.UTC)
        dt_2 = datetime.datetime(2021, 1, 5, 0, 0, 0, tzinfo=pytz.UTC)
        dt_f = '%Y-%m-%d'

        date_gen = dutils.split_dates_to_chunks(dt_1, dt_2, 0, dt_f, generator=True)

        self.assertIsInstance(date_gen, types.GeneratorType)
        self.assertCountEqual(expected_result, list(date_gen))

    def test_split_dates_to_chunks_gen_interval_lower_than_nr(self):
        expected_result = [
            {'start_date': '2021-01-01', 'end_date': '2021-01-02'},
            {'start_date': '2021-01-02', 'end_date': '2021-01-04'},
            {'start_date': '2021-01-04', 'end_date': '2021-01-06'},
        ]

        dt_1 = datetime.datetime(2021, 1, 1, 0, 0, 0, tzinfo=pytz.UTC)
        dt_2 = datetime.datetime(2021, 1, 6, 0, 0, 0, tzinfo=pytz.UTC)
        dt_f = '%Y-%m-%d'

        date_gen = dutils.split_dates_to_chunks(dt_1, dt_2, 2, dt_f, generator=True)

        self.assertIsInstance(date_gen, types.GeneratorType)
        self.assertCountEqual(expected_result, list(date_gen))

    def test_split_dates_to_chunks_gen_interval_higher_than_nr(self):
        expected_result = [
            {'start_date': '2021-01-01', 'end_date': '2021-01-06'}
        ]

        dt_1 = datetime.datetime(2021, 1, 1, 0, 0, 0, tzinfo=pytz.UTC)
        dt_2 = datetime.datetime(2021, 1, 6, 0, 0, 0, tzinfo=pytz.UTC)
        dt_f = '%Y-%m-%d'

        date_gen = dutils.split_dates_to_chunks(dt_1, dt_2, 10, dt_f, generator=True)

        self.assertIsInstance(date_gen, types.GeneratorType)
        self.assertCountEqual(expected_result, list(date_gen))


================================================
File: tests/test_header_normalizer.py
================================================
import unittest

from keboola.utils.header_normalizer import get_normalizer, NormalizerStrategy


class TestFormatterUtils(unittest.TestCase):
    def test_normalize_header_default(self):
        head_norm = get_normalizer(strategy=NormalizerStrategy.DEFAULT)
        headers_1 = ["name", "age", "email"]
        norm_headers_1 = head_norm.normalize_header(headers_1)
        self.assertEqual(norm_headers_1, ["name", "age", "email"])

        headers_2 = ["name_lastname", "ag e", "email@domain.com", "123"]
        norm_headers_2 = head_norm.normalize_header(headers_2)
        self.assertEqual(norm_headers_2, ["name_lastname", "ag_e", "emaildomaincom", "123"])

        headers_3 = ["&*D", "#%^", "email@domain.com", "123"]
        norm_headers_3 = head_norm.normalize_header(headers_3)
        self.assertEqual(norm_headers_3, ["D", "empty_1", "emaildomaincom", "123"])

    def test_normalize_header_special_replace_non_permitted(self):
        head_norm = get_normalizer(strategy=NormalizerStrategy.DEFAULT, forbidden_sub="_")
        headers_1 = ["name", "age", "email"]
        norm_headers_1 = head_norm.normalize_header(headers_1)
        self.assertEqual(norm_headers_1, ["name", "age", "email"])

        headers_2 = ["name_lastname", "age", "email@domain.com", "123"]
        norm_headers_2 = head_norm.normalize_header(headers_2)
        self.assertEqual(norm_headers_2, ["name_lastname", "age", "email_domain_com", "123"])

        headers_3 = ["&*D", "#%^", "email@domain.com", "123"]
        norm_headers_3 = head_norm.normalize_header(headers_3)
        self.assertEqual(norm_headers_3, ["__D", "___", "email_domain_com", "123"])

    def test_sub_not_permitted_raises_exception(self):
        with self.assertRaises(ValueError):
            get_normalizer(strategy=NormalizerStrategy.DEFAULT, forbidden_sub="#")
        with self.assertRaises(ValueError):
            get_normalizer(strategy=NormalizerStrategy.DEFAULT, whitespace_sub="#")
        with self.assertRaises(ValueError):
            get_normalizer(strategy=NormalizerStrategy.DICT, replace_dict={"_": "#"})

    def test_replace_chars_using_dict(self):
        head_norm = get_normalizer(strategy=NormalizerStrategy.DICT, replace_dict={"#": "_hsh_"})
        headers = ["#name", "ag#e", "email"]
        norm_headers = head_norm.normalize_header(headers)
        self.assertEqual(norm_headers, ["_hsh_name", "ag_hsh_e", "email"])

    def test_replace_whitespace(self):
        head_norm = get_normalizer(strategy=NormalizerStrategy.DEFAULT, whitespace_sub="_w_")
        headers = ["n ame", "ag\te", "ema \n il"]
        norm_headers = head_norm.normalize_header(headers)
        self.assertEqual(norm_headers, ["n_w_ame", "ag_w_e", "ema_w_il"])

    def test_replace_not_permitted(self):
        head_norm = get_normalizer(strategy=NormalizerStrategy.DEFAULT, permitted_chars="abcd#$_")
        headers = ["dactor#fd", "a*ruas$", "48DHBb#@"]
        norm_headers = head_norm.normalize_header(headers)
        self.assertEqual(norm_headers, ['dac#d', 'aa$', 'b#'])

    def test_normalize_header_encoding(self):
        head_norm = get_normalizer(strategy=NormalizerStrategy.ENCODER, char_encoder="unicode")
        headers = ["dactor#fd", "a*ruas$", "48DHBb#@"]
        norm_headers = head_norm.normalize_header(headers)
        self.assertEqual(norm_headers, ['dactor_35_fd', 'a_42_ruas_36_', '48DHBb_35__64_'])


================================================
File: tests/test_helpers.py
================================================
import unittest
import keboola.utils.helpers as hutils


class TestFormatterUtils(unittest.TestCase):
    def test_comma_separated_values_to_list(self):
        csv_string_1 = '1,2,3,4,5'
        csv_list_1 = hutils.comma_separated_values_to_list(csv_string_1)
        self.assertEqual(csv_list_1, ['1', '2', '3', '4', '5'])
        csv_string_2 = 'name,age,email'
        csv_list_2 = hutils.comma_separated_values_to_list(csv_string_2)
        self.assertEqual(csv_list_2, ['name', 'age', 'email'])
        csv_string_3 = 'asdh7,asdhj$#@,p_.sd,96,5'
        csv_list_3 = hutils.comma_separated_values_to_list(csv_string_3)
        self.assertEqual(csv_list_3, ['asdh7', 'asdhj$#@', 'p_.sd', '96', '5'])

    def test_comma_separated_values_to_list_throws_type_error(self):
        with self.assertRaises(TypeError):
            hutils.comma_separated_values_to_list(123)

    def test_comma_separated_values_to_list_empty_string(self):
        csv_string_1 = ''
        csv_list_1 = hutils.comma_separated_values_to_list(csv_string_1)
        self.assertEqual(csv_list_1, [])


================================================
File: .github/workflows/deploy.yml
================================================
name: Build & Upload Python Package to PYPI production

on:
  release:
    types: [ published ]
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.7'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel twine
          pip install flake8 pytest
          pip install -r requirements.txt
      - name: Lint with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 src/ --config=flake8.cfg
      - name: Test with pytest
        run: |
          pytest tests
      - name: Build and publish
        env:
          TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}
        run: |
          python setup.py sdist bdist_wheel
          twine upload dist/*

================================================
File: .github/workflows/deploy_to_test.yml
================================================
name: Build & Deploy Python Package To Test PYPI

on:
  create:
    tags:
      - 0.*a
      - 1.*a


jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.7'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel twine
          pip install flake8 pytest
          pip install -r requirements.txt
      - name: Lint with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 src/ --config=flake8.cfg
      - name: Test with pytest
        run: |
          pytest tests
      - name: Build and publish
        env:
          TWINE_USERNAME: ${{ secrets.PYPI_USERNAME_TEST }}
          TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD_TEST }}
        run: |
          python setup.py sdist bdist_wheel
          twine upload --repository testpypi dist/*

================================================
File: .github/workflows/push_dev.yml
================================================
name: Build & Test

on: [ push ]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [ 3.7 ]

    steps:
      - uses: actions/checkout@v2
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest
          pip install -r requirements.txt
      - name: Lint with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 src/ --config=flake8.cfg
      - name: Test with pytest
        run: |
          pytest tests

