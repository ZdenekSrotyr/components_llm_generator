Directory structure:
└── keboola-python-http-client/
    ├── README.md
    ├── LICENSE
    ├── flake8.cfg
    ├── requirements.txt
    ├── setup.py
    ├── docs/
    │   └── api-html/
    │       └── http_client/
    │           ├── http.html
    │           └── index.html
    ├── src/
    │   └── keboola/
    │       └── http_client/
    │           ├── __init__.py
    │           └── http.py
    ├── tests/
    │   ├── __init__.py
    │   └── test_http.py
    └── .github/
        └── workflows/
            ├── deploy.yml
            ├── deploy_to_test.yml
            └── push_dev.yml

================================================
File: README.md
================================================
# Python HTTP Client

## Introduction

![Build & Test](https://github.com/keboola/python-http-client/workflows/Build%20&%20Test/badge.svg?branch=main)
[![Code Climate](https://codeclimate.com/github/keboola/python-http-client/badges/gpa.svg)](https://codeclimate.com/github/keboola/python-http-client)
[![PyPI version](https://badge.fury.io/py/keboola.http-client.svg)](https://badge.fury.io/py/keboola.http-client)

This library serves as tool to work effectively when sending requests to external services. The library wraps on top of the `requests` library and implements a couple useful method, such as in-built retry, exception raising, etc.

It is being developed by the Keboola Data Services team and officially supported by Keboola. It aims to simplify the Keboola Component creation process, by removing the necessity to write complicated code to work with the APIs effectively.

## Links

- API Documentation: [API Docs](https://htmlpreview.github.io/?https://raw.githubusercontent.com/keboola/python-http-client/main/docs/api-html/http_client/http.html)
- Source code: [https://github.com/keboola/python-http-client](https://github.com/keboola/python-http-client)
- PYPI project code: [https://pypi.org/project/keboola.http-client](https://pypi.org/project/keboola.http-client)
- Documentation: [https://developers.keboola.com/extend/component/python-component-library](https://developers.keboola.com/extend/component/python-component-library)

## Quick Start

### Installation

The package may be installed via PIP:

```
pip install keboola.http-client
```

### Structure and Functionality

The package contains a single core module:
- `keboola.http_client` - Contains the `HttpClient` class for easy manipulation with APIs and external services

### `HttpClient`

The core class that serves as a tool to communicate with external services. The class is a wrapper around the `requests` library with implemented retry mechanism, and automatic error handling in case of HTTP error returned.

For each HTTP method, following methods are implemented in the `HttpClient`:
- GET - `get()`, `get_raw()`
- POST - `post()`, `post_raw()`
- PATCH - `patch()`, `patch_raw()`
- UPDATE - `update()`, `update_raw()`
- PUT - `put()`, `put_raw()`
- DELETE - `delete()`, `delete_raw()`

The difference between `_raw()` methods and their non-`_raw()` counterparts is, that raw methods will return `requests.Response` object, while non-raw methods will return a json body if the request is successful and raise an error if an HTTP error is encountered.

All abovementioned methods support all parameters supported by `requests.request()` functions - as described in the [documentation](https://requests.readthedocs.io/en/latest/api/#main-interface).

#### Initialization

The core class is `keboola.http_client.HttpClient`, which can be initialized by specifying the `base_url` parameter:

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://connection.keboola.com/v2/storage/'
cl = HttpClient(BASE_URL)
```

#### Default arguments

For `HttpClient`, it is possible to define default arguments, which will be sent with every request. It's possible to define `default_http_header`, `auth_header` and `default_params` - a default header, a default authentication header and default parameters, respectively.

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://connection.keboola.com/v2/storage/'
AUTH_HEADER = {
    'x-storageapi-token': '1234-STORAGETOKENSTRING'
}
DEFAULT_PARAMS = {
    'include': 'columns'
}
DEFAULT_HEADER = {
    'Content-Type': 'application/json'
}

cl = HttpClient(BASE_URL, default_http_header=DEFAULT_HEADER,
                auth_header=AUTH_HEADER, default_params=DEFAULT_PARAMS)
```

#### Basic authentication

By specifying the `auth` argument, the `HttpClient` will utilize the basic authentication.

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://connection.keboola.com/v2/storage/'
USERNAME = 'TestUser'
PASSWORD = '@bcd1234'

cl = HttpClient(BASE_URL, auth=(USERNAME, PASSWORD))
```

#### Simple POST request

Making a simple POST request using `post_raw()` method.

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://www.example.com/change'
cl = HttpClient(BASE_URL)

data = {'attr_1': 'value_1', 'attr_2': 'value_2'}
header = {'content-type': 'application/json'}
response = cl.post_raw(data=data, headers=header)

if response.ok is not True:
    raise ValueError(response.json())
else:
    print(response.json())
```

Making a simple POST request using `post()` method.

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://www.example.com/change'
cl = HttpClient(BASE_URL)

data = {'attr_1': 'value_1', 'attr_2': 'value_2'}
header = {'content-type': 'application/json'}
response = cl.post(data=data, headers=header)
```

#### Working with URL paths

Each of the methods takes an optional positional argument `endpoint_path`. If specified, the value of the `endpoint_path` will be appended to the URL specified in the `base_url` parameter, when initializing the class. When appending the `endpoint_path`, the [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin) function is used.

The below code will send a POST request to the URL `https://example.com/api/v1/events`:

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://example.com/api/v1'
cl = HttpClient(BASE_URL)

header = {'token': 'token_value'}
cl.post_raw('events', headers=header)
```

It is also possible to override this behavior by using parameter `is_absolute_path=True`. If specified, the value of `endpoint_path` will not be appended to the `base_url` parameter, but will rather be used as an absolute URL to which the HTTP request will be made.

In the below code, the `base_url` parameter is set to `https://example.com/api/v1`, but the base URL will be overriden by specifying `is_absolute_path=True` and the HTTP request will be made to the URL specified in the `post()` request - `https://anothersite.com/v2`.

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://example.com/api/v1'
cl = HttpClient(BASE_URL)

header = {'token': 'token_value'}
cl.post_raw('https://anothersite.com/v2', headers=header, is_absolute_path=True)
```

#### Raw request Example

A simple request made with default authentication header and parameters.

```python
import os
from keboola.http_client import HttpClient

BASE_URL = 'https://connection.keboola.com/v2/'
TOKEN = os.environ['TOKEN']

cl = HttpClient(BASE_URL, auth_header={'x-storageapi-token': TOKEN})

request_params = {'exclude': 'components'}
response = cl.get_raw('storage', params=request_params)

if response.ok is True:
    print(response.json())
```

#### Building HTTP client based on HTTPClient Example

This example demonstrates the default use of the HTTPClient as a base for REST API clients.

```python
from keboola.http_client import HttpClient

BASE_URL = 'https://connection.eu-central-1.keboola.com/v2/storage'
MAX_RETRIES = 10


class KBCStorageClient(HttpClient):

    def __init__(self, storage_token):
        HttpClient.__init__(self, base_url=BASE_URL, max_retries=MAX_RETRIES, backoff_factor=0.3,
                            status_forcelist=(429, 500, 502, 504),
                            auth_header={"X-StorageApi-Token": storage_token})

    def get_files(self, show_expired=False):
        params = {"showExpired": show_expired}
        return self.get('files', params=params)

cl = KBCStorageClient("my_token")

print(cl.get_files())
```

================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2021 Keboola

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
File: flake8.cfg
================================================
[flake8]
exclude =
    .git,
    __pycache__,
    tests,
    mapping.py,
    __init__.py
max-line-length = 119

# F812: list comprehension redefines ...
# H101: Use TODO(NAME)
# H202: assertRaises Exception too broad
# H233: Python 3.x incompatible use of print operator
# H301: one import per line
# H306: imports not in alphabetical order (time, os)
# H401: docstring should not start with a space
# H403: multi line docstrings should end on a new line
# H404: multi line docstring should start without a leading new line
# H405: multi line docstring summary not separated with an empty line
# H501: Do not use self.__dict__ for string formatting
ignore = F812,H101,H202,H233,H301,H306,H401,H403,H404,H405,H501

================================================
File: requirements.txt
================================================
requests

================================================
File: setup.py
================================================
import setuptools

with open("README.md", "r") as fh:
    long_description = fh.read()

project_urls = {
    'Documentation': 'https://htmlpreview.github.io/?https://raw.githubusercontent.com/keboola/'
                     'python-http-client/main/docs/api-html/http_client/http.html'
}

setuptools.setup(
    name="keboola.http_client",
    version="1.0.1",
    author="Keboola KDS Team",
    project_urls=project_urls,
    setup_requires=['pytest-runner', 'flake8'],
    tests_require=['pytest'],
    install_requires=[
        'requests'
    ],
    author_email="support@keboola.com",
    description="General HTTP requests library for Python applications running in Keboola Connection environment",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/keboola/python-http-client",
    packages=['keboola.http_client'],
    package_dir={'': 'src'},
    include_package_data=True,
    zip_safe=False,
    test_suite='tests',
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Intended Audience :: Developers",
        "Intended Audience :: Information Technology",
        "Intended Audience :: Education",
        "Topic :: Software Development :: Libraries",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Development Status :: 4 - Beta"
    ],
    python_requires='>=3.7'
)


================================================
File: docs/api-html/http_client/index.html
================================================
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>keboola.http_client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>keboola.http_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .http import HttpClient  # noqa</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="keboola.http_client.http" href="http.html">keboola.http_client.http</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="keboola.http_client.http" href="http.html">keboola.http_client.http</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

================================================
File: src/keboola/http_client/__init__.py
================================================
from .http import HttpClient  # noqa


================================================
File: src/keboola/http_client/http.py
================================================
import functools
import logging
from urllib.parse import urlparse, urljoin, quote, urlencode
from http.cookiejar import CookieJar
from typing import Dict, Union, Tuple, Optional

import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

Cookie = Union[Dict[str, str], CookieJar]

METHOD_RETRY_WHITELIST = ('GET', 'POST', 'PATCH', 'UPDATE', 'PUT', 'DELETE')
ALLOWED_METHODS = ['GET', 'POST', 'PATCH', 'UPDATE', 'PUT', 'DELETE']


class HttpClient:
    """
    Base class for implementing a simple HTTP client. Typically used as a base for a REST service client.


    Usage:

    ```python
    from keboola.http_client import HttpClient

    BASE_URL = 'https://connection.keboola.com/v2/storage/'
    AUTH_HEADER = {
        'x-storageapi-token': '1234-STORAGETOKENSTRING'
    }
    DEFAULT_PARAMS = {
        'include': 'columns'
    }
    DEFAULT_HEADER = {
        'Content-Type': 'application/json'
    }

    cl = HttpClient(BASE_URL, default_http_header=DEFAULT_HEADER,
                    auth_header=AUTH_HEADER, default_params=DEFAULT_PARAMS)

    files_response = cl.get("files", params={"showExpired": True})
    ```

    """

    def __init__(self, base_url: str, max_retries: int = 10, backoff_factor: float = 0.3,
                 status_forcelist: Tuple[int, ...] = (500, 502, 504), default_http_header: Dict = None,
                 auth_header: Dict = None, auth: Tuple = None, default_params: Dict = None,
                 allowed_methods: Tuple = METHOD_RETRY_WHITELIST):
        """
        Create an endpoint.

        Args:
            base_url: The base URL for this endpoint. e.g. https://exampleservice.com/api_v1/
            max_retries: Total number of retries to allow.
            backoff_factor:  A back-off factor to apply between attempts.
            status_forcelist:  A set of HTTP status codes that we should force a retry on. e.g. [500,502]
            default_http_header: Default header to be sent with each request
                eg. ```{
                        'Content-Type' : 'application/json',
                        'Accept' : 'application/json'
                    }```
            auth_header: Auth header to be sent with each request
                eg. `{'Authorization': 'Bearer ' + token}`
            auth: Default Authentication tuple or object to attach to (from  requests.Session().auth).
                eg. auth = (user, password)
            default_params: default parameters to be sent with each request eg. `{'param':'value'}`
            allowed_methods (tuple): Set of upper-cased HTTP method verbs that we should retry on.
        """
        if base_url is None:
            raise ValueError("Base URL is required.")
        # Add trailing slash because of nature of urllib.parse.urljoin()
        self.base_url = base_url if base_url.endswith('/') else base_url + '/'
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
        self.status_forcelist = status_forcelist
        self._auth = auth
        self._auth_header = auth_header if auth_header else {}
        self._default_header = default_http_header if default_http_header else {}
        self._default_params = default_params
        self.allowed_methods = allowed_methods

    def _requests_retry_session(self, session=None):
        session = session or requests.Session()
        retry = Retry(
            total=self.max_retries,
            read=self.max_retries,
            connect=self.max_retries,
            backoff_factor=self.backoff_factor,
            status_forcelist=self.status_forcelist,
            allowed_methods=self.allowed_methods
        )
        adapter = HTTPAdapter(max_retries=retry)
        session.mount('http://', adapter)
        session.mount('https://', adapter)
        return session

    def _build_url(self, endpoint_path: Optional[str] = None, is_absolute_path=False):
        # build URL Specification
        url_path = str(endpoint_path).strip() if endpoint_path is not None else ''

        if not url_path:
            return self.base_url

        if not is_absolute_path:
            full_path = urljoin(self.base_url, url_path)
            parsed = urlparse(full_path)
            encoded_path = quote(parsed.path, safe="/()=-")
            query = f"?{parsed.query}" if parsed.query else ""
            return f"{parsed.scheme}://{parsed.netloc}{encoded_path}{query}"

        parsed = urlparse(endpoint_path)
        encoded_path = quote(parsed.path, safe="/()=-")
        query = f"?{urlencode(parsed.query, safe='&=')}" if parsed.query else ""
        return f"{parsed.scheme}://{parsed.netloc}{encoded_path}{query}"

    def _request_raw(self, method: str, endpoint_path: Optional[str] = None, **kwargs) -> requests.Response:
        """
        Construct a requests call with args and kwargs and process the
        results.

        Args:
            method: A HTTP method to be used. One of PUT/POST/PATCH/GET/UPDATE/DELETE
            endpoint_path (Optional[str]): Optional full URL or a relative URL path. If empty the base_url is used.
            **kwargs: Key word arguments to pass to the
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).
                Accepts supported params in requests.sessions.Session#request
                eg. params = {'locId':'1'}, header = {some additional header}
                parameters and headers are appended to the default ones
                ignore_auth  - True to skip authentication
                is_absolute_path - False to append URL to base url; True to override base url with value of url arg.

        Returns:
            A [`requests.Response`](https://requests.readthedocs.io/en/latest/api/#requests.Response) object.
        """
        s = requests.Session()

        # build URL Specification
        is_absolute_path = kwargs.pop('is_absolute_path', False)
        url = self._build_url(endpoint_path, is_absolute_path)

        # Update headers
        headers = kwargs.pop('headers', {})
        if headers is None:
            headers = {}

        # Default headers
        headers.update(self._default_header)

        # Auth headers
        if kwargs.pop('ignore_auth', False) is False:
            headers.update(self._auth_header)
            s.headers.update(headers)
            s.auth = self._auth

        s.headers.update(headers)

        # Update parameters
        params = kwargs.pop('params', {})
        if params is None:
            params = {}

        # Default parameters
        if self._default_params is not None:
            all_pars = {**params, **self._default_params}
            kwargs.update({'params': all_pars})

        else:
            kwargs.update({'params': params})

        r = self._requests_retry_session(session=s).request(method, url, **kwargs)
        return r

    def response_error_handling(func):
        """Function, that handles response handling of HTTP requests.
        """

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            try:
                r = func(*args, **kwargs)
                r.raise_for_status()
            except requests.HTTPError as e:
                logging.warning(e, exc_info=True)
                # Handle different error codes
                raise
            else:
                return r.json()

        return wrapper

    def update_auth_header(self, updated_header: Dict, overwrite: bool = False):
        """
        Updates the default auth header by providing new values.

        Args:
            updated_header: An updated header which will be used to update the current header.
            overwrite: If `False`, the existing header will be updated with new header. If `True`, the new header will
                overwrite (replace) the current authentication header.
        """

        if overwrite is False:
            self._auth_header.update(updated_header)
        else:
            self._auth_header = updated_header

    def get_raw(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None,
                is_absolute_path: bool = False, cookies: Cookie = None,
                ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests GET call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A [`requests.Response`](https://requests.readthedocs.io/en/latest/api/#requests.Response) object.
        """

        method = 'GET'
        return self._request_raw(method, endpoint_path, params=params, headers=headers, cookies=cookies,
                                 is_absolute_path=is_absolute_path, ignore_auth=ignore_auth, **kwargs)

    @response_error_handling
    def get(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None,
            is_absolute_path: bool = False, cookies: Cookie = None,
            ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests GET call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A JSON-encoded response of the request.

        Raises:
            requests.HTTPError: If the API request fails.
        """

        return self.get_raw(endpoint_path, params=params, headers=headers, cookies=cookies,
                            is_absolute_path=is_absolute_path, ignore_auth=ignore_auth, **kwargs)

    def post_raw(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None,
                 data: Dict = None, json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None,
                 files: Dict = None, ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests POST call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A [`requests.Response`](https://requests.readthedocs.io/en/latest/api/#requests.Response) object.
        """

        method = 'POST'
        return self._request_raw(method, endpoint_path, params=params, headers=headers, data=data, json=json,
                                 cookies=cookies, is_absolute_path=is_absolute_path, files=files,
                                 ignore_auth=ignore_auth, **kwargs)

    @response_error_handling
    def post(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None, data: Dict = None,
             json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None, files: Dict = None,
             ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests POST call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A JSON-encoded response of the request.

        Raises:
            requests.HTTPError: If the API request fails.
        """

        return self.post_raw(endpoint_path, params=params, headers=headers, data=data, json=json, cookies=cookies,
                             is_absolute_path=is_absolute_path, files=files, ignore_auth=ignore_auth, **kwargs)

    def patch_raw(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None,
                  data: Dict = None, json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None,
                  files: Dict = None, ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests PATCH call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A [`requests.Response`](https://requests.readthedocs.io/en/latest/api/#requests.Response) object.
        """

        method = 'PATCH'
        return self._request_raw(method, endpoint_path, params=params, headers=headers, data=data, json=json,
                                 cookies=cookies, is_absolute_path=is_absolute_path, files=files,
                                 ignore_auth=ignore_auth, **kwargs)

    @response_error_handling
    def patch(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None, data: Dict = None,
              json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None, files: Dict = None,
              ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests PATCH call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A JSON-encoded response of the request.

        Raises:
            requests.HTTPError: If the API request fails.
        """

        return self.patch_raw(endpoint_path, params=params, headers=headers, data=data, json=json, cookies=cookies,
                              is_absolute_path=is_absolute_path, files=files, ignore_auth=ignore_auth, **kwargs)

    def update_raw(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None,
                   data: Dict = None, json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None,
                   files: Dict = None, ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests UPDATE call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A [`requests.Response`](https://requests.readthedocs.io/en/latest/api/#requests.Response) object.
        """

        method = 'UPDATE'
        return self._request_raw(method, endpoint_path, params=params, headers=headers, data=data, json=json,
                                 cookies=cookies, is_absolute_path=is_absolute_path, files=files,
                                 ignore_auth=ignore_auth, **kwargs)

    @response_error_handling
    def update(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None, data: Dict = None,
               json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None, files: Dict = None,
               ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests UPDATE call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A JSON-encoded response of the request.

        Raises:
            requests.HTTPError: If the API request fails.
        """

        return self.update_raw(endpoint_path, params=params, headers=headers, data=data, json=json, cookies=cookies,
                               is_absolute_path=is_absolute_path, files=files, ignore_auth=ignore_auth, **kwargs)

    def put_raw(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None,
                data: Dict = None, json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None,
                files: Dict = None, ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests PUT call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A [`requests.Response`](https://requests.readthedocs.io/en/latest/api/#requests.Response) object.
        """

        method = 'PUT'
        return self._request_raw(method, endpoint_path, params=params, headers=headers, data=data, json=json,
                                 cookies=cookies, is_absolute_path=is_absolute_path, files=files,
                                 ignore_auth=ignore_auth, **kwargs)

    @response_error_handling
    def put(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None, data: Dict = None,
            json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None, files: Dict = None,
            ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests PUT call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A JSON-encoded response of the request.

        Raises:
            requests.HTTPError: If the API request fails.
        """

        return self.put_raw(endpoint_path, params=params, headers=headers, data=data, json=json, cookies=cookies,
                            is_absolute_path=is_absolute_path, files=files, ignore_auth=ignore_auth, **kwargs)

    def delete_raw(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None,
                   data: Dict = None, json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None,
                   files: Dict = None, ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests DELETE call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A [`requests.Response`](https://requests.readthedocs.io/en/latest/api/#requests.Response) object.
        """

        method = 'DELETE'
        return self._request_raw(method, endpoint_path, params=params, headers=headers, data=data, json=json,
                                 cookies=cookies, is_absolute_path=is_absolute_path, files=files,
                                 ignore_auth=ignore_auth, **kwargs)

    @response_error_handling
    def delete(self, endpoint_path: Optional[str] = None, params: Dict = None, headers: Dict = None, data: Dict = None,
               json: Dict = None, is_absolute_path: bool = False, cookies: Cookie = None, files: Dict = None,
               ignore_auth: bool = False, **kwargs) -> requests.Response:
        """
        Constructs a requests DELETE call with specified url and kwargs to process the result.

        Args:
            endpoint_path: Relative URL path or absolute URL to which the request will be made.
                By default a relative path is expected and will be appended to the `self.base_url` value.

                Depending on the value of `is_absolute_path`, the value will be either appended to `self.base_url`,
                or used as an absolute URL.
            params: Dictionary to send in the query string for the request.
            headers: Dictionary of HTTP Headers to send with the request.
            data: Dictionary to send in the body of the request.
            json: A JSON serializable Python object to send in the body of the request.
            is_absolute_path: A boolean value specifying, whether the URL specified in `endpoint_path` parameter
                is an absolute path or not.

                If set to False, the value of `endpoint_path` will be appended to `self.base_url` using
                [`urllib.parse.urljoin()`](https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urljoin)
                function.

                If set to True, base url will be overridden and the value of the `endpoint_path` will
                used instead.
            cookies: Dict or CookieJar object of cookies to send with the request
            files: Dictionary of 'name': file-like-objects (or {'name': file-tuple}) for multipart encoding upload.
            ignore_auth: Boolean marking, whether the default auth_header should be ignored.
            **kwargs: All other keyword arguments supported by
                [`requests.request`](https://requests.readthedocs.io/en/latest/api/#requests.request).

        Returns:
            A JSON-encoded response of the request.

        Raises:
            requests.HTTPError: If the API request fails.
        """

        return self.delete_raw(endpoint_path, params=params, headers=headers, data=data, json=json, cookies=cookies,
                               is_absolute_path=is_absolute_path, files=files, ignore_auth=ignore_auth, **kwargs)


================================================
File: tests/__init__.py
================================================
import pathlib
import sys

# just in case include in path
sys.path.insert(0, str(pathlib.Path(__file__).resolve().parents[1].joinpath('src')))


================================================
File: tests/test_http.py
================================================
import unittest
from urllib.parse import urlparse, urljoin
from unittest.mock import patch

import keboola.http_client.http as client


class TestClientBase(unittest.TestCase):

    @patch.object(client.requests.Session, 'request')
    def test_post_raw_default_pars_with_none_custom_pars_passes(self, mock_post):
        url = 'http://example.com/'
        test_def_par = {"default_par": "test"}
        cl = client.HttpClient(url, default_params=test_def_par)

        # post raw
        cl.post_raw()
        mock_post.assert_called_with('POST', url, params=test_def_par, cookies=None, data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_post_default_pars_with_none_custom_pars_passes(self, mock_post):
        url = 'http://example.com/'
        test_def_par = {"default_par": "test"}
        cl = client.HttpClient(url, default_params=test_def_par)

        # post
        cl.post()
        mock_post.assert_called_with('POST', url, params=test_def_par, cookies=None, data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_post_raw_default_pars_with_custom_pars_passes(self, mock_post):
        url = 'http://example.com/'
        test_def_par = {"default_par": "test"}
        cl = client.HttpClient(url, default_params=test_def_par)

        # post_raw
        cust_par = {"custom_par": "custom_par_value"}
        cl.post_raw(params=cust_par)

        test_cust_def_par = {**test_def_par, **cust_par}
        mock_post.assert_called_with('POST', url, params=test_cust_def_par, cookies=None,
                                     data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_post_default_pars_with_custom_pars_passes(self, mock_post):
        url = 'http://example.com/'
        test_def_par = {"default_par": "test"}
        cl = client.HttpClient(url, default_params=test_def_par)

        # post
        cust_par = {"custom_par": "custom_par_value"}
        cl.post(params=cust_par)

        test_cust_def_par = {**test_def_par, **cust_par}
        mock_post.assert_called_with('POST', url, params=test_cust_def_par, cookies=None,
                                     data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_post_raw_default_pars_with_custom_pars_to_None_passes(self, mock_post):
        url = 'http://example.com/'
        test_def_par = {"default_par": "test"}
        cl = client.HttpClient(url, default_params=test_def_par)

        # post_raw
        cust_par = None
        cl.post_raw(params=cust_par)

        # post_raw changes None to empty dict
        _cust_par_transformed = {}
        test_cust_def_par = {**test_def_par, **_cust_par_transformed}
        mock_post.assert_called_with('POST', url, params=test_cust_def_par, cookies=None,
                                     data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_post_default_pars_with_custom_pars_to_None_passes(self, mock_post):
        url = 'http://example.com/'
        test_def_par = {"default_par": "test"}
        cl = client.HttpClient(url, default_params=test_def_par)

        # post_raw
        cust_par = None
        cl.post(params=cust_par)

        # post_raw changes None to empty dict
        _cust_par_transformed = {}
        test_cust_def_par = {**test_def_par, **_cust_par_transformed}
        mock_post.assert_called_with('POST', url, params=test_cust_def_par, cookies=None,
                                     data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_post_raw_with_custom_pars_passes(self, mock_post):
        url = 'http://example.com/'
        cl = client.HttpClient(url)

        # post_raw
        cust_par = {"custom_par": "custom_par_value"}
        cl.post_raw(params=cust_par)

        mock_post.assert_called_with('POST', url, params=cust_par, cookies=None, data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_post_with_custom_pars_passes(self, mock_post):
        url = 'http://example.com/'
        cl = client.HttpClient(url)

        # post_raw
        cust_par = {"custom_par": "custom_par_value"}
        cl.post(params=cust_par)

        mock_post.assert_called_with('POST', url, params=cust_par, cookies=None, data=None, json=None, files=None)

    @patch.object(client.requests.Session, 'request')
    def test_all_methods_requests_raw_with_custom_pars_passes(self, mock_request):
        url = 'http://example.com/'
        cl = client.HttpClient(url)

        # post_raw
        cust_par = {"custom_par": "custom_par_value"}

        for met in ['GET', 'POST', 'PATCH', 'UPDATE', 'PUT']:
            cl._request_raw(met, ignore_auth=False, params=cust_par)
            mock_request.assert_called_with(met, url, params=cust_par)

        cl._requests_retry_session().close()

    @patch.object(client.HttpClient, '_request_raw')
    def test_all_methods_skip_auth(self, mock_post):
        url = 'http://example.com/'
        cl = client.HttpClient(url, auth_header={"authorization": "xxx"})

        for m in ['POST', 'PATCH', 'UPDATE', 'PUT', 'DELETE']:
            method_to_call = getattr(cl, m.lower())
            method_to_call(ignore_auth=True, is_absolute_path=False)
            mock_post.assert_called_with(m, None, ignore_auth=True, params=None, headers=None,
                                         is_absolute_path=False, cookies=None, data=None, files=None, json=None)

        for m in ['GET']:
            method_to_call = getattr(cl, m.lower())
            method_to_call(ignore_auth=True, is_absolute_path=False)
            mock_post.assert_called_with(m, None, ignore_auth=True, params=None, headers=None,
                                         is_absolute_path=False, cookies=None)

    def test_request_skip_auth_header(self):
        cl = client.HttpClient('http://example.com', default_http_header={"defheader": "test"},
                               auth_header={"Authorization": "test"})
        res = cl._request_raw('POST', 'abc', ignore_auth=True)
        cl._requests_retry_session().close()
        self.assertEqual(res.request.url, 'http://example.com/abc')
        self.assertEqual(res.request.headers.get('defheader'), 'test')
        self.assertEqual(res.request.headers.get('Authorization'), None)

    def test_all_methods_raw(self):
        url = 'http://example.com'
        cl = client.HttpClient(url, default_http_header={'header1': 'headerval'},
                               auth_header={'api_token': 'abdc1234'})

        TARGET_URL = 'http://example.com/storage?exclude=componentDetails'

        for m in ['GET', 'POST']:
            method_to_call = getattr(cl, m.lower() + '_raw')
            res = method_to_call('storage', params={'exclude': 'componentDetails'},
                                 headers={'abc': '123'}, data={'attr1': 'val1'})
            self.assertEqual(res.request.url, TARGET_URL)
            self.assertEqual(res.request.headers.get('api_token'), 'abdc1234')
            self.assertEqual(res.request.headers.get('abc'), '123')
            self.assertEqual(res.request.headers.get('header1'), 'headerval')
            self.assertEqual(res.request.body, 'attr1=val1')

        cl._requests_retry_session().close()

    @patch.object(client.requests.Session, 'request')
    def test_all_methods_requests_raw_with_is_absolute_path_true(self, mock_request):
        url = 'http://example.com/'
        cl = client.HttpClient(url)

        for met in client.ALLOWED_METHODS:
            cl._request_raw(met, 'http://example2.com/v1/', ignore_auth=False, is_absolute_path=True)
            mock_request.assert_called_with(met, 'http://example2.com/v1/', params={})

        cl._requests_retry_session().close()

    @patch.object(client.requests.Session, 'request')
    def test_all_methods_requests_raw_with_is_absolute_path_false(self, mock_request):
        url = 'http://example.com/api/v1'
        cl = client.HttpClient(url)

        for met in ['GET', 'POST', 'PATCH', 'UPDATE', 'PUT']:
            cl._request_raw(met, 'events', ignore_auth=False, is_absolute_path=False)
            mock_request.assert_called_with(met, 'http://example.com/api/v1/events', params={})

        cl._requests_retry_session().close()

    @patch.object(client.requests.Session, 'request')
    def test_all_methods_kwargs(self, mock_request):
        url = 'http://example.com/api/v1'
        cl = client.HttpClient(url)

        for met in ['GET', 'POST', 'PATCH', 'UPDATE', 'PUT']:
            method_to_call = getattr(cl, met.lower())
            method_to_call(params={'par1': 'val1'}, verify=False, data={'data': '123'},
                           files={'a': '/path/to/file'}, cert='/path/to/cert', json=None)
            mock_request.assert_called_with(met, 'http://example.com/api/v1/', verify=False, data={'data': '123'},
                                            files={'a': '/path/to/file'}, cookies=None, cert='/path/to/cert',
                                            params={'par1': 'val1'}, json=None)

        cl._requests_retry_session().close()

    def test_update_auth_header_None(self):
        existing_header = None
        new_header = {'api_token': 'token_value'}

        cl = client.HttpClient('https://example.com', auth_header=existing_header)
        cl.update_auth_header(new_header, overwrite=False)
        self.assertDictEqual(cl._auth_header, new_header)

        new_header_2 = {'password': '123'}
        cl.update_auth_header(new_header_2, overwrite=True)
        self.assertDictEqual(cl._auth_header, new_header_2)

    def test_update_existing_auth_header(self):
        existing_header = {'authorization': 'value'}
        new_header = {'api_token': 'token_value'}

        cl = client.HttpClient('https://example.com', auth_header=existing_header)
        cl.update_auth_header(new_header, overwrite=False)
        self.assertDictEqual(cl._auth_header, {**existing_header, **new_header})

    def test_build_url_rel_path(self):
        url = 'https://example.com/'
        cl = client.HttpClient(url)
        self.assertEqual(urljoin(url, 'storage'), cl._build_url('storage'))

    def test_build_url_abs_path(self):
        url = 'https://example.com/'
        cl = client.HttpClient(url)
        self.assertEqual('https://example2.com/storage', cl._build_url('https://example2.com/storage', True))

    def test_build_url_empty_endpoint_path_leads_to_base_url(self):
        url = 'https://example.com/'
        cl = client.HttpClient(url)
        self.assertEqual(url, cl._build_url())
        self.assertEqual(url, cl._build_url(''))
        self.assertEqual(url, cl._build_url(None))
        self.assertEqual(url, cl._build_url('', True))
        self.assertEqual(url, cl._build_url(None, True))

    def test_build_url_base_url_appends_slash(self):
        url = 'https://example.com'
        cl = client.HttpClient(url)
        self.assertEqual('https://example.com/', cl.base_url)

    def test_build_url_with_spaces(self):
        base_url = "http://example.com/"
        cl = client.HttpClient(base_url)

        result = cl._build_url("path/with spaces")
        expected_path = "path/with%20spaces"
        parsed = urlparse(result)
        self.assertEqual(parsed.path, f"/{expected_path}")
        self.assertEqual(parsed.netloc, "example.com")
        self.assertEqual(parsed.scheme, "http")

        result = cl._build_url("path?param=space test")
        expected_query = "param=space test"
        parsed = urlparse(result)
        self.assertEqual(parsed.query, expected_query)
        self.assertEqual(parsed.path, "/path")
        self.assertEqual(parsed.netloc, "example.com")
        self.assertEqual(parsed.scheme, "http")

        absolute_result = cl._build_url("http://example.com/absolute path", is_absolute_path=True)
        expected_absolute = "http://example.com/absolute%20path"
        self.assertEqual(absolute_result, expected_absolute)

    # test based on SUPPORT-9780
    def test_build_url_with_complex_path(self):
        base_url = "http://example.com/"
        cl = client.HttpClient(base_url)

        result = cl._build_url("ucetni-denik/(datUcto>=2024-10-01 and datUcto<2024-10-30)")
        expected_path = "ucetni-denik/(datUcto%3E=2024-10-01%20and%20datUcto%3C2024-10-30)"
        parsed = urlparse(result)
        self.assertEqual(parsed.path, f"/{expected_path}")


================================================
File: .github/workflows/deploy.yml
================================================
name: Build & Upload Python Package to PYPI production

on:
  release:
    types: [ published ]
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.7'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel twine
          pip install flake8 pytest
          pip install -r requirements.txt
      - name: Lint with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 src/ --config=flake8.cfg
      - name: Test with pytest
        run: |
          pytest tests
      - name: Build and publish
        env:
          TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}
        run: |
          python setup.py sdist bdist_wheel
          twine upload dist/*

================================================
File: .github/workflows/deploy_to_test.yml
================================================
name: Build & Deploy Python Package To Test PYPI

on:
  create:
    tags:
      - 0.*a
      - 1.*a


jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.7'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel twine
          pip install flake8 pytest
          pip install -r requirements.txt
      - name: Lint with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 src/ --config=flake8.cfg
      - name: Test with pytest
        run: |
          pytest tests
      - name: Build and publish
        env:
          TWINE_USERNAME: ${{ secrets.PYPI_USERNAME_TEST }}
          TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD_TEST }}
        run: |
          python setup.py sdist bdist_wheel
          twine upload --repository testpypi dist/*

================================================
File: .github/workflows/push_dev.yml
================================================
name: Build & Test

on: [ push ]

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [ 3.7 ]

    steps:
      - uses: actions/checkout@v2
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest
          pip install -r requirements.txt
      - name: Lint with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 src/ --config=flake8.cfg
      - name: Test with pytest
        run: |
          pytest tests

